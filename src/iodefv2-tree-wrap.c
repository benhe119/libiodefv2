
























/*****
*
* Copyright (C) 2001-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@prelude-ids.com>
* Author: Nicolas Delon <nicolas.delon@prelude-ids.com>
*
* This file is part of the Libiodefv2 library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/*
 * This file was automatically generated by our generator, version 1
 *
 * Do not make changes to this file unless you know what you are doing.
 * modify the template interface file instead.
 * IODEFV2 version : RFC5070-bis-26
 * Template file: generate-tree-wrap.c.mako
 *
 */

#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/types.h>

#include "libiodefv2-inttypes.h"
#include "libiodefv2-list.h"
#include "libiodefv2-string.h"

#define LIBIODEFV2_ERROR_SOURCE_DEFAULT LIBIODEFV2_ERROR_SOURCE_IODEFV2_TREE_WRAP
#include "libiodefv2-error.h"

#include "iodefv2-time.h"
#include "iodefv2-data.h"
#include "iodefv2-class.h"
#include "iodefv2-value.h"
#include "iodefv2-object-prv.h"

#include "iodefv2-tree-wrap.h"
#include "libmissing.h"
#include "common.h"

#ifdef WIN32
# undef interface
#endif


#define LISTED_OBJECT(name, type) libiodefv2_list_t name
#define KEYLISTED_OBJECT(name, type) libiodefv2_list_t name

#define IS_KEY_LISTED(keyfield) IODEFV2_LINKED_OBJECT; libiodefv2_string_t *keyfield

#define UNION(type, var) type var; union

#define UNION_MEMBER(value, type, name) type name

#define ENUM(...) typedef enum

#define PRE_DECLARE(type, class)

#define TYPE_ID(type, id) type

#define PRIMITIVE_TYPE(type)
#define PRIMITIVE_TYPE_STRUCT(type)

#define HIDE(type, name) type name

#define REFCOUNT int refcount
#define REQUIRED(type, name) type name
#define IGNORED(type, name) type name

#define DYNAMIC_IDENT(x) uint64_t x

#define OPTIONAL_INT(type, name) type name; unsigned int name ## _is_set:1

#define IDENT(name) uint64_t name


#define iodefv2_data_copy iodefv2_data_copy_dup

#ifndef ABS
# define ABS(x) (((x) < 0) ? -(x) : (x))
#endif


/*
 * If we subtract the integer representations of two floats then that
 * will tell us how close they are. If the difference is zero, they are
 * identical. If the difference is one, they are adjacent floats.
 * In general, if the difference is n then there are n-1 floats between
 * them.
 *
 * http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm
 */
static int float_compare(float a, float b)
{
        union {
                float fval;
                int32_t ival;
        } au, bu;

        au.fval = a;
        bu.fval = b;

        /* Make aInt lexicographically ordered as a twos-complement int */
        if ( au.ival < 0 )
                au.ival = 0x80000000 - au.ival;

        /* Make bInt lexicographically ordered as a twos-complement int */
        if ( bu.ival < 0 )
                bu.ival = 0x80000000 - bu.ival;

        return (ABS(au.ival - bu.ival) <= 0) ? 0 : -1;
}



static int libiodefv2_string_copy(const libiodefv2_string_t *src, libiodefv2_string_t *dst)
{
        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! libiodefv2_string_is_empty(src) )
               return libiodefv2_string_copy_dup(src, dst);

        return 0;
}



static int get_value_from_string(iodefv2_value_t **value, libiodefv2_string_t *str, libiodefv2_bool_t is_ptr)
{
        int ret;

        if ( ! str ) {
                *value = NULL;
                return 0;
        }

        if ( ! is_ptr ) {
                ret = libiodefv2_string_clone(str, &str);
                if ( ret < 0 )
                        return ret;
        }

        ret = iodefv2_value_new_string(value, str);
        if ( ret < 0 ) {
                libiodefv2_string_destroy(str);
                return ret;
        }

        if ( is_ptr )
                libiodefv2_string_ref(str);

        return 0;
}



static int get_value_from_data(iodefv2_value_t **value, iodefv2_data_t *data, libiodefv2_bool_t is_ptr)
{
        int ret;

        if ( ! data ) {
                *value = NULL;
                return 0;
        }

        if ( ! is_ptr ) {
                ret = iodefv2_data_clone(data, &data);
                if ( ret < 0 )
                        return ret;
        }

        ret = iodefv2_value_new_data(value, data);
        if ( ret < 0 ) {
                iodefv2_data_destroy(data);
                return ret;
        }

        if ( is_ptr )
                iodefv2_data_ref(data);

        return 0;
}


static int get_value_from_time(iodefv2_value_t **value, iodefv2_time_t *time, libiodefv2_bool_t is_ptr)
{
        int ret;

        if ( ! time ) {
                *value = NULL;
                return 0;
        }

        if ( ! is_ptr ) {
                ret = iodefv2_time_clone(time, &time);
                if ( ret < 0 )
                        return ret;
        }

        ret = iodefv2_value_new_time(value, time);
        if ( ret < 0 ) {
                iodefv2_time_destroy(time);
                return ret;
        }

        if ( is_ptr )
                iodefv2_time_ref(time);
        return 0;
}


static void list_insert(libiodefv2_list_t *head, libiodefv2_list_t *item, int pos)
{
        int i = 0;
        libiodefv2_list_t *tmp;

        if ( pos == IODEFV2_LIST_APPEND )
                libiodefv2_list_add_tail(head, item);

        else if ( pos == IODEFV2_LIST_PREPEND )
                libiodefv2_list_add(head, item);

        else if ( pos >= 0 ) {
                libiodefv2_list_for_each(head, tmp) {
                        if ( i == pos )
                                break;
                        i++;
                }

                libiodefv2_list_add_tail(tmp, item);
        }

        else if ( pos < 0 ) {
                pos = -pos;
                pos--;

                libiodefv2_list_for_each_reversed(head, tmp) {
                        if ( i == pos )
                                break;
                        i++;
                }

                libiodefv2_list_add(tmp, item);
        }
}

        
/**
 * iodefv2_telephone_type_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_telephone_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_telephone_type_t iodefv2_telephone_type_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_telephone_type_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_TELEPHONE_TYPE_WIRED, "wired" },


            { IODEFV2_TELEPHONE_TYPE_MOBILE, "mobile" },


            { IODEFV2_TELEPHONE_TYPE_FAX, "fax" },


            { IODEFV2_TELEPHONE_TYPE_HOTLINE, "hotline" },


            { IODEFV2_TELEPHONE_TYPE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for telephone_type", name);

}
/**
 * iodefv2_telephone_type_to_string:
 * @val: an enumeration value for #iodefv2_telephone_type_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_telephone_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_telephone_type_to_string(iodefv2_telephone_type_t val)
{

        const struct {
              iodefv2_telephone_type_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_TELEPHONE_TYPE_WIRED, "wired" },

            { IODEFV2_TELEPHONE_TYPE_MOBILE, "mobile" },

            { IODEFV2_TELEPHONE_TYPE_FAX, "fax" },

            { IODEFV2_TELEPHONE_TYPE_HOTLINE, "hotline" },

            { IODEFV2_TELEPHONE_TYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_telephone {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_telephone_type_t, type);
         libiodefv2_string_t *ext_type;
        REQUIRED(libiodefv2_string_t, *telephone_number);
         libiodefv2_string_t *description;
};



        


struct iodefv2_certificate {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *observable_id;
        REQUIRED(iodefv2_data_t, *x509_data);
         libiodefv2_string_t *description;
};



        
/**
 * iodefv2_key_registryaction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_key_registryaction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_key_registryaction_t iodefv2_key_registryaction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_key_registryaction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_KEY_REGISTRYACTION_ADD_KEY, "add-key" },


            { IODEFV2_KEY_REGISTRYACTION_ADD_VALUE, "add-value" },


            { IODEFV2_KEY_REGISTRYACTION_DELETE_VALUE, "delete-value" },


            { IODEFV2_KEY_REGISTRYACTION_DELETE_KEY, "delete-key" },


            { IODEFV2_KEY_REGISTRYACTION_MODIFY_KEY, "modify-key" },


            { IODEFV2_KEY_REGISTRYACTION_MODIFY_VALUE, "modify-value" },


            { IODEFV2_KEY_REGISTRYACTION_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for key_registryaction", name);

}
/**
 * iodefv2_key_registryaction_to_string:
 * @val: an enumeration value for #iodefv2_key_registryaction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_key_registryaction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_key_registryaction_to_string(iodefv2_key_registryaction_t val)
{

        const struct {
              iodefv2_key_registryaction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_KEY_REGISTRYACTION_ADD_KEY, "add-key" },

            { IODEFV2_KEY_REGISTRYACTION_ADD_VALUE, "add-value" },

            { IODEFV2_KEY_REGISTRYACTION_DELETE_VALUE, "delete-value" },

            { IODEFV2_KEY_REGISTRYACTION_DELETE_KEY, "delete-key" },

            { IODEFV2_KEY_REGISTRYACTION_MODIFY_KEY, "modify-key" },

            { IODEFV2_KEY_REGISTRYACTION_MODIFY_VALUE, "modify-value" },

            { IODEFV2_KEY_REGISTRYACTION_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_key {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_key_registryaction_t, registryaction);
         libiodefv2_string_t *ext_registryaction;
         libiodefv2_string_t *observable_id;
        REQUIRED(libiodefv2_string_t, *key_name);
         libiodefv2_string_t *key_value;
};



        


struct iodefv2_observable_reference {

         IODEFV2_OBJECT;
         REFCOUNT;
        REQUIRED(libiodefv2_string_t, *uid_ref);
};



        
/**
 * iodefv2_registry_handle_registry_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_registry_handle_registry_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_registry_handle_registry_t iodefv2_registry_handle_registry_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_registry_handle_registry_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_REGISTRY_HANDLE_REGISTRY_INTERNIC, "internic" },


            { IODEFV2_REGISTRY_HANDLE_REGISTRY_APNIC, "apnic" },


            { IODEFV2_REGISTRY_HANDLE_REGISTRY_ARIN, "arin" },


            { IODEFV2_REGISTRY_HANDLE_REGISTRY_LACNIC, "lacnic" },


            { IODEFV2_REGISTRY_HANDLE_REGISTRY_RIPE, "ripe" },


            { IODEFV2_REGISTRY_HANDLE_REGISTRY_AFRINIC, "afrinic" },


            { IODEFV2_REGISTRY_HANDLE_REGISTRY_LOCAL, "local" },


            { IODEFV2_REGISTRY_HANDLE_REGISTRY_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for registry_handle_registry", name);

}
/**
 * iodefv2_registry_handle_registry_to_string:
 * @val: an enumeration value for #iodefv2_registry_handle_registry_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_registry_handle_registry_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_registry_handle_registry_to_string(iodefv2_registry_handle_registry_t val)
{

        const struct {
              iodefv2_registry_handle_registry_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_REGISTRY_HANDLE_REGISTRY_INTERNIC, "internic" },

            { IODEFV2_REGISTRY_HANDLE_REGISTRY_APNIC, "apnic" },

            { IODEFV2_REGISTRY_HANDLE_REGISTRY_ARIN, "arin" },

            { IODEFV2_REGISTRY_HANDLE_REGISTRY_LACNIC, "lacnic" },

            { IODEFV2_REGISTRY_HANDLE_REGISTRY_RIPE, "ripe" },

            { IODEFV2_REGISTRY_HANDLE_REGISTRY_AFRINIC, "afrinic" },

            { IODEFV2_REGISTRY_HANDLE_REGISTRY_LOCAL, "local" },

            { IODEFV2_REGISTRY_HANDLE_REGISTRY_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_registry_handle {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         iodefv2_registry_handle_registry_t registry;
         libiodefv2_string_t *ext_registry;
};



        
/**
 * iodefv2_time_impact_duration_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_time_impact_duration_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_time_impact_duration_t iodefv2_time_impact_duration_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_time_impact_duration_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_TIME_IMPACT_DURATION_SECOND, "second" },


            { IODEFV2_TIME_IMPACT_DURATION_MINUTE, "minute" },


            { IODEFV2_TIME_IMPACT_DURATION_HOUR, "hour" },


            { IODEFV2_TIME_IMPACT_DURATION_DAY, "day" },


            { IODEFV2_TIME_IMPACT_DURATION_MONTH, "month" },


            { IODEFV2_TIME_IMPACT_DURATION_QUARTER, "quarter" },


            { IODEFV2_TIME_IMPACT_DURATION_YEAR, "year" },


            { IODEFV2_TIME_IMPACT_DURATION_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for time_impact_duration", name);

}
/**
 * iodefv2_time_impact_duration_to_string:
 * @val: an enumeration value for #iodefv2_time_impact_duration_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_time_impact_duration_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_time_impact_duration_to_string(iodefv2_time_impact_duration_t val)
{

        const struct {
              iodefv2_time_impact_duration_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_TIME_IMPACT_DURATION_SECOND, "second" },

            { IODEFV2_TIME_IMPACT_DURATION_MINUTE, "minute" },

            { IODEFV2_TIME_IMPACT_DURATION_HOUR, "hour" },

            { IODEFV2_TIME_IMPACT_DURATION_DAY, "day" },

            { IODEFV2_TIME_IMPACT_DURATION_MONTH, "month" },

            { IODEFV2_TIME_IMPACT_DURATION_QUARTER, "quarter" },

            { IODEFV2_TIME_IMPACT_DURATION_YEAR, "year" },

            { IODEFV2_TIME_IMPACT_DURATION_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_time_impact_metric_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_time_impact_metric_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_time_impact_metric_t iodefv2_time_impact_metric_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_time_impact_metric_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_TIME_IMPACT_METRIC_LABOR, "labor" },


            { IODEFV2_TIME_IMPACT_METRIC_ELAPSED, "elapsed" },


            { IODEFV2_TIME_IMPACT_METRIC_DOWNTIME, "downtime" },


            { IODEFV2_TIME_IMPACT_METRIC_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for time_impact_metric", name);

}
/**
 * iodefv2_time_impact_metric_to_string:
 * @val: an enumeration value for #iodefv2_time_impact_metric_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_time_impact_metric_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_time_impact_metric_to_string(iodefv2_time_impact_metric_t val)
{

        const struct {
              iodefv2_time_impact_metric_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_TIME_IMPACT_METRIC_LABOR, "labor" },

            { IODEFV2_TIME_IMPACT_METRIC_ELAPSED, "elapsed" },

            { IODEFV2_TIME_IMPACT_METRIC_DOWNTIME, "downtime" },

            { IODEFV2_TIME_IMPACT_METRIC_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_time_impact_severity_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_time_impact_severity_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_time_impact_severity_t iodefv2_time_impact_severity_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_time_impact_severity_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_TIME_IMPACT_SEVERITY_LOW, "low" },


            { IODEFV2_TIME_IMPACT_SEVERITY_MEDIUM, "medium" },


            { IODEFV2_TIME_IMPACT_SEVERITY_HIGH, "high" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for time_impact_severity", name);

}
/**
 * iodefv2_time_impact_severity_to_string:
 * @val: an enumeration value for #iodefv2_time_impact_severity_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_time_impact_severity_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_time_impact_severity_to_string(iodefv2_time_impact_severity_t val)
{

        const struct {
              iodefv2_time_impact_severity_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_TIME_IMPACT_SEVERITY_LOW, "low" },

            { IODEFV2_TIME_IMPACT_SEVERITY_MEDIUM, "medium" },

            { IODEFV2_TIME_IMPACT_SEVERITY_HIGH, "high" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_time_impact {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *ext_metric;
         iodefv2_time_impact_duration_t duration;
         iodefv2_time_impact_metric_t metric;
         OPTIONAL_INT(iodefv2_time_impact_severity_t, severity);
         libiodefv2_string_t *ext_duration;
};



        
/**
 * iodefv2_record_pattern_offsetunit_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_record_pattern_offsetunit_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_record_pattern_offsetunit_t iodefv2_record_pattern_offsetunit_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_record_pattern_offsetunit_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_RECORD_PATTERN_OFFSETUNIT_LINE, "line" },


            { IODEFV2_RECORD_PATTERN_OFFSETUNIT_BINARY, "binary" },


            { IODEFV2_RECORD_PATTERN_OFFSETUNIT_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for record_pattern_offsetunit", name);

}
/**
 * iodefv2_record_pattern_offsetunit_to_string:
 * @val: an enumeration value for #iodefv2_record_pattern_offsetunit_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_record_pattern_offsetunit_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_record_pattern_offsetunit_to_string(iodefv2_record_pattern_offsetunit_t val)
{

        const struct {
              iodefv2_record_pattern_offsetunit_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_RECORD_PATTERN_OFFSETUNIT_LINE, "line" },

            { IODEFV2_RECORD_PATTERN_OFFSETUNIT_BINARY, "binary" },

            { IODEFV2_RECORD_PATTERN_OFFSETUNIT_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_record_pattern_type_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_record_pattern_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_record_pattern_type_t iodefv2_record_pattern_type_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_record_pattern_type_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_RECORD_PATTERN_TYPE_REGEX, "regex" },


            { IODEFV2_RECORD_PATTERN_TYPE_BINARY, "binary" },


            { IODEFV2_RECORD_PATTERN_TYPE_XPATH, "xpath" },


            { IODEFV2_RECORD_PATTERN_TYPE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for record_pattern_type", name);

}
/**
 * iodefv2_record_pattern_type_to_string:
 * @val: an enumeration value for #iodefv2_record_pattern_type_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_record_pattern_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_record_pattern_type_to_string(iodefv2_record_pattern_type_t val)
{

        const struct {
              iodefv2_record_pattern_type_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_RECORD_PATTERN_TYPE_REGEX, "regex" },

            { IODEFV2_RECORD_PATTERN_TYPE_BINARY, "binary" },

            { IODEFV2_RECORD_PATTERN_TYPE_XPATH, "xpath" },

            { IODEFV2_RECORD_PATTERN_TYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_record_pattern {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(uint32_t, instance);
         libiodefv2_string_t *ext_type;
         OPTIONAL_INT(uint32_t, offset);
         OPTIONAL_INT(iodefv2_record_pattern_offsetunit_t, offsetunit);
         libiodefv2_string_t *ext_offsetunit;
         iodefv2_record_pattern_type_t type;
};



        


struct iodefv2_reference {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *observable_id;
         libiodefv2_string_t *url;
         libiodefv2_string_t *description;
         libiodefv2_string_t *reference_name;
};



        
/**
 * iodefv2_postal_address_type_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_postal_address_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_postal_address_type_t iodefv2_postal_address_type_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_postal_address_type_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_POSTAL_ADDRESS_TYPE_STREET, "street" },


            { IODEFV2_POSTAL_ADDRESS_TYPE_MAILING, "mailing" },


            { IODEFV2_POSTAL_ADDRESS_TYPE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for postal_address_type", name);

}
/**
 * iodefv2_postal_address_type_to_string:
 * @val: an enumeration value for #iodefv2_postal_address_type_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_postal_address_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_postal_address_type_to_string(iodefv2_postal_address_type_t val)
{

        const struct {
              iodefv2_postal_address_type_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_POSTAL_ADDRESS_TYPE_STREET, "street" },

            { IODEFV2_POSTAL_ADDRESS_TYPE_MAILING, "mailing" },

            { IODEFV2_POSTAL_ADDRESS_TYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_postal_address {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_postal_address_type_t, type);
         libiodefv2_string_t *ext_type;
        REQUIRED(libiodefv2_string_t, *p_address);
         libiodefv2_string_t *description;
};



        
/**
 * iodefv2_node_role_category_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_node_role_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_node_role_category_t iodefv2_node_role_category_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_node_role_category_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_NODE_ROLE_CATEGORY_CLIENT, "client" },


            { IODEFV2_NODE_ROLE_CATEGORY_SERVER_INTERNAL, "server-internal" },


            { IODEFV2_NODE_ROLE_CATEGORY_SERVER_PUBLIC, "server-public" },


            { IODEFV2_NODE_ROLE_CATEGORY_WWW, "www" },


            { IODEFV2_NODE_ROLE_CATEGORY_MAIL, "mail" },


            { IODEFV2_NODE_ROLE_CATEGORY_MESSAGING, "messaging" },


            { IODEFV2_NODE_ROLE_CATEGORY_STREAMING, "streaming" },


            { IODEFV2_NODE_ROLE_CATEGORY_VOICE, "voice" },


            { IODEFV2_NODE_ROLE_CATEGORY_FILE, "file" },


            { IODEFV2_NODE_ROLE_CATEGORY_FTP, "ftp" },


            { IODEFV2_NODE_ROLE_CATEGORY_P2P, "p2p" },


            { IODEFV2_NODE_ROLE_CATEGORY_NAME, "name" },


            { IODEFV2_NODE_ROLE_CATEGORY_DIRECTORY, "directory" },


            { IODEFV2_NODE_ROLE_CATEGORY_CREDENTIAL, "credential" },


            { IODEFV2_NODE_ROLE_CATEGORY_PRINT, "print" },


            { IODEFV2_NODE_ROLE_CATEGORY_APPLICATION, "application" },


            { IODEFV2_NODE_ROLE_CATEGORY_DATABASE, "database" },


            { IODEFV2_NODE_ROLE_CATEGORY_INFRA, "infra" },


            { IODEFV2_NODE_ROLE_CATEGORY_LOG, "log" },


            { IODEFV2_NODE_ROLE_CATEGORY_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for node_role_category", name);

}
/**
 * iodefv2_node_role_category_to_string:
 * @val: an enumeration value for #iodefv2_node_role_category_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_node_role_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_node_role_category_to_string(iodefv2_node_role_category_t val)
{

        const struct {
              iodefv2_node_role_category_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_NODE_ROLE_CATEGORY_CLIENT, "client" },

            { IODEFV2_NODE_ROLE_CATEGORY_SERVER_INTERNAL, "server-internal" },

            { IODEFV2_NODE_ROLE_CATEGORY_SERVER_PUBLIC, "server-public" },

            { IODEFV2_NODE_ROLE_CATEGORY_WWW, "www" },

            { IODEFV2_NODE_ROLE_CATEGORY_MAIL, "mail" },

            { IODEFV2_NODE_ROLE_CATEGORY_MESSAGING, "messaging" },

            { IODEFV2_NODE_ROLE_CATEGORY_STREAMING, "streaming" },

            { IODEFV2_NODE_ROLE_CATEGORY_VOICE, "voice" },

            { IODEFV2_NODE_ROLE_CATEGORY_FILE, "file" },

            { IODEFV2_NODE_ROLE_CATEGORY_FTP, "ftp" },

            { IODEFV2_NODE_ROLE_CATEGORY_P2P, "p2p" },

            { IODEFV2_NODE_ROLE_CATEGORY_NAME, "name" },

            { IODEFV2_NODE_ROLE_CATEGORY_DIRECTORY, "directory" },

            { IODEFV2_NODE_ROLE_CATEGORY_CREDENTIAL, "credential" },

            { IODEFV2_NODE_ROLE_CATEGORY_PRINT, "print" },

            { IODEFV2_NODE_ROLE_CATEGORY_APPLICATION, "application" },

            { IODEFV2_NODE_ROLE_CATEGORY_DATABASE, "database" },

            { IODEFV2_NODE_ROLE_CATEGORY_INFRA, "infra" },

            { IODEFV2_NODE_ROLE_CATEGORY_LOG, "log" },

            { IODEFV2_NODE_ROLE_CATEGORY_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_node_role {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         iodefv2_node_role_category_t category;
         libiodefv2_string_t *ext_category;
         libiodefv2_string_t *description;
};



        
/**
 * iodefv2_incident_id_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_incident_id_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_incident_id_restriction_t iodefv2_incident_id_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_incident_id_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_INCIDENT_ID_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_INCIDENT_ID_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_INCIDENT_ID_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_INCIDENT_ID_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_INCIDENT_ID_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_INCIDENT_ID_RESTRICTION_WHITE, "white" },


            { IODEFV2_INCIDENT_ID_RESTRICTION_GREEN, "green" },


            { IODEFV2_INCIDENT_ID_RESTRICTION_AMBER, "amber" },


            { IODEFV2_INCIDENT_ID_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for incident_id_restriction", name);

}
/**
 * iodefv2_incident_id_restriction_to_string:
 * @val: an enumeration value for #iodefv2_incident_id_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_incident_id_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_incident_id_restriction_to_string(iodefv2_incident_id_restriction_t val)
{

        const struct {
              iodefv2_incident_id_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_INCIDENT_ID_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_INCIDENT_ID_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_INCIDENT_ID_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_INCIDENT_ID_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_INCIDENT_ID_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_INCIDENT_ID_RESTRICTION_WHITE, "white" },

            { IODEFV2_INCIDENT_ID_RESTRICTION_GREEN, "green" },

            { IODEFV2_INCIDENT_ID_RESTRICTION_AMBER, "amber" },

            { IODEFV2_INCIDENT_ID_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_incident_id {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *instance;
         libiodefv2_string_t *ext_restriction;
        REQUIRED(libiodefv2_string_t, *name);
         OPTIONAL_INT(iodefv2_incident_id_restriction_t, restriction);
};



        
/**
 * iodefv2_alternative_indicator_id_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_alternative_indicator_id_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_alternative_indicator_id_restriction_t iodefv2_alternative_indicator_id_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_alternative_indicator_id_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_WHITE, "white" },


            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_GREEN, "green" },


            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_AMBER, "amber" },


            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for alternative_indicator_id_restriction", name);

}
/**
 * iodefv2_alternative_indicator_id_restriction_to_string:
 * @val: an enumeration value for #iodefv2_alternative_indicator_id_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_alternative_indicator_id_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_alternative_indicator_id_restriction_to_string(iodefv2_alternative_indicator_id_restriction_t val)
{

        const struct {
              iodefv2_alternative_indicator_id_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_WHITE, "white" },

            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_GREEN, "green" },

            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_AMBER, "amber" },

            { IODEFV2_ALTERNATIVE_INDICATOR_ID_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_alternative_indicator_id {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_alternative_indicator_id_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
         libiodefv2_string_t *indicator_reference;
};



        
/**
 * iodefv2_confidence_rating_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_confidence_rating_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_confidence_rating_t iodefv2_confidence_rating_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_confidence_rating_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_CONFIDENCE_RATING_LOW, "low" },


            { IODEFV2_CONFIDENCE_RATING_MEDIUM, "medium" },


            { IODEFV2_CONFIDENCE_RATING_HIGH, "high" },


            { IODEFV2_CONFIDENCE_RATING_NUMERIC, "numeric" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for confidence_rating", name);

}
/**
 * iodefv2_confidence_rating_to_string:
 * @val: an enumeration value for #iodefv2_confidence_rating_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_confidence_rating_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_confidence_rating_to_string(iodefv2_confidence_rating_t val)
{

        const struct {
              iodefv2_confidence_rating_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_CONFIDENCE_RATING_LOW, "low" },

            { IODEFV2_CONFIDENCE_RATING_MEDIUM, "medium" },

            { IODEFV2_CONFIDENCE_RATING_HIGH, "high" },

            { IODEFV2_CONFIDENCE_RATING_NUMERIC, "numeric" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_confidence {

         IODEFV2_OBJECT;
         REFCOUNT;
         iodefv2_confidence_rating_t rating;
         libiodefv2_string_t *ext_rating;
};



        
/**
 * iodefv2_system_impact_completion_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_system_impact_completion_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_system_impact_completion_t iodefv2_system_impact_completion_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_system_impact_completion_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_SYSTEM_IMPACT_COMPLETION_FAILED, "failed" },


            { IODEFV2_SYSTEM_IMPACT_COMPLETION_SUCCEEDED, "succeeded" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for system_impact_completion", name);

}
/**
 * iodefv2_system_impact_completion_to_string:
 * @val: an enumeration value for #iodefv2_system_impact_completion_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_system_impact_completion_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_system_impact_completion_to_string(iodefv2_system_impact_completion_t val)
{

        const struct {
              iodefv2_system_impact_completion_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_SYSTEM_IMPACT_COMPLETION_FAILED, "failed" },

            { IODEFV2_SYSTEM_IMPACT_COMPLETION_SUCCEEDED, "succeeded" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_system_impact_type_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_system_impact_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_system_impact_type_t iodefv2_system_impact_type_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_system_impact_type_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_SYSTEM_IMPACT_TYPE_TAKEOVER_ACCOUNT, "takeover-account" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_TAKEOVER_SERVICE, "takeover-service" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_TAKEOVER_SYSTEM, "takeover-system" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_CPS_MANIPULATION, "cps-manipulation" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_CPS_DAMAGE, "cps-damage" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_AVAILABILITY_DATA, "availability-data" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_AVAILABILITY_ACCOUNT, "availability-account" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_AVAILABILITY_SERVICE, "availability-service" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_AVAILABILITY_SYSTEM, "availability-system" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_DAMAGED_SYSTEM, "damaged-system" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_DAMAGED_DATA, "damaged-data" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_BREACH_PROPRIETARY, "breach-proprietary" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_BREACH_PRIVACY, "breach-privacy" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_BREACH_CREDENTIAL, "breach-credential" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_BREACH_CONFIGURATION, "breach-configuration" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_INTEGRITY_DATA, "integrity-data" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_INTEGRITY_CONFIGURATION, "integrity-configuration" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_INTEGRITY_HARDWARE, "integrity-hardware" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_TRAFFIC_REDIRECTION, "traffic-redirection" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_MONITORING_TRAFFIC, "monitoring-traffic" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_MONITORING_HOST, "monitoring-host" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_POLICY, "policy" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_UNKNOWN, "unknown" },


            { IODEFV2_SYSTEM_IMPACT_TYPE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for system_impact_type", name);

}
/**
 * iodefv2_system_impact_type_to_string:
 * @val: an enumeration value for #iodefv2_system_impact_type_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_system_impact_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_system_impact_type_to_string(iodefv2_system_impact_type_t val)
{

        const struct {
              iodefv2_system_impact_type_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_SYSTEM_IMPACT_TYPE_TAKEOVER_ACCOUNT, "takeover-account" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_TAKEOVER_SERVICE, "takeover-service" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_TAKEOVER_SYSTEM, "takeover-system" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_CPS_MANIPULATION, "cps-manipulation" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_CPS_DAMAGE, "cps-damage" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_AVAILABILITY_DATA, "availability-data" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_AVAILABILITY_ACCOUNT, "availability-account" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_AVAILABILITY_SERVICE, "availability-service" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_AVAILABILITY_SYSTEM, "availability-system" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_DAMAGED_SYSTEM, "damaged-system" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_DAMAGED_DATA, "damaged-data" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_BREACH_PROPRIETARY, "breach-proprietary" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_BREACH_PRIVACY, "breach-privacy" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_BREACH_CREDENTIAL, "breach-credential" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_BREACH_CONFIGURATION, "breach-configuration" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_INTEGRITY_DATA, "integrity-data" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_INTEGRITY_CONFIGURATION, "integrity-configuration" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_INTEGRITY_HARDWARE, "integrity-hardware" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_TRAFFIC_REDIRECTION, "traffic-redirection" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_MONITORING_TRAFFIC, "monitoring-traffic" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_MONITORING_HOST, "monitoring-host" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_POLICY, "policy" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_UNKNOWN, "unknown" },

            { IODEFV2_SYSTEM_IMPACT_TYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_system_impact_severity_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_system_impact_severity_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_system_impact_severity_t iodefv2_system_impact_severity_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_system_impact_severity_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_SYSTEM_IMPACT_SEVERITY_LOW, "low" },


            { IODEFV2_SYSTEM_IMPACT_SEVERITY_MEDIUM, "medium" },


            { IODEFV2_SYSTEM_IMPACT_SEVERITY_HIGH, "high" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for system_impact_severity", name);

}
/**
 * iodefv2_system_impact_severity_to_string:
 * @val: an enumeration value for #iodefv2_system_impact_severity_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_system_impact_severity_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_system_impact_severity_to_string(iodefv2_system_impact_severity_t val)
{

        const struct {
              iodefv2_system_impact_severity_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_SYSTEM_IMPACT_SEVERITY_LOW, "low" },

            { IODEFV2_SYSTEM_IMPACT_SEVERITY_MEDIUM, "medium" },

            { IODEFV2_SYSTEM_IMPACT_SEVERITY_HIGH, "high" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_system_impact {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_system_impact_completion_t, completion);
         iodefv2_system_impact_type_t type;
         OPTIONAL_INT(iodefv2_system_impact_severity_t, severity);
         libiodefv2_string_t *ext_type;
         libiodefv2_string_t *description;
};



        
/**
 * iodefv2_software_reference_dtype_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_software_reference_dtype_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_software_reference_dtype_t iodefv2_software_reference_dtype_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_software_reference_dtype_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_SOFTWARE_REFERENCE_DTYPE_BYTES, "bytes" },


            { IODEFV2_SOFTWARE_REFERENCE_DTYPE_INTEGER, "integer" },


            { IODEFV2_SOFTWARE_REFERENCE_DTYPE_REAL, "real" },


            { IODEFV2_SOFTWARE_REFERENCE_DTYPE_STRING, "string" },


            { IODEFV2_SOFTWARE_REFERENCE_DTYPE_XML, "xml" },


            { IODEFV2_SOFTWARE_REFERENCE_DTYPE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for software_reference_dtype", name);

}
/**
 * iodefv2_software_reference_dtype_to_string:
 * @val: an enumeration value for #iodefv2_software_reference_dtype_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_software_reference_dtype_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_software_reference_dtype_to_string(iodefv2_software_reference_dtype_t val)
{

        const struct {
              iodefv2_software_reference_dtype_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_SOFTWARE_REFERENCE_DTYPE_BYTES, "bytes" },

            { IODEFV2_SOFTWARE_REFERENCE_DTYPE_INTEGER, "integer" },

            { IODEFV2_SOFTWARE_REFERENCE_DTYPE_REAL, "real" },

            { IODEFV2_SOFTWARE_REFERENCE_DTYPE_STRING, "string" },

            { IODEFV2_SOFTWARE_REFERENCE_DTYPE_XML, "xml" },

            { IODEFV2_SOFTWARE_REFERENCE_DTYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_software_reference {

         IODEFV2_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_software_reference_dtype_t, dtype);
         libiodefv2_string_t *ext_spec_name;
         libiodefv2_string_t *ext_dtype;
};



        
/**
 * iodefv2_business_impact_type_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_business_impact_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_business_impact_type_t iodefv2_business_impact_type_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_business_impact_type_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_BUSINESS_IMPACT_TYPE_BREACH_PROPRIETARY, "breach-proprietary" },


            { IODEFV2_BUSINESS_IMPACT_TYPE_BREACH_PRIVACY, "breach-privacy" },


            { IODEFV2_BUSINESS_IMPACT_TYPE_BREACH_CREDENTIAL, "breach-credential" },


            { IODEFV2_BUSINESS_IMPACT_TYPE_LOSS_OF_INTEGRITY, "loss-of-integrity" },


            { IODEFV2_BUSINESS_IMPACT_TYPE_LOSS_OF_SERVICE, "loss-of-service" },


            { IODEFV2_BUSINESS_IMPACT_TYPE_THEFT_FINANCIAL, "theft-financial" },


            { IODEFV2_BUSINESS_IMPACT_TYPE_THEFT_SERVICE, "theft-service" },


            { IODEFV2_BUSINESS_IMPACT_TYPE_DEGRADED_REPUTATION, "degraded-reputation" },


            { IODEFV2_BUSINESS_IMPACT_TYPE_ASSET_DAMAGE, "asset-damage" },


            { IODEFV2_BUSINESS_IMPACT_TYPE_DAMAGED_SYSTEM, "damaged-system" },


            { IODEFV2_BUSINESS_IMPACT_TYPE_LEGAL, "legal" },


            { IODEFV2_BUSINESS_IMPACT_TYPE_EXTORTION, "extortion" },


            { IODEFV2_BUSINESS_IMPACT_TYPE_UNKNOWN, "unknown" },


            { IODEFV2_BUSINESS_IMPACT_TYPE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for business_impact_type", name);

}
/**
 * iodefv2_business_impact_type_to_string:
 * @val: an enumeration value for #iodefv2_business_impact_type_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_business_impact_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_business_impact_type_to_string(iodefv2_business_impact_type_t val)
{

        const struct {
              iodefv2_business_impact_type_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_BUSINESS_IMPACT_TYPE_BREACH_PROPRIETARY, "breach-proprietary" },

            { IODEFV2_BUSINESS_IMPACT_TYPE_BREACH_PRIVACY, "breach-privacy" },

            { IODEFV2_BUSINESS_IMPACT_TYPE_BREACH_CREDENTIAL, "breach-credential" },

            { IODEFV2_BUSINESS_IMPACT_TYPE_LOSS_OF_INTEGRITY, "loss-of-integrity" },

            { IODEFV2_BUSINESS_IMPACT_TYPE_LOSS_OF_SERVICE, "loss-of-service" },

            { IODEFV2_BUSINESS_IMPACT_TYPE_THEFT_FINANCIAL, "theft-financial" },

            { IODEFV2_BUSINESS_IMPACT_TYPE_THEFT_SERVICE, "theft-service" },

            { IODEFV2_BUSINESS_IMPACT_TYPE_DEGRADED_REPUTATION, "degraded-reputation" },

            { IODEFV2_BUSINESS_IMPACT_TYPE_ASSET_DAMAGE, "asset-damage" },

            { IODEFV2_BUSINESS_IMPACT_TYPE_DAMAGED_SYSTEM, "damaged-system" },

            { IODEFV2_BUSINESS_IMPACT_TYPE_LEGAL, "legal" },

            { IODEFV2_BUSINESS_IMPACT_TYPE_EXTORTION, "extortion" },

            { IODEFV2_BUSINESS_IMPACT_TYPE_UNKNOWN, "unknown" },

            { IODEFV2_BUSINESS_IMPACT_TYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_business_impact_severity_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_business_impact_severity_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_business_impact_severity_t iodefv2_business_impact_severity_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_business_impact_severity_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_BUSINESS_IMPACT_SEVERITY_LOW, "low" },


            { IODEFV2_BUSINESS_IMPACT_SEVERITY_MEDIUM, "medium" },


            { IODEFV2_BUSINESS_IMPACT_SEVERITY_HIGH, "high" },


            { IODEFV2_BUSINESS_IMPACT_SEVERITY_NONE, "none" },


            { IODEFV2_BUSINESS_IMPACT_SEVERITY_UNKNOWN, "unknown" },


            { IODEFV2_BUSINESS_IMPACT_SEVERITY_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for business_impact_severity", name);

}
/**
 * iodefv2_business_impact_severity_to_string:
 * @val: an enumeration value for #iodefv2_business_impact_severity_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_business_impact_severity_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_business_impact_severity_to_string(iodefv2_business_impact_severity_t val)
{

        const struct {
              iodefv2_business_impact_severity_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_BUSINESS_IMPACT_SEVERITY_LOW, "low" },

            { IODEFV2_BUSINESS_IMPACT_SEVERITY_MEDIUM, "medium" },

            { IODEFV2_BUSINESS_IMPACT_SEVERITY_HIGH, "high" },

            { IODEFV2_BUSINESS_IMPACT_SEVERITY_NONE, "none" },

            { IODEFV2_BUSINESS_IMPACT_SEVERITY_UNKNOWN, "unknown" },

            { IODEFV2_BUSINESS_IMPACT_SEVERITY_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_business_impact {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *ext_severity;
         iodefv2_business_impact_type_t type;
         OPTIONAL_INT(iodefv2_business_impact_severity_t, severity);
         libiodefv2_string_t *ext_type;
         libiodefv2_string_t *description;
};



        


struct iodefv2_indicator_reference {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *uid_ref;
         libiodefv2_string_t *version;
         libiodefv2_string_t *euid_ref;
};



        
/**
 * iodefv2_email_type_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_email_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_email_type_t iodefv2_email_type_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_email_type_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_EMAIL_TYPE_DIRECT, "direct" },


            { IODEFV2_EMAIL_TYPE_HOTLINE, "hotline" },


            { IODEFV2_EMAIL_TYPE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for email_type", name);

}
/**
 * iodefv2_email_type_to_string:
 * @val: an enumeration value for #iodefv2_email_type_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_email_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_email_type_to_string(iodefv2_email_type_t val)
{

        const struct {
              iodefv2_email_type_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_EMAIL_TYPE_DIRECT, "direct" },

            { IODEFV2_EMAIL_TYPE_HOTLINE, "hotline" },

            { IODEFV2_EMAIL_TYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_email {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_email_type_t, type);
         libiodefv2_string_t *ext_type;
        REQUIRED(libiodefv2_string_t, *email_to);
         libiodefv2_string_t *description;
};



        
/**
 * iodefv2_intended_impact_type_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_intended_impact_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_intended_impact_type_t iodefv2_intended_impact_type_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_intended_impact_type_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_INTENDED_IMPACT_TYPE_BREACH_PROPRIETARY, "breach-proprietary" },


            { IODEFV2_INTENDED_IMPACT_TYPE_BREACH_PRIVACY, "breach-privacy" },


            { IODEFV2_INTENDED_IMPACT_TYPE_BREACH_CREDENTIAL, "breach-credential" },


            { IODEFV2_INTENDED_IMPACT_TYPE_LOSS_OF_INTEGRITY, "loss-of-integrity" },


            { IODEFV2_INTENDED_IMPACT_TYPE_LOSS_OF_SERVICE, "loss-of-service" },


            { IODEFV2_INTENDED_IMPACT_TYPE_THEFT_FINANCIAL, "theft-financial" },


            { IODEFV2_INTENDED_IMPACT_TYPE_THEFT_SERVICE, "theft-service" },


            { IODEFV2_INTENDED_IMPACT_TYPE_DEGRADED_REPUTATION, "degraded-reputation" },


            { IODEFV2_INTENDED_IMPACT_TYPE_ASSET_DAMAGE, "asset-damage" },


            { IODEFV2_INTENDED_IMPACT_TYPE_DAMAGED_SYSTEM, "damaged-system" },


            { IODEFV2_INTENDED_IMPACT_TYPE_LEGAL, "legal" },


            { IODEFV2_INTENDED_IMPACT_TYPE_EXTORTION, "extortion" },


            { IODEFV2_INTENDED_IMPACT_TYPE_UNKNOWN, "unknown" },


            { IODEFV2_INTENDED_IMPACT_TYPE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for intended_impact_type", name);

}
/**
 * iodefv2_intended_impact_type_to_string:
 * @val: an enumeration value for #iodefv2_intended_impact_type_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_intended_impact_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_intended_impact_type_to_string(iodefv2_intended_impact_type_t val)
{

        const struct {
              iodefv2_intended_impact_type_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_INTENDED_IMPACT_TYPE_BREACH_PROPRIETARY, "breach-proprietary" },

            { IODEFV2_INTENDED_IMPACT_TYPE_BREACH_PRIVACY, "breach-privacy" },

            { IODEFV2_INTENDED_IMPACT_TYPE_BREACH_CREDENTIAL, "breach-credential" },

            { IODEFV2_INTENDED_IMPACT_TYPE_LOSS_OF_INTEGRITY, "loss-of-integrity" },

            { IODEFV2_INTENDED_IMPACT_TYPE_LOSS_OF_SERVICE, "loss-of-service" },

            { IODEFV2_INTENDED_IMPACT_TYPE_THEFT_FINANCIAL, "theft-financial" },

            { IODEFV2_INTENDED_IMPACT_TYPE_THEFT_SERVICE, "theft-service" },

            { IODEFV2_INTENDED_IMPACT_TYPE_DEGRADED_REPUTATION, "degraded-reputation" },

            { IODEFV2_INTENDED_IMPACT_TYPE_ASSET_DAMAGE, "asset-damage" },

            { IODEFV2_INTENDED_IMPACT_TYPE_DAMAGED_SYSTEM, "damaged-system" },

            { IODEFV2_INTENDED_IMPACT_TYPE_LEGAL, "legal" },

            { IODEFV2_INTENDED_IMPACT_TYPE_EXTORTION, "extortion" },

            { IODEFV2_INTENDED_IMPACT_TYPE_UNKNOWN, "unknown" },

            { IODEFV2_INTENDED_IMPACT_TYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_intended_impact_severity_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_intended_impact_severity_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_intended_impact_severity_t iodefv2_intended_impact_severity_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_intended_impact_severity_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_INTENDED_IMPACT_SEVERITY_LOW, "low" },


            { IODEFV2_INTENDED_IMPACT_SEVERITY_MEDIUM, "medium" },


            { IODEFV2_INTENDED_IMPACT_SEVERITY_HIGH, "high" },


            { IODEFV2_INTENDED_IMPACT_SEVERITY_NONE, "none" },


            { IODEFV2_INTENDED_IMPACT_SEVERITY_UNKNOWN, "unknown" },


            { IODEFV2_INTENDED_IMPACT_SEVERITY_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for intended_impact_severity", name);

}
/**
 * iodefv2_intended_impact_severity_to_string:
 * @val: an enumeration value for #iodefv2_intended_impact_severity_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_intended_impact_severity_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_intended_impact_severity_to_string(iodefv2_intended_impact_severity_t val)
{

        const struct {
              iodefv2_intended_impact_severity_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_INTENDED_IMPACT_SEVERITY_LOW, "low" },

            { IODEFV2_INTENDED_IMPACT_SEVERITY_MEDIUM, "medium" },

            { IODEFV2_INTENDED_IMPACT_SEVERITY_HIGH, "high" },

            { IODEFV2_INTENDED_IMPACT_SEVERITY_NONE, "none" },

            { IODEFV2_INTENDED_IMPACT_SEVERITY_UNKNOWN, "unknown" },

            { IODEFV2_INTENDED_IMPACT_SEVERITY_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_intended_impact {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *ext_severity;
         iodefv2_intended_impact_type_t type;
         OPTIONAL_INT(iodefv2_intended_impact_severity_t, severity);
         libiodefv2_string_t *ext_type;
         libiodefv2_string_t *description;
};



        
/**
 * iodefv2_additional_data_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_additional_data_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_additional_data_restriction_t iodefv2_additional_data_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_additional_data_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_WHITE, "white" },


            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_GREEN, "green" },


            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_AMBER, "amber" },


            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for additional_data_restriction", name);

}
/**
 * iodefv2_additional_data_restriction_to_string:
 * @val: an enumeration value for #iodefv2_additional_data_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_additional_data_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_additional_data_restriction_to_string(iodefv2_additional_data_restriction_t val)
{

        const struct {
              iodefv2_additional_data_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_WHITE, "white" },

            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_GREEN, "green" },

            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_AMBER, "amber" },

            { IODEFV2_ADDITIONAL_DATA_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_additional_data_type_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_additional_data_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_additional_data_type_t iodefv2_additional_data_type_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_additional_data_type_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_ADDITIONAL_DATA_TYPE_BOOLEAN, "boolean" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_BYTE, "byte" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_CHARACTER, "character" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_DATE_TIME, "date-time" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_INTEGER, "integer" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_PORTLIST, "portlist" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_REAL, "real" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_STRING, "string" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_FILE, "file" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_FRAME, "frame" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_PACKET, "packet" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_IPV4_PACKET, "ipv4-packet" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_IPV6_PACKET, "ipv6-packet" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_PATH, "path" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_URL, "url" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_CSV, "csv" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_WINREG, "winreg" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_XML, "xml" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_BYTES, "bytes" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_NTPSTAMP, "ntpstamp" },


            { IODEFV2_ADDITIONAL_DATA_TYPE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for additional_data_type", name);

}
/**
 * iodefv2_additional_data_type_to_string:
 * @val: an enumeration value for #iodefv2_additional_data_type_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_additional_data_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_additional_data_type_to_string(iodefv2_additional_data_type_t val)
{

        const struct {
              iodefv2_additional_data_type_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_ADDITIONAL_DATA_TYPE_BOOLEAN, "boolean" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_BYTE, "byte" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_CHARACTER, "character" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_DATE_TIME, "date-time" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_INTEGER, "integer" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_PORTLIST, "portlist" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_REAL, "real" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_STRING, "string" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_FILE, "file" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_FRAME, "frame" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_PACKET, "packet" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_IPV4_PACKET, "ipv4-packet" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_IPV6_PACKET, "ipv6-packet" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_PATH, "path" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_URL, "url" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_CSV, "csv" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_WINREG, "winreg" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_XML, "xml" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_BYTES, "bytes" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_NTPSTAMP, "ntpstamp" },

            { IODEFV2_ADDITIONAL_DATA_TYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_additional_data {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         IGNORED(libiodefv2_bool_t, _type_is_set);
         OPTIONAL_INT(iodefv2_additional_data_restriction_t, restriction);
         libiodefv2_string_t *name;
         iodefv2_additional_data_type_t type;
         libiodefv2_string_t *ext_restriction;
         libiodefv2_string_t *formatid;
         libiodefv2_string_t *observable_id;
         libiodefv2_string_t *meaning;
         libiodefv2_string_t *ext_dtype;
        REQUIRED(iodefv2_data_t, *data);
};



        
/**
 * iodefv2_counter_unit_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_counter_unit_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_counter_unit_t iodefv2_counter_unit_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_counter_unit_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_COUNTER_UNIT_BYTE, "byte" },


            { IODEFV2_COUNTER_UNIT_MBIT, "mbit" },


            { IODEFV2_COUNTER_UNIT_PACKET, "packet" },


            { IODEFV2_COUNTER_UNIT_FLOW, "flow" },


            { IODEFV2_COUNTER_UNIT_SESSION, "session" },


            { IODEFV2_COUNTER_UNIT_ALERT, "alert" },


            { IODEFV2_COUNTER_UNIT_MESSAGE, "message" },


            { IODEFV2_COUNTER_UNIT_EVENT, "event" },


            { IODEFV2_COUNTER_UNIT_HOST, "host" },


            { IODEFV2_COUNTER_UNIT_SITE, "site" },


            { IODEFV2_COUNTER_UNIT_ORGANIZATION, "organization" },


            { IODEFV2_COUNTER_UNIT_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for counter_unit", name);

}
/**
 * iodefv2_counter_unit_to_string:
 * @val: an enumeration value for #iodefv2_counter_unit_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_counter_unit_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_counter_unit_to_string(iodefv2_counter_unit_t val)
{

        const struct {
              iodefv2_counter_unit_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_COUNTER_UNIT_BYTE, "byte" },

            { IODEFV2_COUNTER_UNIT_MBIT, "mbit" },

            { IODEFV2_COUNTER_UNIT_PACKET, "packet" },

            { IODEFV2_COUNTER_UNIT_FLOW, "flow" },

            { IODEFV2_COUNTER_UNIT_SESSION, "session" },

            { IODEFV2_COUNTER_UNIT_ALERT, "alert" },

            { IODEFV2_COUNTER_UNIT_MESSAGE, "message" },

            { IODEFV2_COUNTER_UNIT_EVENT, "event" },

            { IODEFV2_COUNTER_UNIT_HOST, "host" },

            { IODEFV2_COUNTER_UNIT_SITE, "site" },

            { IODEFV2_COUNTER_UNIT_ORGANIZATION, "organization" },

            { IODEFV2_COUNTER_UNIT_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_counter_duration_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_counter_duration_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_counter_duration_t iodefv2_counter_duration_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_counter_duration_t val;
              const char *name;
        } tbl[] = {
        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for counter_duration", name);

}
/**
 * iodefv2_counter_duration_to_string:
 * @val: an enumeration value for #iodefv2_counter_duration_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_counter_duration_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_counter_duration_to_string(iodefv2_counter_duration_t val)
{

        const struct {
              iodefv2_counter_duration_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_counter_type_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_counter_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_counter_type_t iodefv2_counter_type_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_counter_type_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_COUNTER_TYPE_COUNT, "count" },


            { IODEFV2_COUNTER_TYPE_PEAK, "peak" },


            { IODEFV2_COUNTER_TYPE_AVERAGE, "average" },


            { IODEFV2_COUNTER_TYPE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for counter_type", name);

}
/**
 * iodefv2_counter_type_to_string:
 * @val: an enumeration value for #iodefv2_counter_type_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_counter_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_counter_type_to_string(iodefv2_counter_type_t val)
{

        const struct {
              iodefv2_counter_type_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_COUNTER_TYPE_COUNT, "count" },

            { IODEFV2_COUNTER_TYPE_PEAK, "peak" },

            { IODEFV2_COUNTER_TYPE_AVERAGE, "average" },

            { IODEFV2_COUNTER_TYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_counter {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *meaning;
         iodefv2_counter_unit_t unit;
         libiodefv2_string_t *ext_type;
         OPTIONAL_INT(iodefv2_counter_duration_t, duration);
         libiodefv2_string_t *ext_unit;
         iodefv2_counter_type_t type;
         libiodefv2_string_t *ext_duration;
};



        
/**
 * iodefv2_monetary_impact_severity_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_monetary_impact_severity_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_monetary_impact_severity_t iodefv2_monetary_impact_severity_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_monetary_impact_severity_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_MONETARY_IMPACT_SEVERITY_LOW, "low" },


            { IODEFV2_MONETARY_IMPACT_SEVERITY_MEDIUM, "medium" },


            { IODEFV2_MONETARY_IMPACT_SEVERITY_HIGH, "high" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for monetary_impact_severity", name);

}
/**
 * iodefv2_monetary_impact_severity_to_string:
 * @val: an enumeration value for #iodefv2_monetary_impact_severity_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_monetary_impact_severity_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_monetary_impact_severity_to_string(iodefv2_monetary_impact_severity_t val)
{

        const struct {
              iodefv2_monetary_impact_severity_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_MONETARY_IMPACT_SEVERITY_LOW, "low" },

            { IODEFV2_MONETARY_IMPACT_SEVERITY_MEDIUM, "medium" },

            { IODEFV2_MONETARY_IMPACT_SEVERITY_HIGH, "high" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_monetary_impact {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
        REQUIRED(libiodefv2_string_t, *currency);
         OPTIONAL_INT(iodefv2_monetary_impact_severity_t, severity);
};



        


struct iodefv2_service_name {

         IODEFV2_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *url;
         libiodefv2_string_t *iana_service;
         libiodefv2_string_t *description;
};



        


struct iodefv2_indicator_id {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *version;
         libiodefv2_string_t *name;
};



        


struct iodefv2_signature_data {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *signature;
};



        
/**
 * iodefv2_address_category_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_address_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_address_category_t iodefv2_address_category_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_address_category_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_ADDRESS_CATEGORY_ASN, "asn" },


            { IODEFV2_ADDRESS_CATEGORY_ATM, "atm" },


            { IODEFV2_ADDRESS_CATEGORY_E_MAIL, "e-mail" },


            { IODEFV2_ADDRESS_CATEGORY_IPV4_ADDR, "ipv4-addr" },


            { IODEFV2_ADDRESS_CATEGORY_IPV4_NET, "ipv4-net" },


            { IODEFV2_ADDRESS_CATEGORY_IPV4_NET_MASK, "ipv4-net-mask" },


            { IODEFV2_ADDRESS_CATEGORY_IPV6_ADDR, "ipv6-addr" },


            { IODEFV2_ADDRESS_CATEGORY_IPV6_NET, "ipv6-net" },


            { IODEFV2_ADDRESS_CATEGORY_IPV6_NET_MASK, "ipv6-net-mask" },


            { IODEFV2_ADDRESS_CATEGORY_MAC, "mac" },


            { IODEFV2_ADDRESS_CATEGORY_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for address_category", name);

}
/**
 * iodefv2_address_category_to_string:
 * @val: an enumeration value for #iodefv2_address_category_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_address_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_address_category_to_string(iodefv2_address_category_t val)
{

        const struct {
              iodefv2_address_category_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_ADDRESS_CATEGORY_ASN, "asn" },

            { IODEFV2_ADDRESS_CATEGORY_ATM, "atm" },

            { IODEFV2_ADDRESS_CATEGORY_E_MAIL, "e-mail" },

            { IODEFV2_ADDRESS_CATEGORY_IPV4_ADDR, "ipv4-addr" },

            { IODEFV2_ADDRESS_CATEGORY_IPV4_NET, "ipv4-net" },

            { IODEFV2_ADDRESS_CATEGORY_IPV4_NET_MASK, "ipv4-net-mask" },

            { IODEFV2_ADDRESS_CATEGORY_IPV6_ADDR, "ipv6-addr" },

            { IODEFV2_ADDRESS_CATEGORY_IPV6_NET, "ipv6-net" },

            { IODEFV2_ADDRESS_CATEGORY_IPV6_NET_MASK, "ipv6-net-mask" },

            { IODEFV2_ADDRESS_CATEGORY_MAC, "mac" },

            { IODEFV2_ADDRESS_CATEGORY_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_address {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         iodefv2_address_category_t category;
         libiodefv2_string_t *vlan_name;
         libiodefv2_string_t *ext_category;
         libiodefv2_string_t *vlan_num;
         libiodefv2_string_t *observable_id;
};



        


struct iodefv2_application_header {

         IODEFV2_OBJECT;
         REFCOUNT;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
};



        
/**
 * iodefv2_certificate_data_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_certificate_data_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_certificate_data_restriction_t iodefv2_certificate_data_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_certificate_data_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_WHITE, "white" },


            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_GREEN, "green" },


            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_AMBER, "amber" },


            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for certificate_data_restriction", name);

}
/**
 * iodefv2_certificate_data_restriction_to_string:
 * @val: an enumeration value for #iodefv2_certificate_data_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_certificate_data_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_certificate_data_restriction_to_string(iodefv2_certificate_data_restriction_t val)
{

        const struct {
              iodefv2_certificate_data_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_WHITE, "white" },

            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_GREEN, "green" },

            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_AMBER, "amber" },

            { IODEFV2_CERTIFICATE_DATA_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_certificate_data {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_certificate_data_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
         libiodefv2_string_t *observable_id;
        LISTED_OBJECT(certificate_list, iodefv2_certificate_t);
};



        
/**
 * iodefv2_threat_actor_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_threat_actor_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_threat_actor_restriction_t iodefv2_threat_actor_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_threat_actor_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_THREAT_ACTOR_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_THREAT_ACTOR_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_THREAT_ACTOR_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_THREAT_ACTOR_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_THREAT_ACTOR_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_THREAT_ACTOR_RESTRICTION_WHITE, "white" },


            { IODEFV2_THREAT_ACTOR_RESTRICTION_GREEN, "green" },


            { IODEFV2_THREAT_ACTOR_RESTRICTION_AMBER, "amber" },


            { IODEFV2_THREAT_ACTOR_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for threat_actor_restriction", name);

}
/**
 * iodefv2_threat_actor_restriction_to_string:
 * @val: an enumeration value for #iodefv2_threat_actor_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_threat_actor_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_threat_actor_restriction_to_string(iodefv2_threat_actor_restriction_t val)
{

        const struct {
              iodefv2_threat_actor_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_THREAT_ACTOR_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_THREAT_ACTOR_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_THREAT_ACTOR_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_THREAT_ACTOR_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_THREAT_ACTOR_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_THREAT_ACTOR_RESTRICTION_WHITE, "white" },

            { IODEFV2_THREAT_ACTOR_RESTRICTION_GREEN, "green" },

            { IODEFV2_THREAT_ACTOR_RESTRICTION_AMBER, "amber" },

            { IODEFV2_THREAT_ACTOR_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_threat_actor {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_threat_actor_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
         libiodefv2_string_t *url;
         libiodefv2_string_t *threat_actor_id;
         libiodefv2_string_t *description;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
};



        
/**
 * iodefv2_method_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_method_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_method_restriction_t iodefv2_method_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_method_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_METHOD_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_METHOD_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_METHOD_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_METHOD_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_METHOD_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_METHOD_RESTRICTION_WHITE, "white" },


            { IODEFV2_METHOD_RESTRICTION_GREEN, "green" },


            { IODEFV2_METHOD_RESTRICTION_AMBER, "amber" },


            { IODEFV2_METHOD_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for method_restriction", name);

}
/**
 * iodefv2_method_restriction_to_string:
 * @val: an enumeration value for #iodefv2_method_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_method_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_method_restriction_to_string(iodefv2_method_restriction_t val)
{

        const struct {
              iodefv2_method_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_METHOD_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_METHOD_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_METHOD_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_METHOD_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_METHOD_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_METHOD_RESTRICTION_WHITE, "white" },

            { IODEFV2_METHOD_RESTRICTION_GREEN, "green" },

            { IODEFV2_METHOD_RESTRICTION_AMBER, "amber" },

            { IODEFV2_METHOD_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_method {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_method_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         libiodefv2_string_t *description;
        LISTED_OBJECT(reference_list, iodefv2_reference_t);
};



        
/**
 * iodefv2_alternative_id_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_alternative_id_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_alternative_id_restriction_t iodefv2_alternative_id_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_alternative_id_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_WHITE, "white" },


            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_GREEN, "green" },


            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_AMBER, "amber" },


            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for alternative_id_restriction", name);

}
/**
 * iodefv2_alternative_id_restriction_to_string:
 * @val: an enumeration value for #iodefv2_alternative_id_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_alternative_id_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_alternative_id_restriction_to_string(iodefv2_alternative_id_restriction_t val)
{

        const struct {
              iodefv2_alternative_id_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_WHITE, "white" },

            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_GREEN, "green" },

            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_AMBER, "amber" },

            { IODEFV2_ALTERNATIVE_ID_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_alternative_id {

         IODEFV2_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_alternative_id_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
        LISTED_OBJECT(incident_id_list, iodefv2_incident_id_t);
};



        


struct iodefv2_software {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *url;
         libiodefv2_string_t *description;
         iodefv2_software_reference_t *software_reference;
};



        


struct iodefv2_nameservers {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
        LISTED_OBJECT(address_list, iodefv2_address_t);
        REQUIRED(libiodefv2_string_t, *server);
};



        


struct iodefv2_windows_registry_keys_modified {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *observable_id;
        LISTED_OBJECT(key_list, iodefv2_key_t);
};



        
/**
 * iodefv2_campaign_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_campaign_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_campaign_restriction_t iodefv2_campaign_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_campaign_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_CAMPAIGN_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_CAMPAIGN_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_CAMPAIGN_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_CAMPAIGN_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_CAMPAIGN_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_CAMPAIGN_RESTRICTION_WHITE, "white" },


            { IODEFV2_CAMPAIGN_RESTRICTION_GREEN, "green" },


            { IODEFV2_CAMPAIGN_RESTRICTION_AMBER, "amber" },


            { IODEFV2_CAMPAIGN_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for campaign_restriction", name);

}
/**
 * iodefv2_campaign_restriction_to_string:
 * @val: an enumeration value for #iodefv2_campaign_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_campaign_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_campaign_restriction_to_string(iodefv2_campaign_restriction_t val)
{

        const struct {
              iodefv2_campaign_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_CAMPAIGN_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_CAMPAIGN_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_CAMPAIGN_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_CAMPAIGN_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_CAMPAIGN_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_CAMPAIGN_RESTRICTION_WHITE, "white" },

            { IODEFV2_CAMPAIGN_RESTRICTION_GREEN, "green" },

            { IODEFV2_CAMPAIGN_RESTRICTION_AMBER, "amber" },

            { IODEFV2_CAMPAIGN_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_campaign {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_campaign_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
         libiodefv2_string_t *url;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         libiodefv2_string_t *description;
         libiodefv2_string_t *campaign_id;
};



        
/**
 * iodefv2_assessment_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_assessment_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_assessment_restriction_t iodefv2_assessment_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_assessment_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_ASSESSMENT_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_ASSESSMENT_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_ASSESSMENT_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_ASSESSMENT_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_ASSESSMENT_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_ASSESSMENT_RESTRICTION_WHITE, "white" },


            { IODEFV2_ASSESSMENT_RESTRICTION_GREEN, "green" },


            { IODEFV2_ASSESSMENT_RESTRICTION_AMBER, "amber" },


            { IODEFV2_ASSESSMENT_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for assessment_restriction", name);

}
/**
 * iodefv2_assessment_restriction_to_string:
 * @val: an enumeration value for #iodefv2_assessment_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_assessment_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_assessment_restriction_to_string(iodefv2_assessment_restriction_t val)
{

        const struct {
              iodefv2_assessment_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_ASSESSMENT_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_ASSESSMENT_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_ASSESSMENT_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_ASSESSMENT_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_ASSESSMENT_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_ASSESSMENT_RESTRICTION_WHITE, "white" },

            { IODEFV2_ASSESSMENT_RESTRICTION_GREEN, "green" },

            { IODEFV2_ASSESSMENT_RESTRICTION_AMBER, "amber" },

            { IODEFV2_ASSESSMENT_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_assessment_occurrence_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_assessment_occurrence_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_assessment_occurrence_t iodefv2_assessment_occurrence_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_assessment_occurrence_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_ASSESSMENT_OCCURRENCE_ACTUAL, "actual" },


            { IODEFV2_ASSESSMENT_OCCURRENCE_POTENTIAL, "potential" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for assessment_occurrence", name);

}
/**
 * iodefv2_assessment_occurrence_to_string:
 * @val: an enumeration value for #iodefv2_assessment_occurrence_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_assessment_occurrence_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_assessment_occurrence_to_string(iodefv2_assessment_occurrence_t val)
{

        const struct {
              iodefv2_assessment_occurrence_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_ASSESSMENT_OCCURRENCE_ACTUAL, "actual" },

            { IODEFV2_ASSESSMENT_OCCURRENCE_POTENTIAL, "potential" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_assessment {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_assessment_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
         OPTIONAL_INT(iodefv2_assessment_occurrence_t, occurrence);
         libiodefv2_string_t *observable_id;
        LISTED_OBJECT(intended_impact_list, iodefv2_intended_impact_t);
         iodefv2_confidence_t *confidence;
        LISTED_OBJECT(time_impact_list, iodefv2_time_impact_t);
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
        LISTED_OBJECT(monetary_impact_list, iodefv2_monetary_impact_t);
        LISTED_OBJECT(counter_list, iodefv2_counter_t);
        LISTED_OBJECT(system_impact_list, iodefv2_system_impact_t);
        LISTED_OBJECT(business_impact_list, iodefv2_business_impact_t);
         libiodefv2_string_t *incident_category;
         libiodefv2_string_t *mitigating_factor;
         libiodefv2_string_t *cause;
};



        


struct iodefv2_attack_phase {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *url;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         libiodefv2_string_t *description;
         libiodefv2_string_t *attack_phase_id;
};



        
/**
 * iodefv2_contact_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_contact_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_contact_restriction_t iodefv2_contact_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_contact_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_CONTACT_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_CONTACT_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_CONTACT_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_CONTACT_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_CONTACT_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_CONTACT_RESTRICTION_WHITE, "white" },


            { IODEFV2_CONTACT_RESTRICTION_GREEN, "green" },


            { IODEFV2_CONTACT_RESTRICTION_AMBER, "amber" },


            { IODEFV2_CONTACT_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for contact_restriction", name);

}
/**
 * iodefv2_contact_restriction_to_string:
 * @val: an enumeration value for #iodefv2_contact_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_contact_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_contact_restriction_to_string(iodefv2_contact_restriction_t val)
{

        const struct {
              iodefv2_contact_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_CONTACT_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_CONTACT_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_CONTACT_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_CONTACT_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_CONTACT_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_CONTACT_RESTRICTION_WHITE, "white" },

            { IODEFV2_CONTACT_RESTRICTION_GREEN, "green" },

            { IODEFV2_CONTACT_RESTRICTION_AMBER, "amber" },

            { IODEFV2_CONTACT_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_contact_role_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_contact_role_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_contact_role_t iodefv2_contact_role_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_contact_role_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_CONTACT_ROLE_CREATOR, "creator" },


            { IODEFV2_CONTACT_ROLE_ADMIN, "admin" },


            { IODEFV2_CONTACT_ROLE_TECH, "tech" },


            { IODEFV2_CONTACT_ROLE_IRT, "irt" },


            { IODEFV2_CONTACT_ROLE_CC, "cc" },


            { IODEFV2_CONTACT_ROLE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for contact_role", name);

}
/**
 * iodefv2_contact_role_to_string:
 * @val: an enumeration value for #iodefv2_contact_role_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_contact_role_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_contact_role_to_string(iodefv2_contact_role_t val)
{

        const struct {
              iodefv2_contact_role_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_CONTACT_ROLE_CREATOR, "creator" },

            { IODEFV2_CONTACT_ROLE_ADMIN, "admin" },

            { IODEFV2_CONTACT_ROLE_TECH, "tech" },

            { IODEFV2_CONTACT_ROLE_IRT, "irt" },

            { IODEFV2_CONTACT_ROLE_CC, "cc" },

            { IODEFV2_CONTACT_ROLE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_contact_type_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_contact_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_contact_type_t iodefv2_contact_type_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_contact_type_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_CONTACT_TYPE_PERSON, "person" },


            { IODEFV2_CONTACT_TYPE_ORGANIZATION, "organization" },


            { IODEFV2_CONTACT_TYPE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for contact_type", name);

}
/**
 * iodefv2_contact_type_to_string:
 * @val: an enumeration value for #iodefv2_contact_type_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_contact_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_contact_type_to_string(iodefv2_contact_type_t val)
{

        const struct {
              iodefv2_contact_type_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_CONTACT_TYPE_PERSON, "person" },

            { IODEFV2_CONTACT_TYPE_ORGANIZATION, "organization" },

            { IODEFV2_CONTACT_TYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_contact {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_contact_restriction_t, restriction);
         iodefv2_contact_role_t role;
         libiodefv2_string_t *ext_type;
         libiodefv2_string_t *ext_role;
         libiodefv2_string_t *ext_restriction;
         iodefv2_contact_type_t type;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         libiodefv2_string_t *contact_title;
         libiodefv2_string_t *description;
        LISTED_OBJECT(telephone_list, iodefv2_telephone_t);
        LISTED_OBJECT(email_list, iodefv2_email_t);
         libiodefv2_string_t *contact_name;
         libiodefv2_string_t *timezone;
        LISTED_OBJECT(postal_address_list, iodefv2_postal_address_t);
        LISTED_OBJECT(registry_handle_list, iodefv2_registry_handle_t);
};



        
/**
 * iodefv2_related_activity_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_related_activity_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_related_activity_restriction_t iodefv2_related_activity_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_related_activity_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_WHITE, "white" },


            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_GREEN, "green" },


            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_AMBER, "amber" },


            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for related_activity_restriction", name);

}
/**
 * iodefv2_related_activity_restriction_to_string:
 * @val: an enumeration value for #iodefv2_related_activity_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_related_activity_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_related_activity_restriction_to_string(iodefv2_related_activity_restriction_t val)
{

        const struct {
              iodefv2_related_activity_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_WHITE, "white" },

            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_GREEN, "green" },

            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_AMBER, "amber" },

            { IODEFV2_RELATED_ACTIVITY_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_related_activity {

         IODEFV2_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_related_activity_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         iodefv2_confidence_t *confidence;
         libiodefv2_string_t *description;
        LISTED_OBJECT(campaign_list, iodefv2_campaign_t);
         libiodefv2_string_t *url;
        LISTED_OBJECT(threat_actor_list, iodefv2_threat_actor_t);
        LISTED_OBJECT(indicator_id_list, iodefv2_indicator_id_t);
        LISTED_OBJECT(incident_id_list, iodefv2_incident_id_t);
};



        


struct iodefv2_domain_contacts {

         IODEFV2_OBJECT;
         REFCOUNT;
        LISTED_OBJECT(contact_list, iodefv2_contact_t);
         libiodefv2_string_t *same_domain_contact;
};



        
/**
 * iodefv2_history_item_action_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_history_item_action_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_history_item_action_t iodefv2_history_item_action_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_history_item_action_t val;
              const char *name;
        } tbl[] = {
        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for history_item_action", name);

}
/**
 * iodefv2_history_item_action_to_string:
 * @val: an enumeration value for #iodefv2_history_item_action_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_history_item_action_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_history_item_action_to_string(iodefv2_history_item_action_t val)
{

        const struct {
              iodefv2_history_item_action_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_history_item_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_history_item_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_history_item_restriction_t iodefv2_history_item_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_history_item_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_HISTORY_ITEM_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_HISTORY_ITEM_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_HISTORY_ITEM_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_HISTORY_ITEM_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_HISTORY_ITEM_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_HISTORY_ITEM_RESTRICTION_WHITE, "white" },


            { IODEFV2_HISTORY_ITEM_RESTRICTION_GREEN, "green" },


            { IODEFV2_HISTORY_ITEM_RESTRICTION_AMBER, "amber" },


            { IODEFV2_HISTORY_ITEM_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for history_item_restriction", name);

}
/**
 * iodefv2_history_item_restriction_to_string:
 * @val: an enumeration value for #iodefv2_history_item_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_history_item_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_history_item_restriction_to_string(iodefv2_history_item_restriction_t val)
{

        const struct {
              iodefv2_history_item_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_HISTORY_ITEM_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_HISTORY_ITEM_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_HISTORY_ITEM_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_HISTORY_ITEM_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_HISTORY_ITEM_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_HISTORY_ITEM_RESTRICTION_WHITE, "white" },

            { IODEFV2_HISTORY_ITEM_RESTRICTION_GREEN, "green" },

            { IODEFV2_HISTORY_ITEM_RESTRICTION_AMBER, "amber" },

            { IODEFV2_HISTORY_ITEM_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_history_item {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         iodefv2_history_item_action_t action;
         OPTIONAL_INT(iodefv2_history_item_restriction_t, restriction);
         libiodefv2_string_t *ext_action;
         libiodefv2_string_t *ext_restriction;
         libiodefv2_string_t *observable_id;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         iodefv2_contact_t *contact;
         libiodefv2_string_t *defined_coa;
         libiodefv2_string_t *description;
         iodefv2_incident_id_t *incident_id;
        REQUIRED(iodefv2_time_t, *date_time);
};



        


struct iodefv2_fuzzy_hash {

         IODEFV2_OBJECT;
         REFCOUNT;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         iodefv2_software_t *software;
};



        


struct iodefv2_hash {

         IODEFV2_OBJECT;
         REFCOUNT;
        REQUIRED(libiodefv2_string_t, *digest_value);
        REQUIRED(libiodefv2_string_t, *digest_method);
         libiodefv2_string_t *canonicalization_method;
         iodefv2_software_t *software;
};



        
/**
 * iodefv2_detection_pattern_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_detection_pattern_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_detection_pattern_restriction_t iodefv2_detection_pattern_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_detection_pattern_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_DETECTION_PATTERN_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_DETECTION_PATTERN_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_DETECTION_PATTERN_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_DETECTION_PATTERN_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_DETECTION_PATTERN_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_DETECTION_PATTERN_RESTRICTION_WHITE, "white" },


            { IODEFV2_DETECTION_PATTERN_RESTRICTION_GREEN, "green" },


            { IODEFV2_DETECTION_PATTERN_RESTRICTION_AMBER, "amber" },


            { IODEFV2_DETECTION_PATTERN_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for detection_pattern_restriction", name);

}
/**
 * iodefv2_detection_pattern_restriction_to_string:
 * @val: an enumeration value for #iodefv2_detection_pattern_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_detection_pattern_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_detection_pattern_restriction_to_string(iodefv2_detection_pattern_restriction_t val)
{

        const struct {
              iodefv2_detection_pattern_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_DETECTION_PATTERN_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_DETECTION_PATTERN_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_DETECTION_PATTERN_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_DETECTION_PATTERN_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_DETECTION_PATTERN_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_DETECTION_PATTERN_RESTRICTION_WHITE, "white" },

            { IODEFV2_DETECTION_PATTERN_RESTRICTION_GREEN, "green" },

            { IODEFV2_DETECTION_PATTERN_RESTRICTION_AMBER, "amber" },

            { IODEFV2_DETECTION_PATTERN_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_detection_pattern {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_detection_pattern_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
         libiodefv2_string_t *observable_id;
         libiodefv2_string_t *detection_configuration;
         libiodefv2_string_t *description;
        REQUIRED(iodefv2_software_t, *software);
};



        
/**
 * iodefv2_expectation_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_expectation_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_expectation_restriction_t iodefv2_expectation_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_expectation_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_EXPECTATION_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_EXPECTATION_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_EXPECTATION_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_EXPECTATION_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_EXPECTATION_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_EXPECTATION_RESTRICTION_WHITE, "white" },


            { IODEFV2_EXPECTATION_RESTRICTION_GREEN, "green" },


            { IODEFV2_EXPECTATION_RESTRICTION_AMBER, "amber" },


            { IODEFV2_EXPECTATION_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for expectation_restriction", name);

}
/**
 * iodefv2_expectation_restriction_to_string:
 * @val: an enumeration value for #iodefv2_expectation_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_expectation_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_expectation_restriction_to_string(iodefv2_expectation_restriction_t val)
{

        const struct {
              iodefv2_expectation_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_EXPECTATION_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_EXPECTATION_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_EXPECTATION_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_EXPECTATION_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_EXPECTATION_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_EXPECTATION_RESTRICTION_WHITE, "white" },

            { IODEFV2_EXPECTATION_RESTRICTION_GREEN, "green" },

            { IODEFV2_EXPECTATION_RESTRICTION_AMBER, "amber" },

            { IODEFV2_EXPECTATION_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_expectation_severity_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_expectation_severity_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_expectation_severity_t iodefv2_expectation_severity_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_expectation_severity_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_EXPECTATION_SEVERITY_LOW, "low" },


            { IODEFV2_EXPECTATION_SEVERITY_MEDIUM, "medium" },


            { IODEFV2_EXPECTATION_SEVERITY_HIGH, "high" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for expectation_severity", name);

}
/**
 * iodefv2_expectation_severity_to_string:
 * @val: an enumeration value for #iodefv2_expectation_severity_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_expectation_severity_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_expectation_severity_to_string(iodefv2_expectation_severity_t val)
{

        const struct {
              iodefv2_expectation_severity_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_EXPECTATION_SEVERITY_LOW, "low" },

            { IODEFV2_EXPECTATION_SEVERITY_MEDIUM, "medium" },

            { IODEFV2_EXPECTATION_SEVERITY_HIGH, "high" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_expectation_action_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_expectation_action_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_expectation_action_t iodefv2_expectation_action_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_expectation_action_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_EXPECTATION_ACTION_NOTHING, "nothing" },


            { IODEFV2_EXPECTATION_ACTION_CONTACT_SOURCE_SITE, "contact-source-site" },


            { IODEFV2_EXPECTATION_ACTION_CONTACT_TARGET_SITE, "contact-target-site" },


            { IODEFV2_EXPECTATION_ACTION_CONTACT_SENDER, "contact-sender" },


            { IODEFV2_EXPECTATION_ACTION_INVESTIGATE, "investigate" },


            { IODEFV2_EXPECTATION_ACTION_BLOCK_HOST, "block-host" },


            { IODEFV2_EXPECTATION_ACTION_BLOCK_NETWORK, "block-network" },


            { IODEFV2_EXPECTATION_ACTION_BLOCK_PORT, "block-port" },


            { IODEFV2_EXPECTATION_ACTION_RATE_LIMIT_HOST, "rate-limit-host" },


            { IODEFV2_EXPECTATION_ACTION_RATE_LIMIT_NETWORK, "rate-limit-network" },


            { IODEFV2_EXPECTATION_ACTION_RATE_LIMIT_PORT, "rate-limit-port" },


            { IODEFV2_EXPECTATION_ACTION_REMEDIATE_OTHER, "remediate-other" },


            { IODEFV2_EXPECTATION_ACTION_STATUS_TRIAGE, "status-triage" },


            { IODEFV2_EXPECTATION_ACTION_STATUS_NEW_INFO, "status-new-info" },


            { IODEFV2_EXPECTATION_ACTION_OTHER, "other" },


            { IODEFV2_EXPECTATION_ACTION_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for expectation_action", name);

}
/**
 * iodefv2_expectation_action_to_string:
 * @val: an enumeration value for #iodefv2_expectation_action_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_expectation_action_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_expectation_action_to_string(iodefv2_expectation_action_t val)
{

        const struct {
              iodefv2_expectation_action_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_EXPECTATION_ACTION_NOTHING, "nothing" },

            { IODEFV2_EXPECTATION_ACTION_CONTACT_SOURCE_SITE, "contact-source-site" },

            { IODEFV2_EXPECTATION_ACTION_CONTACT_TARGET_SITE, "contact-target-site" },

            { IODEFV2_EXPECTATION_ACTION_CONTACT_SENDER, "contact-sender" },

            { IODEFV2_EXPECTATION_ACTION_INVESTIGATE, "investigate" },

            { IODEFV2_EXPECTATION_ACTION_BLOCK_HOST, "block-host" },

            { IODEFV2_EXPECTATION_ACTION_BLOCK_NETWORK, "block-network" },

            { IODEFV2_EXPECTATION_ACTION_BLOCK_PORT, "block-port" },

            { IODEFV2_EXPECTATION_ACTION_RATE_LIMIT_HOST, "rate-limit-host" },

            { IODEFV2_EXPECTATION_ACTION_RATE_LIMIT_NETWORK, "rate-limit-network" },

            { IODEFV2_EXPECTATION_ACTION_RATE_LIMIT_PORT, "rate-limit-port" },

            { IODEFV2_EXPECTATION_ACTION_REMEDIATE_OTHER, "remediate-other" },

            { IODEFV2_EXPECTATION_ACTION_STATUS_TRIAGE, "status-triage" },

            { IODEFV2_EXPECTATION_ACTION_STATUS_NEW_INFO, "status-new-info" },

            { IODEFV2_EXPECTATION_ACTION_OTHER, "other" },

            { IODEFV2_EXPECTATION_ACTION_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_expectation {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_expectation_restriction_t, restriction);
         libiodefv2_string_t *ext_action;
         libiodefv2_string_t *ext_severity;
         OPTIONAL_INT(iodefv2_expectation_severity_t, severity);
         OPTIONAL_INT(iodefv2_expectation_action_t, action);
         libiodefv2_string_t *ext_restriction;
         iodefv2_time_t *end_time;
         libiodefv2_string_t *defined_coa;
         libiodefv2_string_t *description;
         iodefv2_time_t *start_time;
         iodefv2_contact_t *contact;
};



        
/**
 * iodefv2_domain_data_domain_status_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_domain_data_domain_status_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_domain_data_domain_status_t iodefv2_domain_data_domain_status_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_domain_data_domain_status_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_RESERVED_DELEGATION, "reserveddelegation" },


            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_ASSIGNED_AND_ACTIVE, "assignedandactive" },


            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_ASSIGNED_AND_INACTIVE, "assignedandinactive" },


            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_ASSIGNED_AND_ON_HOLD, "assignedandonhold" },


            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_REVOKED, "revoked" },


            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_TRANSFER_PENDING, "transferpending" },


            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_REGISTRY_LOCK, "registrylock" },


            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_REGISTRAR_LOCK, "registrarlock" },


            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_OTHER, "other" },


            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_UNKNOWN, "unknown" },


            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for domain_data_domain_status", name);

}
/**
 * iodefv2_domain_data_domain_status_to_string:
 * @val: an enumeration value for #iodefv2_domain_data_domain_status_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_domain_data_domain_status_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_domain_data_domain_status_to_string(iodefv2_domain_data_domain_status_t val)
{

        const struct {
              iodefv2_domain_data_domain_status_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_RESERVED_DELEGATION, "reserveddelegation" },

            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_ASSIGNED_AND_ACTIVE, "assignedandactive" },

            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_ASSIGNED_AND_INACTIVE, "assignedandinactive" },

            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_ASSIGNED_AND_ON_HOLD, "assignedandonhold" },

            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_REVOKED, "revoked" },

            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_TRANSFER_PENDING, "transferpending" },

            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_REGISTRY_LOCK, "registrylock" },

            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_REGISTRAR_LOCK, "registrarlock" },

            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_OTHER, "other" },

            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_UNKNOWN, "unknown" },

            { IODEFV2_DOMAIN_DATA_DOMAIN_STATUS_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_domain_data_system_status_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_domain_data_system_status_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_domain_data_system_status_t iodefv2_domain_data_system_status_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_domain_data_system_status_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_DOMAIN_DATA_SYSTEM_STATUS_SPOOFED, "spoofed" },


            { IODEFV2_DOMAIN_DATA_SYSTEM_STATUS_FRAUDULENT, "fraudulent" },


            { IODEFV2_DOMAIN_DATA_SYSTEM_STATUS_INNOCENT_HACKED, "innocent-hacked" },


            { IODEFV2_DOMAIN_DATA_SYSTEM_STATUS_INNOCENT_HIJACKED, "innocent-hijacked" },


            { IODEFV2_DOMAIN_DATA_SYSTEM_STATUS_UNKNOWN, "unknown" },


            { IODEFV2_DOMAIN_DATA_SYSTEM_STATUS_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for domain_data_system_status", name);

}
/**
 * iodefv2_domain_data_system_status_to_string:
 * @val: an enumeration value for #iodefv2_domain_data_system_status_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_domain_data_system_status_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_domain_data_system_status_to_string(iodefv2_domain_data_system_status_t val)
{

        const struct {
              iodefv2_domain_data_system_status_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_DOMAIN_DATA_SYSTEM_STATUS_SPOOFED, "spoofed" },

            { IODEFV2_DOMAIN_DATA_SYSTEM_STATUS_FRAUDULENT, "fraudulent" },

            { IODEFV2_DOMAIN_DATA_SYSTEM_STATUS_INNOCENT_HACKED, "innocent-hacked" },

            { IODEFV2_DOMAIN_DATA_SYSTEM_STATUS_INNOCENT_HIJACKED, "innocent-hijacked" },

            { IODEFV2_DOMAIN_DATA_SYSTEM_STATUS_UNKNOWN, "unknown" },

            { IODEFV2_DOMAIN_DATA_SYSTEM_STATUS_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_domain_data {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *ext_domain_status;
         iodefv2_domain_data_domain_status_t domain_status;
         libiodefv2_string_t *ext_system_status;
         libiodefv2_string_t *observable_id;
         iodefv2_domain_data_system_status_t system_status;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
        REQUIRED(libiodefv2_string_t, *name);
        LISTED_OBJECT(nameservers_list, iodefv2_nameservers_t);
         iodefv2_time_t *registration_date;
         iodefv2_domain_contacts_t *domain_contacts;
         iodefv2_time_t *date_domain_was_checked;
         iodefv2_time_t *expiration_date;
};



        
/**
 * iodefv2_hash_data_scope_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_hash_data_scope_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_hash_data_scope_t iodefv2_hash_data_scope_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_hash_data_scope_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_HASH_DATA_SCOPE_FILE_CONTENT, "file-content" },


            { IODEFV2_HASH_DATA_SCOPE_FILE_PE_SECTION, "file-pe-section" },


            { IODEFV2_HASH_DATA_SCOPE_FILE_PE_IAT, "file-pe-iat" },


            { IODEFV2_HASH_DATA_SCOPE_FILE_PE_RESOURCE, "file-pe-resource" },


            { IODEFV2_HASH_DATA_SCOPE_FILE_PDF_OBJECT, "file-pdf-object" },


            { IODEFV2_HASH_DATA_SCOPE_EMAIL_HASH, "email-hash" },


            { IODEFV2_HASH_DATA_SCOPE_EMAIL_HEADERS_HASH, "email-headers-hash" },


            { IODEFV2_HASH_DATA_SCOPE_EMAIL_BODY_HASH, "email-body-hash" },


            { IODEFV2_HASH_DATA_SCOPE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for hash_data_scope", name);

}
/**
 * iodefv2_hash_data_scope_to_string:
 * @val: an enumeration value for #iodefv2_hash_data_scope_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_hash_data_scope_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_hash_data_scope_to_string(iodefv2_hash_data_scope_t val)
{

        const struct {
              iodefv2_hash_data_scope_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_HASH_DATA_SCOPE_FILE_CONTENT, "file-content" },

            { IODEFV2_HASH_DATA_SCOPE_FILE_PE_SECTION, "file-pe-section" },

            { IODEFV2_HASH_DATA_SCOPE_FILE_PE_IAT, "file-pe-iat" },

            { IODEFV2_HASH_DATA_SCOPE_FILE_PE_RESOURCE, "file-pe-resource" },

            { IODEFV2_HASH_DATA_SCOPE_FILE_PDF_OBJECT, "file-pdf-object" },

            { IODEFV2_HASH_DATA_SCOPE_EMAIL_HASH, "email-hash" },

            { IODEFV2_HASH_DATA_SCOPE_EMAIL_HEADERS_HASH, "email-headers-hash" },

            { IODEFV2_HASH_DATA_SCOPE_EMAIL_BODY_HASH, "email-body-hash" },

            { IODEFV2_HASH_DATA_SCOPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_hash_data {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_hash_data_scope_t, scope);
         libiodefv2_string_t *ext_scope;
         libiodefv2_string_t *hash_target_id;
         iodefv2_hash_t *hash;
         iodefv2_fuzzy_hash_t *fuzzy_hash;
};



        


struct iodefv2_bulk_observable_format {

         IODEFV2_OBJECT;
         REFCOUNT;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         iodefv2_hash_t *hash;
};



        
/**
 * iodefv2_history_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_history_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_history_restriction_t iodefv2_history_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_history_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for history_restriction", name);

}
/**
 * iodefv2_history_restriction_to_string:
 * @val: an enumeration value for #iodefv2_history_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_history_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_history_restriction_to_string(iodefv2_history_restriction_t val)
{

        const struct {
              iodefv2_history_restriction_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_history {

         IODEFV2_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_history_restriction_t, restriction);
        LISTED_OBJECT(history_item_list, iodefv2_history_item_t);
};



        
/**
 * iodefv2_discovery_source_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_discovery_source_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_discovery_source_t iodefv2_discovery_source_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_discovery_source_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_DISCOVERY_SOURCE_NIDPS, "nidps" },


            { IODEFV2_DISCOVERY_SOURCE_HIPS, "hips" },


            { IODEFV2_DISCOVERY_SOURCE_SIEM, "siem" },


            { IODEFV2_DISCOVERY_SOURCE_AV, "av" },


            { IODEFV2_DISCOVERY_SOURCE_THIRD_PARTY_MONITORING, "third-party-monitoring" },


            { IODEFV2_DISCOVERY_SOURCE_INCIDENT, "incident" },


            { IODEFV2_DISCOVERY_SOURCE_OS_LOG, "os-log" },


            { IODEFV2_DISCOVERY_SOURCE_APPLICATION_LOG, "application-log" },


            { IODEFV2_DISCOVERY_SOURCE_DEVICE_LOG, "device-log" },


            { IODEFV2_DISCOVERY_SOURCE_NETWORK_FLOW, "network-flow" },


            { IODEFV2_DISCOVERY_SOURCE_PASSIVE_DNS, "passive-dns" },


            { IODEFV2_DISCOVERY_SOURCE_INVESTIGATION, "investigation" },


            { IODEFV2_DISCOVERY_SOURCE_AUDIT, "audit" },


            { IODEFV2_DISCOVERY_SOURCE_INTERNAL_NOTIFICATION, "internal-notification" },


            { IODEFV2_DISCOVERY_SOURCE_EXTERNAL_NOTIFICATION, "external-notification" },


            { IODEFV2_DISCOVERY_SOURCE_LEO, "leo" },


            { IODEFV2_DISCOVERY_SOURCE_PARTNER, "partner" },


            { IODEFV2_DISCOVERY_SOURCE_ACTOR, "actor" },


            { IODEFV2_DISCOVERY_SOURCE_UNKNOWN, "unknown" },


            { IODEFV2_DISCOVERY_SOURCE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for discovery_source", name);

}
/**
 * iodefv2_discovery_source_to_string:
 * @val: an enumeration value for #iodefv2_discovery_source_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_discovery_source_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_discovery_source_to_string(iodefv2_discovery_source_t val)
{

        const struct {
              iodefv2_discovery_source_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_DISCOVERY_SOURCE_NIDPS, "nidps" },

            { IODEFV2_DISCOVERY_SOURCE_HIPS, "hips" },

            { IODEFV2_DISCOVERY_SOURCE_SIEM, "siem" },

            { IODEFV2_DISCOVERY_SOURCE_AV, "av" },

            { IODEFV2_DISCOVERY_SOURCE_THIRD_PARTY_MONITORING, "third-party-monitoring" },

            { IODEFV2_DISCOVERY_SOURCE_INCIDENT, "incident" },

            { IODEFV2_DISCOVERY_SOURCE_OS_LOG, "os-log" },

            { IODEFV2_DISCOVERY_SOURCE_APPLICATION_LOG, "application-log" },

            { IODEFV2_DISCOVERY_SOURCE_DEVICE_LOG, "device-log" },

            { IODEFV2_DISCOVERY_SOURCE_NETWORK_FLOW, "network-flow" },

            { IODEFV2_DISCOVERY_SOURCE_PASSIVE_DNS, "passive-dns" },

            { IODEFV2_DISCOVERY_SOURCE_INVESTIGATION, "investigation" },

            { IODEFV2_DISCOVERY_SOURCE_AUDIT, "audit" },

            { IODEFV2_DISCOVERY_SOURCE_INTERNAL_NOTIFICATION, "internal-notification" },

            { IODEFV2_DISCOVERY_SOURCE_EXTERNAL_NOTIFICATION, "external-notification" },

            { IODEFV2_DISCOVERY_SOURCE_LEO, "leo" },

            { IODEFV2_DISCOVERY_SOURCE_PARTNER, "partner" },

            { IODEFV2_DISCOVERY_SOURCE_ACTOR, "actor" },

            { IODEFV2_DISCOVERY_SOURCE_UNKNOWN, "unknown" },

            { IODEFV2_DISCOVERY_SOURCE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_discovery_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_discovery_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_discovery_restriction_t iodefv2_discovery_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_discovery_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_DISCOVERY_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_DISCOVERY_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_DISCOVERY_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_DISCOVERY_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_DISCOVERY_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_DISCOVERY_RESTRICTION_WHITE, "white" },


            { IODEFV2_DISCOVERY_RESTRICTION_GREEN, "green" },


            { IODEFV2_DISCOVERY_RESTRICTION_AMBER, "amber" },


            { IODEFV2_DISCOVERY_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for discovery_restriction", name);

}
/**
 * iodefv2_discovery_restriction_to_string:
 * @val: an enumeration value for #iodefv2_discovery_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_discovery_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_discovery_restriction_to_string(iodefv2_discovery_restriction_t val)
{

        const struct {
              iodefv2_discovery_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_DISCOVERY_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_DISCOVERY_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_DISCOVERY_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_DISCOVERY_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_DISCOVERY_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_DISCOVERY_RESTRICTION_WHITE, "white" },

            { IODEFV2_DISCOVERY_RESTRICTION_GREEN, "green" },

            { IODEFV2_DISCOVERY_RESTRICTION_AMBER, "amber" },

            { IODEFV2_DISCOVERY_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_discovery {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_discovery_source_t, source);
         libiodefv2_string_t *ext_restriction;
         libiodefv2_string_t *ext_source;
         libiodefv2_string_t *observable_id;
         OPTIONAL_INT(iodefv2_discovery_restriction_t, restriction);
        LISTED_OBJECT(detection_pattern_list, iodefv2_detection_pattern_t);
        LISTED_OBJECT(contact_list, iodefv2_contact_t);
         libiodefv2_string_t *description;
};



        
/**
 * iodefv2_bulk_observable_type_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_bulk_observable_type_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_bulk_observable_type_t iodefv2_bulk_observable_type_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_bulk_observable_type_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_BULK_OBSERVABLE_TYPE_ASN, "asn" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_ATM, "atm" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_E_MAIL, "e-mail" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV4_ADDR, "ipv4-addr" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV4_NET, "ipv4-net" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV4_NET_MASK, "ipv4-net-mask" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV6_ADDR, "ipv6-addr" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV6_NET, "ipv6-net" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV6_NET_MASK, "ipv6-net-mask" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_MAC, "mac" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_SITE_URI, "site-uri" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_DOMAIN_NAME, "domain-name" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_DOMAIN_TO_IPV4, "domain-to-ipv4" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_DOMAIN_TO_IPV6, "domain-to-ipv6" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_DOMAIN_TO_IPV4_TIMESTAMP, "domain-to-ipv4-timestamp" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_DOMAIN_TO_IPV6_TIMESTAMP, "domain-to-ipv6-timestamp" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV4_PORT, "ipv4-port" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV6_PORT, "ipv6-port" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_WINDOWS_REG_KEY, "windows-reg-key" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_FILE_HASH, "file-hash" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_EMAIL_X_MAILER, "email-x-mailer" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_EMAIL_SUBJECT, "email-subject" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_HTTP_USER_AGENT, "http-user-agent" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_HTTP_REQUEST_URI, "http-request-uri" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_AMBER, "amber" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_FILE_PATH, "file-path" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_USER_NAME, "user-name" },


            { IODEFV2_BULK_OBSERVABLE_TYPE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for bulk_observable_type", name);

}
/**
 * iodefv2_bulk_observable_type_to_string:
 * @val: an enumeration value for #iodefv2_bulk_observable_type_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_bulk_observable_type_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_bulk_observable_type_to_string(iodefv2_bulk_observable_type_t val)
{

        const struct {
              iodefv2_bulk_observable_type_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_BULK_OBSERVABLE_TYPE_ASN, "asn" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_ATM, "atm" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_E_MAIL, "e-mail" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV4_ADDR, "ipv4-addr" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV4_NET, "ipv4-net" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV4_NET_MASK, "ipv4-net-mask" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV6_ADDR, "ipv6-addr" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV6_NET, "ipv6-net" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV6_NET_MASK, "ipv6-net-mask" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_MAC, "mac" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_SITE_URI, "site-uri" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_DOMAIN_NAME, "domain-name" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_DOMAIN_TO_IPV4, "domain-to-ipv4" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_DOMAIN_TO_IPV6, "domain-to-ipv6" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_DOMAIN_TO_IPV4_TIMESTAMP, "domain-to-ipv4-timestamp" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_DOMAIN_TO_IPV6_TIMESTAMP, "domain-to-ipv6-timestamp" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV4_PORT, "ipv4-port" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_IPV6_PORT, "ipv6-port" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_WINDOWS_REG_KEY, "windows-reg-key" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_FILE_HASH, "file-hash" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_EMAIL_X_MAILER, "email-x-mailer" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_EMAIL_SUBJECT, "email-subject" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_HTTP_USER_AGENT, "http-user-agent" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_HTTP_REQUEST_URI, "http-request-uri" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_AMBER, "amber" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_FILE_PATH, "file-path" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_USER_NAME, "user-name" },

            { IODEFV2_BULK_OBSERVABLE_TYPE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_bulk_observable {

         IODEFV2_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_bulk_observable_type_t, type);
         libiodefv2_string_t *ext_type;
         libiodefv2_string_t *bulk_observable_list;
         iodefv2_bulk_observable_format_t *bulk_observable_format;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
};



        


struct iodefv2_email_data {

         IODEFV2_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *observable_id;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         libiodefv2_string_t *email_headers;
        LISTED_OBJECT(signature_data_list, iodefv2_signature_data_t);
         libiodefv2_string_t *email_subject;
         libiodefv2_string_t *email_x_mailer;
        LISTED_OBJECT(hash_data_list, iodefv2_hash_data_t);
         libiodefv2_string_t *email_from;
         iodefv2_application_header_t *application_header;
         libiodefv2_string_t *email_body;
         libiodefv2_string_t *email_message;
         libiodefv2_string_t *email_to;
};



        


struct iodefv2_file {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *observable_id;
         iodefv2_hash_data_t *hash_data;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         iodefv2_signature_data_t *signature_data;
         libiodefv2_string_t *url;
         iodefv2_software_t *software;
         libiodefv2_string_t *file_name;
};



        


struct iodefv2_node {

         IODEFV2_OBJECT;
         REFCOUNT;
         libiodefv2_string_t *postal_address;
        LISTED_OBJECT(counter_list, iodefv2_counter_t);
         libiodefv2_string_t *location;
        LISTED_OBJECT(domain_data_list, iodefv2_domain_data_t);
        LISTED_OBJECT(address_list, iodefv2_address_t);
};



        


struct iodefv2_service {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         uint32_t ip_protocol;
         libiodefv2_string_t *observable_id;
         OPTIONAL_INT(uint32_t, proto_code);
         libiodefv2_string_t *portlist;
         OPTIONAL_INT(uint32_t, proto_field);
         iodefv2_service_name_t *service_name;
         iodefv2_application_header_t *application_header;
         iodefv2_email_data_t *email_data;
         OPTIONAL_INT(uint32_t, proto_type);
         OPTIONAL_INT(uint32_t, port);
        LISTED_OBJECT(software_list, iodefv2_software_t);
};



        
/**
 * iodefv2_file_data_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_file_data_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_file_data_restriction_t iodefv2_file_data_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_file_data_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_FILE_DATA_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_FILE_DATA_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_FILE_DATA_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_FILE_DATA_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_FILE_DATA_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_FILE_DATA_RESTRICTION_WHITE, "white" },


            { IODEFV2_FILE_DATA_RESTRICTION_GREEN, "green" },


            { IODEFV2_FILE_DATA_RESTRICTION_AMBER, "amber" },


            { IODEFV2_FILE_DATA_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for file_data_restriction", name);

}
/**
 * iodefv2_file_data_restriction_to_string:
 * @val: an enumeration value for #iodefv2_file_data_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_file_data_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_file_data_restriction_to_string(iodefv2_file_data_restriction_t val)
{

        const struct {
              iodefv2_file_data_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_FILE_DATA_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_FILE_DATA_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_FILE_DATA_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_FILE_DATA_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_FILE_DATA_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_FILE_DATA_RESTRICTION_WHITE, "white" },

            { IODEFV2_FILE_DATA_RESTRICTION_GREEN, "green" },

            { IODEFV2_FILE_DATA_RESTRICTION_AMBER, "amber" },

            { IODEFV2_FILE_DATA_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_file_data {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_file_data_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
         libiodefv2_string_t *observable_id;
        LISTED_OBJECT(file_list, iodefv2_file_t);
};



        
/**
 * iodefv2_system_category_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_system_category_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_system_category_t iodefv2_system_category_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_system_category_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_SYSTEM_CATEGORY_SOURCE, "source" },


            { IODEFV2_SYSTEM_CATEGORY_TARGET, "target" },


            { IODEFV2_SYSTEM_CATEGORY_INTERMEDIATE, "intermediate" },


            { IODEFV2_SYSTEM_CATEGORY_SENSOR, "sensor" },


            { IODEFV2_SYSTEM_CATEGORY_INFRASTRUCTURE, "infrastructure" },


            { IODEFV2_SYSTEM_CATEGORY_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for system_category", name);

}
/**
 * iodefv2_system_category_to_string:
 * @val: an enumeration value for #iodefv2_system_category_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_system_category_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_system_category_to_string(iodefv2_system_category_t val)
{

        const struct {
              iodefv2_system_category_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_SYSTEM_CATEGORY_SOURCE, "source" },

            { IODEFV2_SYSTEM_CATEGORY_TARGET, "target" },

            { IODEFV2_SYSTEM_CATEGORY_INTERMEDIATE, "intermediate" },

            { IODEFV2_SYSTEM_CATEGORY_SENSOR, "sensor" },

            { IODEFV2_SYSTEM_CATEGORY_INFRASTRUCTURE, "infrastructure" },

            { IODEFV2_SYSTEM_CATEGORY_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_system_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_system_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_system_restriction_t iodefv2_system_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_system_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_SYSTEM_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_SYSTEM_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_SYSTEM_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_SYSTEM_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_SYSTEM_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_SYSTEM_RESTRICTION_WHITE, "white" },


            { IODEFV2_SYSTEM_RESTRICTION_GREEN, "green" },


            { IODEFV2_SYSTEM_RESTRICTION_AMBER, "amber" },


            { IODEFV2_SYSTEM_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for system_restriction", name);

}
/**
 * iodefv2_system_restriction_to_string:
 * @val: an enumeration value for #iodefv2_system_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_system_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_system_restriction_to_string(iodefv2_system_restriction_t val)
{

        const struct {
              iodefv2_system_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_SYSTEM_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_SYSTEM_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_SYSTEM_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_SYSTEM_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_SYSTEM_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_SYSTEM_RESTRICTION_WHITE, "white" },

            { IODEFV2_SYSTEM_RESTRICTION_GREEN, "green" },

            { IODEFV2_SYSTEM_RESTRICTION_AMBER, "amber" },

            { IODEFV2_SYSTEM_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_system_spoofed_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_system_spoofed_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_system_spoofed_t iodefv2_system_spoofed_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_system_spoofed_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_SYSTEM_SPOOFED_UNKNOWN, "unknown" },


            { IODEFV2_SYSTEM_SPOOFED_YES, "yes" },


            { IODEFV2_SYSTEM_SPOOFED_NO, "no" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for system_spoofed", name);

}
/**
 * iodefv2_system_spoofed_to_string:
 * @val: an enumeration value for #iodefv2_system_spoofed_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_system_spoofed_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_system_spoofed_to_string(iodefv2_system_spoofed_t val)
{

        const struct {
              iodefv2_system_spoofed_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_SYSTEM_SPOOFED_UNKNOWN, "unknown" },

            { IODEFV2_SYSTEM_SPOOFED_YES, "yes" },

            { IODEFV2_SYSTEM_SPOOFED_NO, "no" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_system_virtual_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_system_virtual_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_system_virtual_t iodefv2_system_virtual_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_system_virtual_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_SYSTEM_VIRTUAL_YES, "yes" },


            { IODEFV2_SYSTEM_VIRTUAL_NO, "no" },


            { IODEFV2_SYSTEM_VIRTUAL_UNKNOWN, "unknown" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for system_virtual", name);

}
/**
 * iodefv2_system_virtual_to_string:
 * @val: an enumeration value for #iodefv2_system_virtual_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_system_virtual_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_system_virtual_to_string(iodefv2_system_virtual_t val)
{

        const struct {
              iodefv2_system_virtual_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_SYSTEM_VIRTUAL_YES, "yes" },

            { IODEFV2_SYSTEM_VIRTUAL_NO, "no" },

            { IODEFV2_SYSTEM_VIRTUAL_UNKNOWN, "unknown" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_system_ownership_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_system_ownership_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_system_ownership_t iodefv2_system_ownership_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_system_ownership_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_SYSTEM_OWNERSHIP_ORGANIZATION, "organization" },


            { IODEFV2_SYSTEM_OWNERSHIP_PERSONAL, "personal" },


            { IODEFV2_SYSTEM_OWNERSHIP_PARTNER, "partner" },


            { IODEFV2_SYSTEM_OWNERSHIP_CUSTOMER, "customer" },


            { IODEFV2_SYSTEM_OWNERSHIP_NO_RELATIONSHIP, "no-relationship" },


            { IODEFV2_SYSTEM_OWNERSHIP_UNKNOWN, "unknown" },


            { IODEFV2_SYSTEM_OWNERSHIP_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for system_ownership", name);

}
/**
 * iodefv2_system_ownership_to_string:
 * @val: an enumeration value for #iodefv2_system_ownership_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_system_ownership_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_system_ownership_to_string(iodefv2_system_ownership_t val)
{

        const struct {
              iodefv2_system_ownership_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_SYSTEM_OWNERSHIP_ORGANIZATION, "organization" },

            { IODEFV2_SYSTEM_OWNERSHIP_PERSONAL, "personal" },

            { IODEFV2_SYSTEM_OWNERSHIP_PARTNER, "partner" },

            { IODEFV2_SYSTEM_OWNERSHIP_CUSTOMER, "customer" },

            { IODEFV2_SYSTEM_OWNERSHIP_NO_RELATIONSHIP, "no-relationship" },

            { IODEFV2_SYSTEM_OWNERSHIP_UNKNOWN, "unknown" },

            { IODEFV2_SYSTEM_OWNERSHIP_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_system {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         iodefv2_system_category_t category;
         OPTIONAL_INT(iodefv2_system_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
         libiodefv2_string_t *ext_ownership;
         libiodefv2_string_t *ext_category;
         OPTIONAL_INT(iodefv2_system_spoofed_t, spoofed);
         OPTIONAL_INT(iodefv2_system_virtual_t, virtual);
         libiodefv2_string_t *observable_id;
         OPTIONAL_INT(iodefv2_system_ownership_t, ownership);
         libiodefv2_string_t *interface;
         iodefv2_node_t *node;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         libiodefv2_string_t *description;
        LISTED_OBJECT(service_list, iodefv2_service_t);
         libiodefv2_string_t *asset_id;
        LISTED_OBJECT(counter_list, iodefv2_counter_t);
        LISTED_OBJECT(node_role_list, iodefv2_node_role_t);
         iodefv2_software_t *software;
};



        
/**
 * iodefv2_record_data_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_record_data_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_record_data_restriction_t iodefv2_record_data_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_record_data_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_RECORD_DATA_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_RECORD_DATA_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_RECORD_DATA_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_RECORD_DATA_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_RECORD_DATA_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_RECORD_DATA_RESTRICTION_WHITE, "white" },


            { IODEFV2_RECORD_DATA_RESTRICTION_GREEN, "green" },


            { IODEFV2_RECORD_DATA_RESTRICTION_AMBER, "amber" },


            { IODEFV2_RECORD_DATA_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for record_data_restriction", name);

}
/**
 * iodefv2_record_data_restriction_to_string:
 * @val: an enumeration value for #iodefv2_record_data_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_record_data_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_record_data_restriction_to_string(iodefv2_record_data_restriction_t val)
{

        const struct {
              iodefv2_record_data_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_RECORD_DATA_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_RECORD_DATA_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_RECORD_DATA_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_RECORD_DATA_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_RECORD_DATA_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_RECORD_DATA_RESTRICTION_WHITE, "white" },

            { IODEFV2_RECORD_DATA_RESTRICTION_GREEN, "green" },

            { IODEFV2_RECORD_DATA_RESTRICTION_AMBER, "amber" },

            { IODEFV2_RECORD_DATA_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_record_data {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_record_data_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
         libiodefv2_string_t *observable_id;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         libiodefv2_string_t *description;
         libiodefv2_string_t *url;
        LISTED_OBJECT(certificate_data_list, iodefv2_certificate_data_t);
        LISTED_OBJECT(record_pattern_list, iodefv2_record_pattern_t);
         iodefv2_time_t *date_time;
        LISTED_OBJECT(windows_registry_keys_modified_list, iodefv2_windows_registry_keys_modified_t);
        LISTED_OBJECT(file_data_list, iodefv2_file_data_t);
         iodefv2_software_t *software;
};



        
/**
 * iodefv2_record_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_record_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_record_restriction_t iodefv2_record_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_record_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_RECORD_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_RECORD_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_RECORD_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_RECORD_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_RECORD_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_RECORD_RESTRICTION_WHITE, "white" },


            { IODEFV2_RECORD_RESTRICTION_GREEN, "green" },


            { IODEFV2_RECORD_RESTRICTION_AMBER, "amber" },


            { IODEFV2_RECORD_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for record_restriction", name);

}
/**
 * iodefv2_record_restriction_to_string:
 * @val: an enumeration value for #iodefv2_record_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_record_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_record_restriction_to_string(iodefv2_record_restriction_t val)
{

        const struct {
              iodefv2_record_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_RECORD_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_RECORD_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_RECORD_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_RECORD_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_RECORD_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_RECORD_RESTRICTION_WHITE, "white" },

            { IODEFV2_RECORD_RESTRICTION_GREEN, "green" },

            { IODEFV2_RECORD_RESTRICTION_AMBER, "amber" },

            { IODEFV2_RECORD_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_record {

         IODEFV2_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_record_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
        LISTED_OBJECT(record_data_list, iodefv2_record_data_t);
};



        


struct iodefv2_flow {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
        LISTED_OBJECT(system_list, iodefv2_system_t);
};



        
/**
 * iodefv2_event_data_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_event_data_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_event_data_restriction_t iodefv2_event_data_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_event_data_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_EVENT_DATA_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_EVENT_DATA_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_EVENT_DATA_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_EVENT_DATA_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_EVENT_DATA_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_EVENT_DATA_RESTRICTION_WHITE, "white" },


            { IODEFV2_EVENT_DATA_RESTRICTION_GREEN, "green" },


            { IODEFV2_EVENT_DATA_RESTRICTION_AMBER, "amber" },


            { IODEFV2_EVENT_DATA_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for event_data_restriction", name);

}
/**
 * iodefv2_event_data_restriction_to_string:
 * @val: an enumeration value for #iodefv2_event_data_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_event_data_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_event_data_restriction_to_string(iodefv2_event_data_restriction_t val)
{

        const struct {
              iodefv2_event_data_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_EVENT_DATA_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_EVENT_DATA_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_EVENT_DATA_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_EVENT_DATA_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_EVENT_DATA_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_EVENT_DATA_RESTRICTION_WHITE, "white" },

            { IODEFV2_EVENT_DATA_RESTRICTION_GREEN, "green" },

            { IODEFV2_EVENT_DATA_RESTRICTION_AMBER, "amber" },

            { IODEFV2_EVENT_DATA_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_event_data {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_event_data_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
         libiodefv2_string_t *observable_id;
         iodefv2_time_t *detect_time;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         iodefv2_time_t *report_time;
         libiodefv2_string_t *description;
        LISTED_OBJECT(flow_list, iodefv2_flow_t);
        LISTED_OBJECT(expectation_list, iodefv2_expectation_t);
         iodefv2_record_t *record;
        LISTED_OBJECT(contact_list, iodefv2_contact_t);
         iodefv2_time_t *start_time;
         iodefv2_time_t *end_time;
         iodefv2_assessment_t *assessment;
        LISTED_OBJECT(method_list, iodefv2_method_t);
         iodefv2_time_t *recovery_time;
        LISTED_OBJECT(discovery_list, iodefv2_discovery_t);
};



        
/**
 * iodefv2_observable_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_observable_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_observable_restriction_t iodefv2_observable_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_observable_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_OBSERVABLE_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_OBSERVABLE_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_OBSERVABLE_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_OBSERVABLE_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_OBSERVABLE_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_OBSERVABLE_RESTRICTION_WHITE, "white" },


            { IODEFV2_OBSERVABLE_RESTRICTION_GREEN, "green" },


            { IODEFV2_OBSERVABLE_RESTRICTION_AMBER, "amber" },


            { IODEFV2_OBSERVABLE_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for observable_restriction", name);

}
/**
 * iodefv2_observable_restriction_to_string:
 * @val: an enumeration value for #iodefv2_observable_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_observable_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_observable_restriction_to_string(iodefv2_observable_restriction_t val)
{

        const struct {
              iodefv2_observable_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_OBSERVABLE_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_OBSERVABLE_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_OBSERVABLE_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_OBSERVABLE_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_OBSERVABLE_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_OBSERVABLE_RESTRICTION_WHITE, "white" },

            { IODEFV2_OBSERVABLE_RESTRICTION_GREEN, "green" },

            { IODEFV2_OBSERVABLE_RESTRICTION_AMBER, "amber" },

            { IODEFV2_OBSERVABLE_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_observable {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_observable_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
         iodefv2_detection_pattern_t *detection_pattern;
         iodefv2_service_t *service;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         iodefv2_system_t *system;
         iodefv2_domain_data_t *domain_data;
         iodefv2_email_data_t *email_data;
         iodefv2_assessment_t *assessment;
         iodefv2_record_data_t *record_data;
         iodefv2_reference_t *reference;
         iodefv2_history_item_t *history_item;
         iodefv2_bulk_observable_t *bulk_observable;
         iodefv2_certificate_data_t *certificate_data;
         iodefv2_expectation_t *expectation;
         iodefv2_windows_registry_keys_modified_t *windows_registry_keys_modified;
         iodefv2_address_t *address;
         iodefv2_event_data_t *event_data;
         iodefv2_file_data_t *file_data;
         iodefv2_registry_handle_t *registry_handle;
};



        
/**
 * iodefv2_indicator_expression_operator_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_indicator_expression_operator_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_indicator_expression_operator_t iodefv2_indicator_expression_operator_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_indicator_expression_operator_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_INDICATOR_EXPRESSION_OPERATOR_NOT, "not" },


            { IODEFV2_INDICATOR_EXPRESSION_OPERATOR_AND, "and" },


            { IODEFV2_INDICATOR_EXPRESSION_OPERATOR_OR, "or" },


            { IODEFV2_INDICATOR_EXPRESSION_OPERATOR_XOR, "xor" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for indicator_expression_operator", name);

}
/**
 * iodefv2_indicator_expression_operator_to_string:
 * @val: an enumeration value for #iodefv2_indicator_expression_operator_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_indicator_expression_operator_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_indicator_expression_operator_to_string(iodefv2_indicator_expression_operator_t val)
{

        const struct {
              iodefv2_indicator_expression_operator_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_INDICATOR_EXPRESSION_OPERATOR_NOT, "not" },

            { IODEFV2_INDICATOR_EXPRESSION_OPERATOR_AND, "and" },

            { IODEFV2_INDICATOR_EXPRESSION_OPERATOR_OR, "or" },

            { IODEFV2_INDICATOR_EXPRESSION_OPERATOR_XOR, "xor" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_indicator_expression {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_indicator_expression_operator_t, operator);
         libiodefv2_string_t *ext_operator;
        LISTED_OBJECT(indicator_reference_list, iodefv2_indicator_reference_t);
        LISTED_OBJECT(observable_list, iodefv2_observable_t);
         iodefv2_confidence_t *confidence;
        LISTED_OBJECT(indicator_expression_list, iodefv2_indicator_expression_t);
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
};



        
/**
 * iodefv2_indicator_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_indicator_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_indicator_restriction_t iodefv2_indicator_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_indicator_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_INDICATOR_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_INDICATOR_RESTRICTION_PARTNER, "partner" },


            { IODEFV2_INDICATOR_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_INDICATOR_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_INDICATOR_RESTRICTION_DEFAULT, "default" },


            { IODEFV2_INDICATOR_RESTRICTION_WHITE, "white" },


            { IODEFV2_INDICATOR_RESTRICTION_GREEN, "green" },


            { IODEFV2_INDICATOR_RESTRICTION_AMBER, "amber" },


            { IODEFV2_INDICATOR_RESTRICTION_RED, "red" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for indicator_restriction", name);

}
/**
 * iodefv2_indicator_restriction_to_string:
 * @val: an enumeration value for #iodefv2_indicator_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_indicator_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_indicator_restriction_to_string(iodefv2_indicator_restriction_t val)
{

        const struct {
              iodefv2_indicator_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_INDICATOR_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_INDICATOR_RESTRICTION_PARTNER, "partner" },

            { IODEFV2_INDICATOR_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_INDICATOR_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_INDICATOR_RESTRICTION_DEFAULT, "default" },

            { IODEFV2_INDICATOR_RESTRICTION_WHITE, "white" },

            { IODEFV2_INDICATOR_RESTRICTION_GREEN, "green" },

            { IODEFV2_INDICATOR_RESTRICTION_AMBER, "amber" },

            { IODEFV2_INDICATOR_RESTRICTION_RED, "red" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_indicator {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         OPTIONAL_INT(iodefv2_indicator_restriction_t, restriction);
         libiodefv2_string_t *ext_restriction;
        LISTED_OBJECT(alternative_indicator_id_list, iodefv2_alternative_indicator_id_t);
         iodefv2_confidence_t *confidence;
        LISTED_OBJECT(reference_list, iodefv2_reference_t);
         iodefv2_observable_t *observable;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         iodefv2_indicator_expression_t *indicator_expression;
        LISTED_OBJECT(contact_list, iodefv2_contact_t);
        LISTED_OBJECT(node_role_list, iodefv2_node_role_t);
         iodefv2_time_t *start_time;
        REQUIRED(iodefv2_indicator_id_t, *indicator_id);
         iodefv2_indicator_reference_t *indicator_reference;
         iodefv2_observable_reference_t *observable_reference;
        LISTED_OBJECT(attack_phase_list, iodefv2_attack_phase_t);
         iodefv2_time_t *end_time;
};



        


struct iodefv2_indicator_data {

         IODEFV2_OBJECT;
         REFCOUNT;
        LISTED_OBJECT(indicator_list, iodefv2_indicator_t);
};



        
/**
 * iodefv2_incident_status_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_incident_status_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_incident_status_t iodefv2_incident_status_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_incident_status_t val;
              const char *name;
        } tbl[] = {
        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for incident_status", name);

}
/**
 * iodefv2_incident_status_to_string:
 * @val: an enumeration value for #iodefv2_incident_status_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_incident_status_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_incident_status_to_string(iodefv2_incident_status_t val)
{

        const struct {
              iodefv2_incident_status_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_incident_lang_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_incident_lang_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_incident_lang_t iodefv2_incident_lang_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_incident_lang_t val;
              const char *name;
        } tbl[] = {
        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for incident_lang", name);

}
/**
 * iodefv2_incident_lang_to_string:
 * @val: an enumeration value for #iodefv2_incident_lang_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_incident_lang_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_incident_lang_to_string(iodefv2_incident_lang_t val)
{

        const struct {
              iodefv2_incident_lang_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_incident_purpose_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_incident_purpose_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_incident_purpose_t iodefv2_incident_purpose_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_incident_purpose_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_INCIDENT_PURPOSE_TRACEBACK, "traceback" },


            { IODEFV2_INCIDENT_PURPOSE_MITIGATION, "mitigation" },


            { IODEFV2_INCIDENT_PURPOSE_REPORTING, "reporting" },


            { IODEFV2_INCIDENT_PURPOSE_WATCH, "watch" },


            { IODEFV2_INCIDENT_PURPOSE_OTHER, "other" },


            { IODEFV2_INCIDENT_PURPOSE_EXT_VALUE, "ext-value" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for incident_purpose", name);

}
/**
 * iodefv2_incident_purpose_to_string:
 * @val: an enumeration value for #iodefv2_incident_purpose_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_incident_purpose_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_incident_purpose_to_string(iodefv2_incident_purpose_t val)
{

        const struct {
              iodefv2_incident_purpose_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_INCIDENT_PURPOSE_TRACEBACK, "traceback" },

            { IODEFV2_INCIDENT_PURPOSE_MITIGATION, "mitigation" },

            { IODEFV2_INCIDENT_PURPOSE_REPORTING, "reporting" },

            { IODEFV2_INCIDENT_PURPOSE_WATCH, "watch" },

            { IODEFV2_INCIDENT_PURPOSE_OTHER, "other" },

            { IODEFV2_INCIDENT_PURPOSE_EXT_VALUE, "ext-value" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        
/**
 * iodefv2_incident_restriction_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_incident_restriction_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_incident_restriction_t iodefv2_incident_restriction_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_incident_restriction_t val;
              const char *name;
        } tbl[] = {

            { IODEFV2_INCIDENT_RESTRICTION_PUBLIC, "public" },


            { IODEFV2_INCIDENT_RESTRICTION_NEED_TO_KNOW, "need-to-know" },


            { IODEFV2_INCIDENT_RESTRICTION_PRIVATE, "private" },


            { IODEFV2_INCIDENT_RESTRICTION_DEFAULT, "default" },

        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for incident_restriction", name);

}
/**
 * iodefv2_incident_restriction_to_string:
 * @val: an enumeration value for #iodefv2_incident_restriction_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_incident_restriction_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_incident_restriction_to_string(iodefv2_incident_restriction_t val)
{

        const struct {
              iodefv2_incident_restriction_t val;
              const char *name;
        } tbl[] = {
            { 0, NULL },

            { IODEFV2_INCIDENT_RESTRICTION_PUBLIC, "public" },

            { IODEFV2_INCIDENT_RESTRICTION_NEED_TO_KNOW, "need-to-know" },

            { IODEFV2_INCIDENT_RESTRICTION_PRIVATE, "private" },

            { IODEFV2_INCIDENT_RESTRICTION_DEFAULT, "default" },
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_incident {

         IODEFV2_LINKED_OBJECT;
         REFCOUNT;
         iodefv2_incident_status_t status;
         OPTIONAL_INT(iodefv2_incident_lang_t, lang);
         libiodefv2_string_t *ext_purpose;
         iodefv2_incident_purpose_t purpose;
         libiodefv2_string_t *ext_status;
         OPTIONAL_INT(iodefv2_incident_restriction_t, restriction);
         libiodefv2_string_t *observable_id;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
         iodefv2_history_t *history;
         iodefv2_time_t *start_time;
         iodefv2_alternative_id_t *alternative_id;
        LISTED_OBJECT(contact_list, iodefv2_contact_t);
         iodefv2_related_activity_t *related_activity;
         iodefv2_time_t *end_time;
         iodefv2_time_t *generation_time;
        LISTED_OBJECT(assessment_list, iodefv2_assessment_t);
        LISTED_OBJECT(method_list, iodefv2_method_t);
         iodefv2_time_t *recovery_time;
        LISTED_OBJECT(discovery_list, iodefv2_discovery_t);
         iodefv2_time_t *detect_time;
         iodefv2_time_t *report_time;
         libiodefv2_string_t *description;
         iodefv2_indicator_data_t *indicator_data;
        LISTED_OBJECT(event_data_list, iodefv2_event_data_t);
         iodefv2_incident_id_t *incident_id;
};



        
/**
 * iodefv2_document_lang_to_numeric:
 * @name: pointer to an IODEFV2 string representation of a #iodefv2_document_lang_t value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
iodefv2_document_lang_t iodefv2_document_lang_to_numeric(const char *name)
{
       size_t i;
        const struct {
              iodefv2_document_lang_t val;
              const char *name;
        } tbl[] = {
        };

        libiodefv2_return_val_if_fail(name, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_IODEFV2_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for document_lang", name);

}
/**
 * iodefv2_document_lang_to_string:
 * @val: an enumeration value for #iodefv2_document_lang_t.
 *
 * Return the IODEFV2 string equivalent of @val provided #iodefv2_document_lang_t value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *iodefv2_document_lang_to_string(iodefv2_document_lang_t val)
{

        const struct {
              iodefv2_document_lang_t val;
              const char *name;
        } tbl[] = {
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}

        


struct iodefv2_document {

         IODEFV2_OBJECT;
         REFCOUNT;
         iodefv2_document_lang_t lang;
         libiodefv2_string_t *formatid;
        REQUIRED(libiodefv2_string_t, *version);
         libiodefv2_string_t *private_enum_name;
         libiodefv2_string_t *private_enum_id;
        LISTED_OBJECT(additional_data_list, iodefv2_additional_data_t);
        LISTED_OBJECT(incident_list, iodefv2_incident_t);
};



        



/**
 * iodefv2_telephone_new:
 * @ret: Pointer where to store the created #iodefv2_telephone_t object.
 *
 * Create a new #iodefv2_telephone_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_telephone_new(iodefv2_telephone_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_TELEPHONE;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;




        {
            int retval = libiodefv2_string_new(&(*ret)->telephone_number);

            if ( retval < 0 ) {
                    iodefv2_telephone_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

            return 0;
}


/**
 * iodefv2_telephone_ref:
 * @telephone: pointer to a #iodefv2_telephone_t object.
 *
 * Increase @telephone reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @telephone.
 */
iodefv2_telephone_t *iodefv2_telephone_ref(iodefv2_telephone_t *telephone)
{
        libiodefv2_return_val_if_fail(telephone, NULL);
        telephone->refcount++;

        return telephone;
}



int _iodefv2_telephone_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_telephone_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->type_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_TELEPHONE_TYPE , ptr->type);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_type, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->telephone_number, TRUE);



            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_telephone_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_telephone_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_telephone_new_type(ptr, (iodefv2_telephone_type_t **) ret);

                case 1:
                    return iodefv2_telephone_new_ext_type(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_telephone_new_telephone_number(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_telephone_new_description(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_telephone_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_telephone_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->type_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_type ) {
                                libiodefv2_string_destroy(ptr->ext_type);
                                ptr->ext_type = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->telephone_number ) {
                                libiodefv2_string_destroy(ptr->telephone_number);
                                ptr->telephone_number = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_telephone_destroy_internal(iodefv2_telephone_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_type ) {
                libiodefv2_string_destroy(ptr->ext_type);
                ptr->ext_type = NULL;
        }



        if ( ptr->telephone_number ) {
                libiodefv2_string_destroy(ptr->telephone_number);
                ptr->telephone_number = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_telephone_destroy:
 * @ptr: pointer to a #iodefv2_telephone_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_telephone_destroy(iodefv2_telephone_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_telephone_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_telephone_get_type:
 * @ptr: pointer to a #iodefv2_telephone_t object.
 *
 * Get type children of the #iodefv2_telephone_t object.
 *
 * Returns: a pointer to a iodefv2_telephone_type_t object, or NULL if the children object is not set.
 */
iodefv2_telephone_type_t *iodefv2_telephone_get_type(iodefv2_telephone_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type_is_set ? &ptr->type : NULL;


}


/**
 * iodefv2_telephone_set_type:
 * @ptr: pointer to a #iodefv2_telephone_t object.
 * @type: pointer to a #iodefv2_telephone_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */
void iodefv2_telephone_set_type(iodefv2_telephone_t *ptr, iodefv2_telephone_type_t type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type = type;
        ptr->type_is_set = 1;
}

void iodefv2_telephone_unset_type(iodefv2_telephone_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type_is_set = 0;
}
/**
 * iodefv2_telephone_new_type:
 * @ptr: pointer to a #iodefv2_telephone_t object.
 * @ret: pointer to an address where to store the created #iodefv2_telephone_type_t object.
 *
 * Create a new type object, children of #iodefv2_telephone_t.
 * If @ptr already contain a #iodefv2_telephone_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_telephone_new_type(iodefv2_telephone_t *ptr, iodefv2_telephone_type_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->type_is_set = 1;



        *ret = &ptr->type;
        return 0;
}




/**
 * iodefv2_telephone_get_ext_type:
 * @ptr: pointer to a #iodefv2_telephone_t object.
 *
 * Get ext_type children of the #iodefv2_telephone_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_telephone_get_ext_type(iodefv2_telephone_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_type;

}


/**
 * iodefv2_telephone_set_ext_type:
 * @ptr: pointer to a #iodefv2_telephone_t object.
 * @ext_type: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_type object as a children of @ptr.
 * if @ptr already contain an @ext_type object, then it is destroyed,
 * and updated to point to the provided @ext_type object.
 */

void iodefv2_telephone_set_ext_type(iodefv2_telephone_t *ptr, libiodefv2_string_t *ext_type)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_type )
                libiodefv2_string_destroy(ptr->ext_type);

        ptr->ext_type = ext_type;
}
/**
 * iodefv2_telephone_new_ext_type:
 * @ptr: pointer to a #iodefv2_telephone_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_type object, children of #iodefv2_telephone_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_telephone_new_ext_type(iodefv2_telephone_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_type ) {
                retval = libiodefv2_string_new(&ptr->ext_type);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_type;
        return 0;
}




/**
 * iodefv2_telephone_get_telephone_number:
 * @ptr: pointer to a #iodefv2_telephone_t object.
 *
 * Get telephone_number children of the #iodefv2_telephone_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_telephone_get_telephone_number(iodefv2_telephone_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->telephone_number;

}


/**
 * iodefv2_telephone_set_telephone_number:
 * @ptr: pointer to a #iodefv2_telephone_t object.
 * @telephone_number: pointer to a #libiodefv2_string_t object.
 *
 * Set @telephone_number object as a children of @ptr.
 * if @ptr already contain an @telephone_number object, then it is destroyed,
 * and updated to point to the provided @telephone_number object.
 */

void iodefv2_telephone_set_telephone_number(iodefv2_telephone_t *ptr, libiodefv2_string_t *telephone_number)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->telephone_number )
                libiodefv2_string_destroy(ptr->telephone_number);

        ptr->telephone_number = telephone_number;
}
/**
 * iodefv2_telephone_new_telephone_number:
 * @ptr: pointer to a #iodefv2_telephone_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new telephone_number object, children of #iodefv2_telephone_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_telephone_new_telephone_number(iodefv2_telephone_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->telephone_number ) {
                retval = libiodefv2_string_new(&ptr->telephone_number);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->telephone_number;
        return 0;
}




/**
 * iodefv2_telephone_get_description:
 * @ptr: pointer to a #iodefv2_telephone_t object.
 *
 * Get description children of the #iodefv2_telephone_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_telephone_get_description(iodefv2_telephone_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_telephone_set_description:
 * @ptr: pointer to a #iodefv2_telephone_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_telephone_set_description(iodefv2_telephone_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_telephone_new_description:
 * @ptr: pointer to a #iodefv2_telephone_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_telephone_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_telephone_new_description(iodefv2_telephone_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}



/**
 * iodefv2_telephone_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_telephone_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_telephone_copy(const iodefv2_telephone_t *src, iodefv2_telephone_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->type_is_set = src->type_is_set;
        dst->type = src->type;



        if ( dst->ext_type ) {
                libiodefv2_string_destroy(dst->ext_type);
                dst->ext_type = NULL;
        }

        if ( src->ext_type ) {
                ret = libiodefv2_string_clone(src->ext_type, &dst->ext_type);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->telephone_number ) {
                ret = libiodefv2_string_copy(src->telephone_number, dst->telephone_number);
                if ( ret < 0 )
                        return ret;
        }



        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_telephone_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_telephone_clone(iodefv2_telephone_t *src, iodefv2_telephone_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_telephone_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_telephone_copy(src, *dst);
}


/**
 * iodefv2_telephone_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_telephone_compare(const iodefv2_telephone_t *obj1, const iodefv2_telephone_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->type_is_set != obj2->type_is_set )
                return -1;

        if ( obj1->type_is_set && obj1->type != obj2->type )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_type, obj2->ext_type);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->telephone_number, obj2->telephone_number);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_certificate_new:
 * @ret: Pointer where to store the created #iodefv2_certificate_t object.
 *
 * Create a new #iodefv2_certificate_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_certificate_new(iodefv2_certificate_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_CERTIFICATE;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;


        {
            int retval = iodefv2_data_new(&(*ret)->x509_data);

            if ( retval < 0 ) {
                    iodefv2_certificate_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

            return 0;
}


/**
 * iodefv2_certificate_ref:
 * @certificate: pointer to a #iodefv2_certificate_t object.
 *
 * Increase @certificate reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @certificate.
 */
iodefv2_certificate_t *iodefv2_certificate_ref(iodefv2_certificate_t *certificate)
{
        libiodefv2_return_val_if_fail(certificate, NULL);
        certificate->refcount++;

        return certificate;
}



int _iodefv2_certificate_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_certificate_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);



            case 1:

                return get_value_from_data((iodefv2_value_t **) childptr,  ptr->x509_data, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_certificate_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_certificate_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_certificate_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 1:
                    return iodefv2_certificate_new_x509_data(ptr, (iodefv2_data_t **) ret);

                case 2:
                    return iodefv2_certificate_new_description(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_certificate_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_certificate_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->x509_data ) {
                                iodefv2_data_destroy(ptr->x509_data);
                                ptr->x509_data = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_certificate_destroy_internal(iodefv2_certificate_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }



        if ( ptr->x509_data ) {
                iodefv2_data_destroy(ptr->x509_data);
                ptr->x509_data = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_certificate_destroy:
 * @ptr: pointer to a #iodefv2_certificate_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_certificate_destroy(iodefv2_certificate_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_certificate_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_certificate_get_observable_id:
 * @ptr: pointer to a #iodefv2_certificate_t object.
 *
 * Get observable_id children of the #iodefv2_certificate_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_certificate_get_observable_id(iodefv2_certificate_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_certificate_set_observable_id:
 * @ptr: pointer to a #iodefv2_certificate_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_certificate_set_observable_id(iodefv2_certificate_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_certificate_new_observable_id:
 * @ptr: pointer to a #iodefv2_certificate_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_certificate_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_certificate_new_observable_id(iodefv2_certificate_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}




/**
 * iodefv2_certificate_get_x509_data:
 * @ptr: pointer to a #iodefv2_certificate_t object.
 *
 * Get x509_data children of the #iodefv2_certificate_t object.
 *
 * Returns: a pointer to a iodefv2_data_t object, or NULL if the children object is not set.
 */
iodefv2_data_t *iodefv2_certificate_get_x509_data(iodefv2_certificate_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->x509_data;

}


/**
 * iodefv2_certificate_set_x509_data:
 * @ptr: pointer to a #iodefv2_certificate_t object.
 * @x509_data: pointer to a #iodefv2_data_t object.
 *
 * Set @x509_data object as a children of @ptr.
 * if @ptr already contain an @x509_data object, then it is destroyed,
 * and updated to point to the provided @x509_data object.
 */

void iodefv2_certificate_set_x509_data(iodefv2_certificate_t *ptr, iodefv2_data_t *x509_data)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->x509_data )
                iodefv2_data_destroy(ptr->x509_data);

        ptr->x509_data = x509_data;
}
/**
 * iodefv2_certificate_new_x509_data:
 * @ptr: pointer to a #iodefv2_certificate_t object.
 * @ret: pointer to an address where to store the created #iodefv2_data_t object.
 *
 * Create a new x509_data object, children of #iodefv2_certificate_t.
 * If @ptr already contain a #iodefv2_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_certificate_new_x509_data(iodefv2_certificate_t *ptr, iodefv2_data_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->x509_data ) {
                retval = iodefv2_data_new(&ptr->x509_data);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->x509_data;
        return 0;
}




/**
 * iodefv2_certificate_get_description:
 * @ptr: pointer to a #iodefv2_certificate_t object.
 *
 * Get description children of the #iodefv2_certificate_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_certificate_get_description(iodefv2_certificate_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_certificate_set_description:
 * @ptr: pointer to a #iodefv2_certificate_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_certificate_set_description(iodefv2_certificate_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_certificate_new_description:
 * @ptr: pointer to a #iodefv2_certificate_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_certificate_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_certificate_new_description(iodefv2_certificate_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}



/**
 * iodefv2_certificate_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_certificate_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_certificate_copy(const iodefv2_certificate_t *src, iodefv2_certificate_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->x509_data ) {
                ret = iodefv2_data_copy(src->x509_data, dst->x509_data);
                if ( ret < 0 )
                        return ret;
        }



        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_certificate_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_certificate_clone(iodefv2_certificate_t *src, iodefv2_certificate_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_certificate_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_certificate_copy(src, *dst);
}


/**
 * iodefv2_certificate_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_certificate_compare(const iodefv2_certificate_t *obj1, const iodefv2_certificate_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;

        ret = iodefv2_data_compare(obj1->x509_data, obj2->x509_data);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_key_new:
 * @ret: Pointer where to store the created #iodefv2_key_t object.
 *
 * Create a new #iodefv2_key_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_key_new(iodefv2_key_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_KEY;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;





        {
            int retval = libiodefv2_string_new(&(*ret)->key_name);

            if ( retval < 0 ) {
                    iodefv2_key_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

            return 0;
}


/**
 * iodefv2_key_ref:
 * @key: pointer to a #iodefv2_key_t object.
 *
 * Increase @key reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @key.
 */
iodefv2_key_t *iodefv2_key_ref(iodefv2_key_t *key)
{
        libiodefv2_return_val_if_fail(key, NULL);
        key->refcount++;

        return key;
}



int _iodefv2_key_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_key_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->registryaction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_KEY_REGISTRYACTION , ptr->registryaction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_registryaction, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);



            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->key_name, TRUE);



            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->key_value, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_key_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_key_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_key_new_registryaction(ptr, (iodefv2_key_registryaction_t **) ret);

                case 1:
                    return iodefv2_key_new_ext_registryaction(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_key_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_key_new_key_name(ptr, (libiodefv2_string_t **) ret);

                case 4:
                    return iodefv2_key_new_key_value(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_key_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_key_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->registryaction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_registryaction ) {
                                libiodefv2_string_destroy(ptr->ext_registryaction);
                                ptr->ext_registryaction = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->key_name ) {
                                libiodefv2_string_destroy(ptr->key_name);
                                ptr->key_name = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->key_value ) {
                                libiodefv2_string_destroy(ptr->key_value);
                                ptr->key_value = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_key_destroy_internal(iodefv2_key_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_registryaction ) {
                libiodefv2_string_destroy(ptr->ext_registryaction);
                ptr->ext_registryaction = NULL;
        }



        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }



        if ( ptr->key_name ) {
                libiodefv2_string_destroy(ptr->key_name);
                ptr->key_name = NULL;
        }



        if ( ptr->key_value ) {
                libiodefv2_string_destroy(ptr->key_value);
                ptr->key_value = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_key_destroy:
 * @ptr: pointer to a #iodefv2_key_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_key_destroy(iodefv2_key_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_key_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_key_get_registryaction:
 * @ptr: pointer to a #iodefv2_key_t object.
 *
 * Get registryaction children of the #iodefv2_key_t object.
 *
 * Returns: a pointer to a iodefv2_key_registryaction_t object, or NULL if the children object is not set.
 */
iodefv2_key_registryaction_t *iodefv2_key_get_registryaction(iodefv2_key_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->registryaction_is_set ? &ptr->registryaction : NULL;


}


/**
 * iodefv2_key_set_registryaction:
 * @ptr: pointer to a #iodefv2_key_t object.
 * @registryaction: pointer to a #iodefv2_key_registryaction_t object.
 *
 * Set @registryaction object as a children of @ptr.
 * if @ptr already contain an @registryaction object, then it is destroyed,
 * and updated to point to the provided @registryaction object.
 */
void iodefv2_key_set_registryaction(iodefv2_key_t *ptr, iodefv2_key_registryaction_t registryaction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->registryaction = registryaction;
        ptr->registryaction_is_set = 1;
}

void iodefv2_key_unset_registryaction(iodefv2_key_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->registryaction_is_set = 0;
}
/**
 * iodefv2_key_new_registryaction:
 * @ptr: pointer to a #iodefv2_key_t object.
 * @ret: pointer to an address where to store the created #iodefv2_key_registryaction_t object.
 *
 * Create a new registryaction object, children of #iodefv2_key_t.
 * If @ptr already contain a #iodefv2_key_registryaction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_key_new_registryaction(iodefv2_key_t *ptr, iodefv2_key_registryaction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->registryaction_is_set = 1;



        *ret = &ptr->registryaction;
        return 0;
}




/**
 * iodefv2_key_get_ext_registryaction:
 * @ptr: pointer to a #iodefv2_key_t object.
 *
 * Get ext_registryaction children of the #iodefv2_key_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_key_get_ext_registryaction(iodefv2_key_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_registryaction;

}


/**
 * iodefv2_key_set_ext_registryaction:
 * @ptr: pointer to a #iodefv2_key_t object.
 * @ext_registryaction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_registryaction object as a children of @ptr.
 * if @ptr already contain an @ext_registryaction object, then it is destroyed,
 * and updated to point to the provided @ext_registryaction object.
 */

void iodefv2_key_set_ext_registryaction(iodefv2_key_t *ptr, libiodefv2_string_t *ext_registryaction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_registryaction )
                libiodefv2_string_destroy(ptr->ext_registryaction);

        ptr->ext_registryaction = ext_registryaction;
}
/**
 * iodefv2_key_new_ext_registryaction:
 * @ptr: pointer to a #iodefv2_key_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_registryaction object, children of #iodefv2_key_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_key_new_ext_registryaction(iodefv2_key_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_registryaction ) {
                retval = libiodefv2_string_new(&ptr->ext_registryaction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_registryaction;
        return 0;
}




/**
 * iodefv2_key_get_observable_id:
 * @ptr: pointer to a #iodefv2_key_t object.
 *
 * Get observable_id children of the #iodefv2_key_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_key_get_observable_id(iodefv2_key_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_key_set_observable_id:
 * @ptr: pointer to a #iodefv2_key_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_key_set_observable_id(iodefv2_key_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_key_new_observable_id:
 * @ptr: pointer to a #iodefv2_key_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_key_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_key_new_observable_id(iodefv2_key_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}




/**
 * iodefv2_key_get_key_name:
 * @ptr: pointer to a #iodefv2_key_t object.
 *
 * Get key_name children of the #iodefv2_key_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_key_get_key_name(iodefv2_key_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->key_name;

}


/**
 * iodefv2_key_set_key_name:
 * @ptr: pointer to a #iodefv2_key_t object.
 * @key_name: pointer to a #libiodefv2_string_t object.
 *
 * Set @key_name object as a children of @ptr.
 * if @ptr already contain an @key_name object, then it is destroyed,
 * and updated to point to the provided @key_name object.
 */

void iodefv2_key_set_key_name(iodefv2_key_t *ptr, libiodefv2_string_t *key_name)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->key_name )
                libiodefv2_string_destroy(ptr->key_name);

        ptr->key_name = key_name;
}
/**
 * iodefv2_key_new_key_name:
 * @ptr: pointer to a #iodefv2_key_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new key_name object, children of #iodefv2_key_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_key_new_key_name(iodefv2_key_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->key_name ) {
                retval = libiodefv2_string_new(&ptr->key_name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->key_name;
        return 0;
}




/**
 * iodefv2_key_get_key_value:
 * @ptr: pointer to a #iodefv2_key_t object.
 *
 * Get key_value children of the #iodefv2_key_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_key_get_key_value(iodefv2_key_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->key_value;

}


/**
 * iodefv2_key_set_key_value:
 * @ptr: pointer to a #iodefv2_key_t object.
 * @key_value: pointer to a #libiodefv2_string_t object.
 *
 * Set @key_value object as a children of @ptr.
 * if @ptr already contain an @key_value object, then it is destroyed,
 * and updated to point to the provided @key_value object.
 */

void iodefv2_key_set_key_value(iodefv2_key_t *ptr, libiodefv2_string_t *key_value)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->key_value )
                libiodefv2_string_destroy(ptr->key_value);

        ptr->key_value = key_value;
}
/**
 * iodefv2_key_new_key_value:
 * @ptr: pointer to a #iodefv2_key_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new key_value object, children of #iodefv2_key_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_key_new_key_value(iodefv2_key_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->key_value ) {
                retval = libiodefv2_string_new(&ptr->key_value);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->key_value;
        return 0;
}



/**
 * iodefv2_key_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_key_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_key_copy(const iodefv2_key_t *src, iodefv2_key_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->registryaction_is_set = src->registryaction_is_set;
        dst->registryaction = src->registryaction;



        if ( dst->ext_registryaction ) {
                libiodefv2_string_destroy(dst->ext_registryaction);
                dst->ext_registryaction = NULL;
        }

        if ( src->ext_registryaction ) {
                ret = libiodefv2_string_clone(src->ext_registryaction, &dst->ext_registryaction);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->key_name ) {
                ret = libiodefv2_string_copy(src->key_name, dst->key_name);
                if ( ret < 0 )
                        return ret;
        }



        if ( dst->key_value ) {
                libiodefv2_string_destroy(dst->key_value);
                dst->key_value = NULL;
        }

        if ( src->key_value ) {
                ret = libiodefv2_string_clone(src->key_value, &dst->key_value);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_key_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_key_clone(iodefv2_key_t *src, iodefv2_key_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_key_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_key_copy(src, *dst);
}


/**
 * iodefv2_key_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_key_compare(const iodefv2_key_t *obj1, const iodefv2_key_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->registryaction_is_set != obj2->registryaction_is_set )
                return -1;

        if ( obj1->registryaction_is_set && obj1->registryaction != obj2->registryaction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_registryaction, obj2->ext_registryaction);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->key_name, obj2->key_name);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->key_value, obj2->key_value);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_observable_reference_new:
 * @ret: Pointer where to store the created #iodefv2_observable_reference_t object.
 *
 * Create a new #iodefv2_observable_reference_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_observable_reference_new(iodefv2_observable_reference_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_OBSERVABLE_REFERENCE;


        (*ret)->refcount = 1;

        {
            int retval = libiodefv2_string_new(&(*ret)->uid_ref);

            if ( retval < 0 ) {
                    iodefv2_observable_reference_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }
            return 0;
}


/**
 * iodefv2_observable_reference_ref:
 * @observable_reference: pointer to a #iodefv2_observable_reference_t object.
 *
 * Increase @observable_reference reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @observable_reference.
 */
iodefv2_observable_reference_t *iodefv2_observable_reference_ref(iodefv2_observable_reference_t *observable_reference)
{
        libiodefv2_return_val_if_fail(observable_reference, NULL);
        observable_reference->refcount++;

        return observable_reference;
}



int _iodefv2_observable_reference_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_observable_reference_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->uid_ref, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_observable_reference_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_observable_reference_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_observable_reference_new_uid_ref(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_observable_reference_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_observable_reference_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->uid_ref ) {
                                libiodefv2_string_destroy(ptr->uid_ref);
                                ptr->uid_ref = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_observable_reference_destroy_internal(iodefv2_observable_reference_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( ptr->uid_ref ) {
                libiodefv2_string_destroy(ptr->uid_ref);
                ptr->uid_ref = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_observable_reference_destroy:
 * @ptr: pointer to a #iodefv2_observable_reference_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_observable_reference_destroy(iodefv2_observable_reference_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_observable_reference_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_observable_reference_get_uid_ref:
 * @ptr: pointer to a #iodefv2_observable_reference_t object.
 *
 * Get uid_ref children of the #iodefv2_observable_reference_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_observable_reference_get_uid_ref(iodefv2_observable_reference_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->uid_ref;

}


/**
 * iodefv2_observable_reference_set_uid_ref:
 * @ptr: pointer to a #iodefv2_observable_reference_t object.
 * @uid_ref: pointer to a #libiodefv2_string_t object.
 *
 * Set @uid_ref object as a children of @ptr.
 * if @ptr already contain an @uid_ref object, then it is destroyed,
 * and updated to point to the provided @uid_ref object.
 */

void iodefv2_observable_reference_set_uid_ref(iodefv2_observable_reference_t *ptr, libiodefv2_string_t *uid_ref)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->uid_ref )
                libiodefv2_string_destroy(ptr->uid_ref);

        ptr->uid_ref = uid_ref;
}
/**
 * iodefv2_observable_reference_new_uid_ref:
 * @ptr: pointer to a #iodefv2_observable_reference_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new uid_ref object, children of #iodefv2_observable_reference_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_reference_new_uid_ref(iodefv2_observable_reference_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->uid_ref ) {
                retval = libiodefv2_string_new(&ptr->uid_ref);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->uid_ref;
        return 0;
}



/**
 * iodefv2_observable_reference_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_observable_reference_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_observable_reference_copy(const iodefv2_observable_reference_t *src, iodefv2_observable_reference_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;


        if ( src->uid_ref ) {
                ret = libiodefv2_string_copy(src->uid_ref, dst->uid_ref);
                if ( ret < 0 )
                        return ret;
        }
    return 0 ;
}


/**
 * iodefv2_observable_reference_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_observable_reference_clone(iodefv2_observable_reference_t *src, iodefv2_observable_reference_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_observable_reference_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_observable_reference_copy(src, *dst);
}


/**
 * iodefv2_observable_reference_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_observable_reference_compare(const iodefv2_observable_reference_t *obj1, const iodefv2_observable_reference_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->uid_ref, obj2->uid_ref);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_registry_handle_new:
 * @ret: Pointer where to store the created #iodefv2_registry_handle_t object.
 *
 * Create a new #iodefv2_registry_handle_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_registry_handle_new(iodefv2_registry_handle_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_REGISTRY_HANDLE;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;



            return 0;
}


/**
 * iodefv2_registry_handle_ref:
 * @registry_handle: pointer to a #iodefv2_registry_handle_t object.
 *
 * Increase @registry_handle reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @registry_handle.
 */
iodefv2_registry_handle_t *iodefv2_registry_handle_ref(iodefv2_registry_handle_t *registry_handle)
{
        libiodefv2_return_val_if_fail(registry_handle, NULL);
        registry_handle->refcount++;

        return registry_handle;
}



int _iodefv2_registry_handle_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_registry_handle_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_REGISTRY_HANDLE_REGISTRY , ptr->registry);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_registry, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_registry_handle_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_registry_handle_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_registry_handle_new_registry(ptr, (iodefv2_registry_handle_registry_t **) ret);

                case 1:
                    return iodefv2_registry_handle_new_ext_registry(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_registry_handle_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_registry_handle_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->registry = 0;
                    return 0;




                case 1:
                        if ( ptr->ext_registry ) {
                                libiodefv2_string_destroy(ptr->ext_registry);
                                ptr->ext_registry = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_registry_handle_destroy_internal(iodefv2_registry_handle_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_registry ) {
                libiodefv2_string_destroy(ptr->ext_registry);
                ptr->ext_registry = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_registry_handle_destroy:
 * @ptr: pointer to a #iodefv2_registry_handle_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_registry_handle_destroy(iodefv2_registry_handle_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_registry_handle_destroy_internal(ptr);
        free(ptr);
}




/**
 * iodefv2_registry_handle_get_registry:
 * @ptr: pointer to a #iodefv2_registry_handle_t object.
 *
 * Get registry children of the #iodefv2_registry_handle_t object.
 *
 * Returns: a pointer to a iodefv2_registry_handle_registry_t object, or NULL if the children object is not set.
 */
iodefv2_registry_handle_registry_t iodefv2_registry_handle_get_registry(iodefv2_registry_handle_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->registry;

}


/**
 * iodefv2_registry_handle_set_registry:
 * @ptr: pointer to a #iodefv2_registry_handle_t object.
 * @registry: pointer to a #iodefv2_registry_handle_registry_t object.
 *
 * Set @registry object as a children of @ptr.
 * if @ptr already contain an @registry object, then it is destroyed,
 * and updated to point to the provided @registry object.
 */
void iodefv2_registry_handle_set_registry(iodefv2_registry_handle_t *ptr, iodefv2_registry_handle_registry_t registry)
{
        libiodefv2_return_if_fail(ptr);
        ptr->registry = registry;
}
/**
 * iodefv2_registry_handle_new_registry:
 * @ptr: pointer to a #iodefv2_registry_handle_t object.
 * @ret: pointer to an address where to store the created #iodefv2_registry_handle_registry_t object.
 *
 * Create a new registry object, children of #iodefv2_registry_handle_t.
 * If @ptr already contain a #iodefv2_registry_handle_registry_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_registry_handle_new_registry(iodefv2_registry_handle_t *ptr, iodefv2_registry_handle_registry_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->registry;
        return 0;
}




/**
 * iodefv2_registry_handle_get_ext_registry:
 * @ptr: pointer to a #iodefv2_registry_handle_t object.
 *
 * Get ext_registry children of the #iodefv2_registry_handle_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_registry_handle_get_ext_registry(iodefv2_registry_handle_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_registry;

}


/**
 * iodefv2_registry_handle_set_ext_registry:
 * @ptr: pointer to a #iodefv2_registry_handle_t object.
 * @ext_registry: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_registry object as a children of @ptr.
 * if @ptr already contain an @ext_registry object, then it is destroyed,
 * and updated to point to the provided @ext_registry object.
 */

void iodefv2_registry_handle_set_ext_registry(iodefv2_registry_handle_t *ptr, libiodefv2_string_t *ext_registry)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_registry )
                libiodefv2_string_destroy(ptr->ext_registry);

        ptr->ext_registry = ext_registry;
}
/**
 * iodefv2_registry_handle_new_ext_registry:
 * @ptr: pointer to a #iodefv2_registry_handle_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_registry object, children of #iodefv2_registry_handle_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_registry_handle_new_ext_registry(iodefv2_registry_handle_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_registry ) {
                retval = libiodefv2_string_new(&ptr->ext_registry);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_registry;
        return 0;
}



/**
 * iodefv2_registry_handle_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_registry_handle_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_registry_handle_copy(const iodefv2_registry_handle_t *src, iodefv2_registry_handle_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->registry = src->registry;



        if ( dst->ext_registry ) {
                libiodefv2_string_destroy(dst->ext_registry);
                dst->ext_registry = NULL;
        }

        if ( src->ext_registry ) {
                ret = libiodefv2_string_clone(src->ext_registry, &dst->ext_registry);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_registry_handle_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_registry_handle_clone(iodefv2_registry_handle_t *src, iodefv2_registry_handle_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_registry_handle_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_registry_handle_copy(src, *dst);
}


/**
 * iodefv2_registry_handle_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_registry_handle_compare(const iodefv2_registry_handle_t *obj1, const iodefv2_registry_handle_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->registry != obj2->registry )
                return -1;

        ret = libiodefv2_string_compare(obj1->ext_registry, obj2->ext_registry);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_time_impact_new:
 * @ret: Pointer where to store the created #iodefv2_time_impact_t object.
 *
 * Create a new #iodefv2_time_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_time_impact_new(iodefv2_time_impact_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_TIME_IMPACT;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;








            return 0;
}


/**
 * iodefv2_time_impact_ref:
 * @time_impact: pointer to a #iodefv2_time_impact_t object.
 *
 * Increase @time_impact reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @time_impact.
 */
iodefv2_time_impact_t *iodefv2_time_impact_ref(iodefv2_time_impact_t *time_impact)
{
        libiodefv2_return_val_if_fail(time_impact, NULL);
        time_impact->refcount++;

        return time_impact;
}



int _iodefv2_time_impact_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_time_impact_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_metric, TRUE);


            case 1:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_TIME_IMPACT_DURATION , ptr->duration);

            case 2:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_TIME_IMPACT_METRIC , ptr->metric);

            case 3:

                    if ( ! ptr->severity_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_TIME_IMPACT_SEVERITY , ptr->severity);


            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_duration, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_time_impact_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_time_impact_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_time_impact_new_ext_metric(ptr, (libiodefv2_string_t **) ret);

                case 1:
                    return iodefv2_time_impact_new_duration(ptr, (iodefv2_time_impact_duration_t **) ret);

                case 2:
                    return iodefv2_time_impact_new_metric(ptr, (iodefv2_time_impact_metric_t **) ret);

                case 3:
                    return iodefv2_time_impact_new_severity(ptr, (iodefv2_time_impact_severity_t **) ret);

                case 4:
                    return iodefv2_time_impact_new_ext_duration(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_time_impact_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_time_impact_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->ext_metric ) {
                                libiodefv2_string_destroy(ptr->ext_metric);
                                ptr->ext_metric = NULL;
                        }

                        return 0;




                case 1:
                    ptr->duration = 0;
                    return 0;




                case 2:
                    ptr->metric = 0;
                    return 0;

                case 3:
                        ptr->severity_is_set = 0;
                        return 0;




                case 4:
                        if ( ptr->ext_duration ) {
                                libiodefv2_string_destroy(ptr->ext_duration);
                                ptr->ext_duration = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_time_impact_destroy_internal(iodefv2_time_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->ext_metric ) {
                libiodefv2_string_destroy(ptr->ext_metric);
                ptr->ext_metric = NULL;
        }









        if ( ptr->ext_duration ) {
                libiodefv2_string_destroy(ptr->ext_duration);
                ptr->ext_duration = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_time_impact_destroy:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_time_impact_destroy(iodefv2_time_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_time_impact_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_time_impact_get_ext_metric:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 *
 * Get ext_metric children of the #iodefv2_time_impact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_time_impact_get_ext_metric(iodefv2_time_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_metric;

}


/**
 * iodefv2_time_impact_set_ext_metric:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 * @ext_metric: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_metric object as a children of @ptr.
 * if @ptr already contain an @ext_metric object, then it is destroyed,
 * and updated to point to the provided @ext_metric object.
 */

void iodefv2_time_impact_set_ext_metric(iodefv2_time_impact_t *ptr, libiodefv2_string_t *ext_metric)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_metric )
                libiodefv2_string_destroy(ptr->ext_metric);

        ptr->ext_metric = ext_metric;
}
/**
 * iodefv2_time_impact_new_ext_metric:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_metric object, children of #iodefv2_time_impact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_time_impact_new_ext_metric(iodefv2_time_impact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_metric ) {
                retval = libiodefv2_string_new(&ptr->ext_metric);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_metric;
        return 0;
}



/**
 * iodefv2_time_impact_get_duration:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 *
 * Get duration children of the #iodefv2_time_impact_t object.
 *
 * Returns: a pointer to a iodefv2_time_impact_duration_t object, or NULL if the children object is not set.
 */
iodefv2_time_impact_duration_t iodefv2_time_impact_get_duration(iodefv2_time_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->duration;

}


/**
 * iodefv2_time_impact_set_duration:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 * @duration: pointer to a #iodefv2_time_impact_duration_t object.
 *
 * Set @duration object as a children of @ptr.
 * if @ptr already contain an @duration object, then it is destroyed,
 * and updated to point to the provided @duration object.
 */
void iodefv2_time_impact_set_duration(iodefv2_time_impact_t *ptr, iodefv2_time_impact_duration_t duration)
{
        libiodefv2_return_if_fail(ptr);
        ptr->duration = duration;
}
/**
 * iodefv2_time_impact_new_duration:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_impact_duration_t object.
 *
 * Create a new duration object, children of #iodefv2_time_impact_t.
 * If @ptr already contain a #iodefv2_time_impact_duration_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_time_impact_new_duration(iodefv2_time_impact_t *ptr, iodefv2_time_impact_duration_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->duration;
        return 0;
}



/**
 * iodefv2_time_impact_get_metric:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 *
 * Get metric children of the #iodefv2_time_impact_t object.
 *
 * Returns: a pointer to a iodefv2_time_impact_metric_t object, or NULL if the children object is not set.
 */
iodefv2_time_impact_metric_t iodefv2_time_impact_get_metric(iodefv2_time_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->metric;

}


/**
 * iodefv2_time_impact_set_metric:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 * @metric: pointer to a #iodefv2_time_impact_metric_t object.
 *
 * Set @metric object as a children of @ptr.
 * if @ptr already contain an @metric object, then it is destroyed,
 * and updated to point to the provided @metric object.
 */
void iodefv2_time_impact_set_metric(iodefv2_time_impact_t *ptr, iodefv2_time_impact_metric_t metric)
{
        libiodefv2_return_if_fail(ptr);
        ptr->metric = metric;
}
/**
 * iodefv2_time_impact_new_metric:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_impact_metric_t object.
 *
 * Create a new metric object, children of #iodefv2_time_impact_t.
 * If @ptr already contain a #iodefv2_time_impact_metric_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_time_impact_new_metric(iodefv2_time_impact_t *ptr, iodefv2_time_impact_metric_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->metric;
        return 0;
}




/**
 * iodefv2_time_impact_get_severity:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 *
 * Get severity children of the #iodefv2_time_impact_t object.
 *
 * Returns: a pointer to a iodefv2_time_impact_severity_t object, or NULL if the children object is not set.
 */
iodefv2_time_impact_severity_t *iodefv2_time_impact_get_severity(iodefv2_time_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->severity_is_set ? &ptr->severity : NULL;


}


/**
 * iodefv2_time_impact_set_severity:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 * @severity: pointer to a #iodefv2_time_impact_severity_t object.
 *
 * Set @severity object as a children of @ptr.
 * if @ptr already contain an @severity object, then it is destroyed,
 * and updated to point to the provided @severity object.
 */
void iodefv2_time_impact_set_severity(iodefv2_time_impact_t *ptr, iodefv2_time_impact_severity_t severity)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity = severity;
        ptr->severity_is_set = 1;
}

void iodefv2_time_impact_unset_severity(iodefv2_time_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity_is_set = 0;
}
/**
 * iodefv2_time_impact_new_severity:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_impact_severity_t object.
 *
 * Create a new severity object, children of #iodefv2_time_impact_t.
 * If @ptr already contain a #iodefv2_time_impact_severity_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_time_impact_new_severity(iodefv2_time_impact_t *ptr, iodefv2_time_impact_severity_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->severity_is_set = 1;



        *ret = &ptr->severity;
        return 0;
}




/**
 * iodefv2_time_impact_get_ext_duration:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 *
 * Get ext_duration children of the #iodefv2_time_impact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_time_impact_get_ext_duration(iodefv2_time_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_duration;

}


/**
 * iodefv2_time_impact_set_ext_duration:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 * @ext_duration: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_duration object as a children of @ptr.
 * if @ptr already contain an @ext_duration object, then it is destroyed,
 * and updated to point to the provided @ext_duration object.
 */

void iodefv2_time_impact_set_ext_duration(iodefv2_time_impact_t *ptr, libiodefv2_string_t *ext_duration)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_duration )
                libiodefv2_string_destroy(ptr->ext_duration);

        ptr->ext_duration = ext_duration;
}
/**
 * iodefv2_time_impact_new_ext_duration:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_duration object, children of #iodefv2_time_impact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_time_impact_new_ext_duration(iodefv2_time_impact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_duration ) {
                retval = libiodefv2_string_new(&ptr->ext_duration);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_duration;
        return 0;
}



/**
 * iodefv2_time_impact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_time_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_time_impact_copy(const iodefv2_time_impact_t *src, iodefv2_time_impact_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->ext_metric ) {
                libiodefv2_string_destroy(dst->ext_metric);
                dst->ext_metric = NULL;
        }

        if ( src->ext_metric ) {
                ret = libiodefv2_string_clone(src->ext_metric, &dst->ext_metric);
                if ( ret < 0 )
                        return ret;
        }




        dst->duration = src->duration;



        dst->metric = src->metric;



        dst->severity_is_set = src->severity_is_set;
        dst->severity = src->severity;



        if ( dst->ext_duration ) {
                libiodefv2_string_destroy(dst->ext_duration);
                dst->ext_duration = NULL;
        }

        if ( src->ext_duration ) {
                ret = libiodefv2_string_clone(src->ext_duration, &dst->ext_duration);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_time_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_time_impact_clone(iodefv2_time_impact_t *src, iodefv2_time_impact_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_time_impact_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_time_impact_copy(src, *dst);
}


/**
 * iodefv2_time_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_time_impact_compare(const iodefv2_time_impact_t *obj1, const iodefv2_time_impact_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->ext_metric, obj2->ext_metric);
        if ( ret != 0 )
                return ret;


        if ( obj1->duration != obj2->duration )
                return -1;


        if ( obj1->metric != obj2->metric )
                return -1;


        if ( obj1->severity_is_set != obj2->severity_is_set )
                return -1;

        if ( obj1->severity_is_set && obj1->severity != obj2->severity )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_duration, obj2->ext_duration);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_record_pattern_new:
 * @ret: Pointer where to store the created #iodefv2_record_pattern_t object.
 *
 * Create a new #iodefv2_record_pattern_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_record_pattern_new(iodefv2_record_pattern_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_RECORD_PATTERN;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;








            return 0;
}


/**
 * iodefv2_record_pattern_ref:
 * @record_pattern: pointer to a #iodefv2_record_pattern_t object.
 *
 * Increase @record_pattern reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @record_pattern.
 */
iodefv2_record_pattern_t *iodefv2_record_pattern_ref(iodefv2_record_pattern_t *record_pattern)
{
        libiodefv2_return_val_if_fail(record_pattern, NULL);
        record_pattern->refcount++;

        return record_pattern;
}



int _iodefv2_record_pattern_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_record_pattern_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:
                         return (ptr->instance_is_set) ? iodefv2_value_new_uint32((iodefv2_value_t **) childptr, ptr->instance) : 0;


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_type, TRUE);


            case 2:
                         return (ptr->offset_is_set) ? iodefv2_value_new_uint32((iodefv2_value_t **) childptr, ptr->offset) : 0;

            case 3:

                    if ( ! ptr->offsetunit_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_RECORD_PATTERN_OFFSETUNIT , ptr->offsetunit);


            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_offsetunit, TRUE);


            case 5:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_RECORD_PATTERN_TYPE , ptr->type);

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_record_pattern_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_record_pattern_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_record_pattern_new_instance(ptr, (uint32_t **) ret);

                case 1:
                    return iodefv2_record_pattern_new_ext_type(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_record_pattern_new_offset(ptr, (uint32_t **) ret);

                case 3:
                    return iodefv2_record_pattern_new_offsetunit(ptr, (iodefv2_record_pattern_offsetunit_t **) ret);

                case 4:
                    return iodefv2_record_pattern_new_ext_offsetunit(ptr, (libiodefv2_string_t **) ret);

                case 5:
                    return iodefv2_record_pattern_new_type(ptr, (iodefv2_record_pattern_type_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_record_pattern_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_record_pattern_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->instance_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_type ) {
                                libiodefv2_string_destroy(ptr->ext_type);
                                ptr->ext_type = NULL;
                        }

                        return 0;

                case 2:
                        ptr->offset_is_set = 0;
                        return 0;

                case 3:
                        ptr->offsetunit_is_set = 0;
                        return 0;




                case 4:
                        if ( ptr->ext_offsetunit ) {
                                libiodefv2_string_destroy(ptr->ext_offsetunit);
                                ptr->ext_offsetunit = NULL;
                        }

                        return 0;




                case 5:
                    ptr->type = 0;
                    return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_record_pattern_destroy_internal(iodefv2_record_pattern_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_type ) {
                libiodefv2_string_destroy(ptr->ext_type);
                ptr->ext_type = NULL;
        }







        if ( ptr->ext_offsetunit ) {
                libiodefv2_string_destroy(ptr->ext_offsetunit);
                ptr->ext_offsetunit = NULL;
        }




        /* free() should be done by the caller */
}


/**
 * iodefv2_record_pattern_destroy:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_record_pattern_destroy(iodefv2_record_pattern_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_record_pattern_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_record_pattern_get_instance:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 *
 * Get instance children of the #iodefv2_record_pattern_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *iodefv2_record_pattern_get_instance(iodefv2_record_pattern_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->instance_is_set ? &ptr->instance : NULL;


}


/**
 * iodefv2_record_pattern_set_instance:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 * @instance: pointer to a #uint32_t object.
 *
 * Set @instance object as a children of @ptr.
 * if @ptr already contain an @instance object, then it is destroyed,
 * and updated to point to the provided @instance object.
 */
void iodefv2_record_pattern_set_instance(iodefv2_record_pattern_t *ptr, uint32_t instance)
{
        libiodefv2_return_if_fail(ptr);
        ptr->instance = instance;
        ptr->instance_is_set = 1;
}

void iodefv2_record_pattern_unset_instance(iodefv2_record_pattern_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->instance_is_set = 0;
}
/**
 * iodefv2_record_pattern_new_instance:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new instance object, children of #iodefv2_record_pattern_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_pattern_new_instance(iodefv2_record_pattern_t *ptr, uint32_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->instance_is_set = 1;



        *ret = &ptr->instance;
        return 0;
}




/**
 * iodefv2_record_pattern_get_ext_type:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 *
 * Get ext_type children of the #iodefv2_record_pattern_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_record_pattern_get_ext_type(iodefv2_record_pattern_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_type;

}


/**
 * iodefv2_record_pattern_set_ext_type:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 * @ext_type: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_type object as a children of @ptr.
 * if @ptr already contain an @ext_type object, then it is destroyed,
 * and updated to point to the provided @ext_type object.
 */

void iodefv2_record_pattern_set_ext_type(iodefv2_record_pattern_t *ptr, libiodefv2_string_t *ext_type)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_type )
                libiodefv2_string_destroy(ptr->ext_type);

        ptr->ext_type = ext_type;
}
/**
 * iodefv2_record_pattern_new_ext_type:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_type object, children of #iodefv2_record_pattern_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_pattern_new_ext_type(iodefv2_record_pattern_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_type ) {
                retval = libiodefv2_string_new(&ptr->ext_type);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_type;
        return 0;
}




/**
 * iodefv2_record_pattern_get_offset:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 *
 * Get offset children of the #iodefv2_record_pattern_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *iodefv2_record_pattern_get_offset(iodefv2_record_pattern_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->offset_is_set ? &ptr->offset : NULL;


}


/**
 * iodefv2_record_pattern_set_offset:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 * @offset: pointer to a #uint32_t object.
 *
 * Set @offset object as a children of @ptr.
 * if @ptr already contain an @offset object, then it is destroyed,
 * and updated to point to the provided @offset object.
 */
void iodefv2_record_pattern_set_offset(iodefv2_record_pattern_t *ptr, uint32_t offset)
{
        libiodefv2_return_if_fail(ptr);
        ptr->offset = offset;
        ptr->offset_is_set = 1;
}

void iodefv2_record_pattern_unset_offset(iodefv2_record_pattern_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->offset_is_set = 0;
}
/**
 * iodefv2_record_pattern_new_offset:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new offset object, children of #iodefv2_record_pattern_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_pattern_new_offset(iodefv2_record_pattern_t *ptr, uint32_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->offset_is_set = 1;



        *ret = &ptr->offset;
        return 0;
}




/**
 * iodefv2_record_pattern_get_offsetunit:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 *
 * Get offsetunit children of the #iodefv2_record_pattern_t object.
 *
 * Returns: a pointer to a iodefv2_record_pattern_offsetunit_t object, or NULL if the children object is not set.
 */
iodefv2_record_pattern_offsetunit_t *iodefv2_record_pattern_get_offsetunit(iodefv2_record_pattern_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->offsetunit_is_set ? &ptr->offsetunit : NULL;


}


/**
 * iodefv2_record_pattern_set_offsetunit:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 * @offsetunit: pointer to a #iodefv2_record_pattern_offsetunit_t object.
 *
 * Set @offsetunit object as a children of @ptr.
 * if @ptr already contain an @offsetunit object, then it is destroyed,
 * and updated to point to the provided @offsetunit object.
 */
void iodefv2_record_pattern_set_offsetunit(iodefv2_record_pattern_t *ptr, iodefv2_record_pattern_offsetunit_t offsetunit)
{
        libiodefv2_return_if_fail(ptr);
        ptr->offsetunit = offsetunit;
        ptr->offsetunit_is_set = 1;
}

void iodefv2_record_pattern_unset_offsetunit(iodefv2_record_pattern_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->offsetunit_is_set = 0;
}
/**
 * iodefv2_record_pattern_new_offsetunit:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 * @ret: pointer to an address where to store the created #iodefv2_record_pattern_offsetunit_t object.
 *
 * Create a new offsetunit object, children of #iodefv2_record_pattern_t.
 * If @ptr already contain a #iodefv2_record_pattern_offsetunit_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_pattern_new_offsetunit(iodefv2_record_pattern_t *ptr, iodefv2_record_pattern_offsetunit_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->offsetunit_is_set = 1;



        *ret = &ptr->offsetunit;
        return 0;
}




/**
 * iodefv2_record_pattern_get_ext_offsetunit:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 *
 * Get ext_offsetunit children of the #iodefv2_record_pattern_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_record_pattern_get_ext_offsetunit(iodefv2_record_pattern_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_offsetunit;

}


/**
 * iodefv2_record_pattern_set_ext_offsetunit:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 * @ext_offsetunit: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_offsetunit object as a children of @ptr.
 * if @ptr already contain an @ext_offsetunit object, then it is destroyed,
 * and updated to point to the provided @ext_offsetunit object.
 */

void iodefv2_record_pattern_set_ext_offsetunit(iodefv2_record_pattern_t *ptr, libiodefv2_string_t *ext_offsetunit)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_offsetunit )
                libiodefv2_string_destroy(ptr->ext_offsetunit);

        ptr->ext_offsetunit = ext_offsetunit;
}
/**
 * iodefv2_record_pattern_new_ext_offsetunit:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_offsetunit object, children of #iodefv2_record_pattern_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_pattern_new_ext_offsetunit(iodefv2_record_pattern_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_offsetunit ) {
                retval = libiodefv2_string_new(&ptr->ext_offsetunit);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_offsetunit;
        return 0;
}



/**
 * iodefv2_record_pattern_get_type:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 *
 * Get type children of the #iodefv2_record_pattern_t object.
 *
 * Returns: a pointer to a iodefv2_record_pattern_type_t object, or NULL if the children object is not set.
 */
iodefv2_record_pattern_type_t iodefv2_record_pattern_get_type(iodefv2_record_pattern_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type;

}


/**
 * iodefv2_record_pattern_set_type:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 * @type: pointer to a #iodefv2_record_pattern_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */
void iodefv2_record_pattern_set_type(iodefv2_record_pattern_t *ptr, iodefv2_record_pattern_type_t type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type = type;
}
/**
 * iodefv2_record_pattern_new_type:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 * @ret: pointer to an address where to store the created #iodefv2_record_pattern_type_t object.
 *
 * Create a new type object, children of #iodefv2_record_pattern_t.
 * If @ptr already contain a #iodefv2_record_pattern_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_pattern_new_type(iodefv2_record_pattern_t *ptr, iodefv2_record_pattern_type_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->type;
        return 0;
}



/**
 * iodefv2_record_pattern_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_record_pattern_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_record_pattern_copy(const iodefv2_record_pattern_t *src, iodefv2_record_pattern_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;


        dst->instance_is_set = src->instance_is_set;
        dst->instance = src->instance;



        if ( dst->ext_type ) {
                libiodefv2_string_destroy(dst->ext_type);
                dst->ext_type = NULL;
        }

        if ( src->ext_type ) {
                ret = libiodefv2_string_clone(src->ext_type, &dst->ext_type);
                if ( ret < 0 )
                        return ret;
        }



        dst->offset_is_set = src->offset_is_set;
        dst->offset = src->offset;



        dst->offsetunit_is_set = src->offsetunit_is_set;
        dst->offsetunit = src->offsetunit;



        if ( dst->ext_offsetunit ) {
                libiodefv2_string_destroy(dst->ext_offsetunit);
                dst->ext_offsetunit = NULL;
        }

        if ( src->ext_offsetunit ) {
                ret = libiodefv2_string_clone(src->ext_offsetunit, &dst->ext_offsetunit);
                if ( ret < 0 )
                        return ret;
        }




        dst->type = src->type;
    return 0 ;
}


/**
 * iodefv2_record_pattern_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_record_pattern_clone(iodefv2_record_pattern_t *src, iodefv2_record_pattern_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_record_pattern_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_record_pattern_copy(src, *dst);
}


/**
 * iodefv2_record_pattern_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_record_pattern_compare(const iodefv2_record_pattern_t *obj1, const iodefv2_record_pattern_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        if ( obj1->instance_is_set != obj2->instance_is_set )
                return -1;

        if ( obj1->instance_is_set && obj1->instance != obj2->instance )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_type, obj2->ext_type);
        if ( ret != 0 )
                return ret;

        if ( obj1->offset_is_set != obj2->offset_is_set )
                return -1;

        if ( obj1->offset_is_set && obj1->offset != obj2->offset )
                return -1;



        if ( obj1->offsetunit_is_set != obj2->offsetunit_is_set )
                return -1;

        if ( obj1->offsetunit_is_set && obj1->offsetunit != obj2->offsetunit )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_offsetunit, obj2->ext_offsetunit);
        if ( ret != 0 )
                return ret;


        if ( obj1->type != obj2->type )
                return -1;
        return ret;
}


        



/**
 * iodefv2_reference_new:
 * @ret: Pointer where to store the created #iodefv2_reference_t object.
 *
 * Create a new #iodefv2_reference_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_reference_new(iodefv2_reference_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_REFERENCE;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;




            return 0;
}


/**
 * iodefv2_reference_ref:
 * @reference: pointer to a #iodefv2_reference_t object.
 *
 * Increase @reference reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @reference.
 */
iodefv2_reference_t *iodefv2_reference_ref(iodefv2_reference_t *reference)
{
        libiodefv2_return_val_if_fail(reference, NULL);
        reference->refcount++;

        return reference;
}



int _iodefv2_reference_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_reference_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);



            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->url, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);



            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->reference_name, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_reference_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_reference_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_reference_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 1:
                    return iodefv2_reference_new_url(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_reference_new_description(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_reference_new_reference_name(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_reference_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_reference_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->url ) {
                                libiodefv2_string_destroy(ptr->url);
                                ptr->url = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->reference_name ) {
                                libiodefv2_string_destroy(ptr->reference_name);
                                ptr->reference_name = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_reference_destroy_internal(iodefv2_reference_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }



        if ( ptr->url ) {
                libiodefv2_string_destroy(ptr->url);
                ptr->url = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }



        if ( ptr->reference_name ) {
                libiodefv2_string_destroy(ptr->reference_name);
                ptr->reference_name = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_reference_destroy:
 * @ptr: pointer to a #iodefv2_reference_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_reference_destroy(iodefv2_reference_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_reference_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_reference_get_observable_id:
 * @ptr: pointer to a #iodefv2_reference_t object.
 *
 * Get observable_id children of the #iodefv2_reference_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_reference_get_observable_id(iodefv2_reference_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_reference_set_observable_id:
 * @ptr: pointer to a #iodefv2_reference_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_reference_set_observable_id(iodefv2_reference_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_reference_new_observable_id:
 * @ptr: pointer to a #iodefv2_reference_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_reference_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_reference_new_observable_id(iodefv2_reference_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}




/**
 * iodefv2_reference_get_url:
 * @ptr: pointer to a #iodefv2_reference_t object.
 *
 * Get url children of the #iodefv2_reference_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_reference_get_url(iodefv2_reference_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->url;

}


/**
 * iodefv2_reference_set_url:
 * @ptr: pointer to a #iodefv2_reference_t object.
 * @url: pointer to a #libiodefv2_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void iodefv2_reference_set_url(iodefv2_reference_t *ptr, libiodefv2_string_t *url)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->url )
                libiodefv2_string_destroy(ptr->url);

        ptr->url = url;
}
/**
 * iodefv2_reference_new_url:
 * @ptr: pointer to a #iodefv2_reference_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new url object, children of #iodefv2_reference_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_reference_new_url(iodefv2_reference_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->url ) {
                retval = libiodefv2_string_new(&ptr->url);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->url;
        return 0;
}




/**
 * iodefv2_reference_get_description:
 * @ptr: pointer to a #iodefv2_reference_t object.
 *
 * Get description children of the #iodefv2_reference_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_reference_get_description(iodefv2_reference_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_reference_set_description:
 * @ptr: pointer to a #iodefv2_reference_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_reference_set_description(iodefv2_reference_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_reference_new_description:
 * @ptr: pointer to a #iodefv2_reference_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_reference_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_reference_new_description(iodefv2_reference_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}




/**
 * iodefv2_reference_get_reference_name:
 * @ptr: pointer to a #iodefv2_reference_t object.
 *
 * Get reference_name children of the #iodefv2_reference_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_reference_get_reference_name(iodefv2_reference_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->reference_name;

}


/**
 * iodefv2_reference_set_reference_name:
 * @ptr: pointer to a #iodefv2_reference_t object.
 * @reference_name: pointer to a #libiodefv2_string_t object.
 *
 * Set @reference_name object as a children of @ptr.
 * if @ptr already contain an @reference_name object, then it is destroyed,
 * and updated to point to the provided @reference_name object.
 */

void iodefv2_reference_set_reference_name(iodefv2_reference_t *ptr, libiodefv2_string_t *reference_name)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->reference_name )
                libiodefv2_string_destroy(ptr->reference_name);

        ptr->reference_name = reference_name;
}
/**
 * iodefv2_reference_new_reference_name:
 * @ptr: pointer to a #iodefv2_reference_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new reference_name object, children of #iodefv2_reference_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_reference_new_reference_name(iodefv2_reference_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->reference_name ) {
                retval = libiodefv2_string_new(&ptr->reference_name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->reference_name;
        return 0;
}



/**
 * iodefv2_reference_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_reference_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_reference_copy(const iodefv2_reference_t *src, iodefv2_reference_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->url ) {
                libiodefv2_string_destroy(dst->url);
                dst->url = NULL;
        }

        if ( src->url ) {
                ret = libiodefv2_string_clone(src->url, &dst->url);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->reference_name ) {
                libiodefv2_string_destroy(dst->reference_name);
                dst->reference_name = NULL;
        }

        if ( src->reference_name ) {
                ret = libiodefv2_string_clone(src->reference_name, &dst->reference_name);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_reference_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_reference_clone(iodefv2_reference_t *src, iodefv2_reference_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_reference_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_reference_copy(src, *dst);
}


/**
 * iodefv2_reference_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_reference_compare(const iodefv2_reference_t *obj1, const iodefv2_reference_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->url, obj2->url);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->reference_name, obj2->reference_name);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_postal_address_new:
 * @ret: Pointer where to store the created #iodefv2_postal_address_t object.
 *
 * Create a new #iodefv2_postal_address_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_postal_address_new(iodefv2_postal_address_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_POSTAL_ADDRESS;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;




        {
            int retval = libiodefv2_string_new(&(*ret)->p_address);

            if ( retval < 0 ) {
                    iodefv2_postal_address_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

            return 0;
}


/**
 * iodefv2_postal_address_ref:
 * @postal_address: pointer to a #iodefv2_postal_address_t object.
 *
 * Increase @postal_address reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @postal_address.
 */
iodefv2_postal_address_t *iodefv2_postal_address_ref(iodefv2_postal_address_t *postal_address)
{
        libiodefv2_return_val_if_fail(postal_address, NULL);
        postal_address->refcount++;

        return postal_address;
}



int _iodefv2_postal_address_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_postal_address_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->type_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_POSTAL_ADDRESS_TYPE , ptr->type);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_type, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->p_address, TRUE);



            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_postal_address_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_postal_address_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_postal_address_new_type(ptr, (iodefv2_postal_address_type_t **) ret);

                case 1:
                    return iodefv2_postal_address_new_ext_type(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_postal_address_new_p_address(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_postal_address_new_description(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_postal_address_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_postal_address_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->type_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_type ) {
                                libiodefv2_string_destroy(ptr->ext_type);
                                ptr->ext_type = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->p_address ) {
                                libiodefv2_string_destroy(ptr->p_address);
                                ptr->p_address = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_postal_address_destroy_internal(iodefv2_postal_address_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_type ) {
                libiodefv2_string_destroy(ptr->ext_type);
                ptr->ext_type = NULL;
        }



        if ( ptr->p_address ) {
                libiodefv2_string_destroy(ptr->p_address);
                ptr->p_address = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_postal_address_destroy:
 * @ptr: pointer to a #iodefv2_postal_address_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_postal_address_destroy(iodefv2_postal_address_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_postal_address_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_postal_address_get_type:
 * @ptr: pointer to a #iodefv2_postal_address_t object.
 *
 * Get type children of the #iodefv2_postal_address_t object.
 *
 * Returns: a pointer to a iodefv2_postal_address_type_t object, or NULL if the children object is not set.
 */
iodefv2_postal_address_type_t *iodefv2_postal_address_get_type(iodefv2_postal_address_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type_is_set ? &ptr->type : NULL;


}


/**
 * iodefv2_postal_address_set_type:
 * @ptr: pointer to a #iodefv2_postal_address_t object.
 * @type: pointer to a #iodefv2_postal_address_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */
void iodefv2_postal_address_set_type(iodefv2_postal_address_t *ptr, iodefv2_postal_address_type_t type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type = type;
        ptr->type_is_set = 1;
}

void iodefv2_postal_address_unset_type(iodefv2_postal_address_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type_is_set = 0;
}
/**
 * iodefv2_postal_address_new_type:
 * @ptr: pointer to a #iodefv2_postal_address_t object.
 * @ret: pointer to an address where to store the created #iodefv2_postal_address_type_t object.
 *
 * Create a new type object, children of #iodefv2_postal_address_t.
 * If @ptr already contain a #iodefv2_postal_address_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_postal_address_new_type(iodefv2_postal_address_t *ptr, iodefv2_postal_address_type_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->type_is_set = 1;



        *ret = &ptr->type;
        return 0;
}




/**
 * iodefv2_postal_address_get_ext_type:
 * @ptr: pointer to a #iodefv2_postal_address_t object.
 *
 * Get ext_type children of the #iodefv2_postal_address_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_postal_address_get_ext_type(iodefv2_postal_address_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_type;

}


/**
 * iodefv2_postal_address_set_ext_type:
 * @ptr: pointer to a #iodefv2_postal_address_t object.
 * @ext_type: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_type object as a children of @ptr.
 * if @ptr already contain an @ext_type object, then it is destroyed,
 * and updated to point to the provided @ext_type object.
 */

void iodefv2_postal_address_set_ext_type(iodefv2_postal_address_t *ptr, libiodefv2_string_t *ext_type)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_type )
                libiodefv2_string_destroy(ptr->ext_type);

        ptr->ext_type = ext_type;
}
/**
 * iodefv2_postal_address_new_ext_type:
 * @ptr: pointer to a #iodefv2_postal_address_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_type object, children of #iodefv2_postal_address_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_postal_address_new_ext_type(iodefv2_postal_address_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_type ) {
                retval = libiodefv2_string_new(&ptr->ext_type);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_type;
        return 0;
}




/**
 * iodefv2_postal_address_get_p_address:
 * @ptr: pointer to a #iodefv2_postal_address_t object.
 *
 * Get p_address children of the #iodefv2_postal_address_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_postal_address_get_p_address(iodefv2_postal_address_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->p_address;

}


/**
 * iodefv2_postal_address_set_p_address:
 * @ptr: pointer to a #iodefv2_postal_address_t object.
 * @p_address: pointer to a #libiodefv2_string_t object.
 *
 * Set @p_address object as a children of @ptr.
 * if @ptr already contain an @p_address object, then it is destroyed,
 * and updated to point to the provided @p_address object.
 */

void iodefv2_postal_address_set_p_address(iodefv2_postal_address_t *ptr, libiodefv2_string_t *p_address)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->p_address )
                libiodefv2_string_destroy(ptr->p_address);

        ptr->p_address = p_address;
}
/**
 * iodefv2_postal_address_new_p_address:
 * @ptr: pointer to a #iodefv2_postal_address_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new p_address object, children of #iodefv2_postal_address_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_postal_address_new_p_address(iodefv2_postal_address_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->p_address ) {
                retval = libiodefv2_string_new(&ptr->p_address);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->p_address;
        return 0;
}




/**
 * iodefv2_postal_address_get_description:
 * @ptr: pointer to a #iodefv2_postal_address_t object.
 *
 * Get description children of the #iodefv2_postal_address_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_postal_address_get_description(iodefv2_postal_address_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_postal_address_set_description:
 * @ptr: pointer to a #iodefv2_postal_address_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_postal_address_set_description(iodefv2_postal_address_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_postal_address_new_description:
 * @ptr: pointer to a #iodefv2_postal_address_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_postal_address_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_postal_address_new_description(iodefv2_postal_address_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}



/**
 * iodefv2_postal_address_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_postal_address_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_postal_address_copy(const iodefv2_postal_address_t *src, iodefv2_postal_address_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->type_is_set = src->type_is_set;
        dst->type = src->type;



        if ( dst->ext_type ) {
                libiodefv2_string_destroy(dst->ext_type);
                dst->ext_type = NULL;
        }

        if ( src->ext_type ) {
                ret = libiodefv2_string_clone(src->ext_type, &dst->ext_type);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->p_address ) {
                ret = libiodefv2_string_copy(src->p_address, dst->p_address);
                if ( ret < 0 )
                        return ret;
        }



        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_postal_address_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_postal_address_clone(iodefv2_postal_address_t *src, iodefv2_postal_address_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_postal_address_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_postal_address_copy(src, *dst);
}


/**
 * iodefv2_postal_address_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_postal_address_compare(const iodefv2_postal_address_t *obj1, const iodefv2_postal_address_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->type_is_set != obj2->type_is_set )
                return -1;

        if ( obj1->type_is_set && obj1->type != obj2->type )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_type, obj2->ext_type);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->p_address, obj2->p_address);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_node_role_new:
 * @ret: Pointer where to store the created #iodefv2_node_role_t object.
 *
 * Create a new #iodefv2_node_role_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_node_role_new(iodefv2_node_role_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_NODE_ROLE;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;




            return 0;
}


/**
 * iodefv2_node_role_ref:
 * @node_role: pointer to a #iodefv2_node_role_t object.
 *
 * Increase @node_role reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @node_role.
 */
iodefv2_node_role_t *iodefv2_node_role_ref(iodefv2_node_role_t *node_role)
{
        libiodefv2_return_val_if_fail(node_role, NULL);
        node_role->refcount++;

        return node_role;
}



int _iodefv2_node_role_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_node_role_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_NODE_ROLE_CATEGORY , ptr->category);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_category, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_node_role_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_node_role_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_node_role_new_category(ptr, (iodefv2_node_role_category_t **) ret);

                case 1:
                    return iodefv2_node_role_new_ext_category(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_node_role_new_description(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_node_role_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_node_role_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->category = 0;
                    return 0;




                case 1:
                        if ( ptr->ext_category ) {
                                libiodefv2_string_destroy(ptr->ext_category);
                                ptr->ext_category = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_node_role_destroy_internal(iodefv2_node_role_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_category ) {
                libiodefv2_string_destroy(ptr->ext_category);
                ptr->ext_category = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_node_role_destroy:
 * @ptr: pointer to a #iodefv2_node_role_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_node_role_destroy(iodefv2_node_role_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_node_role_destroy_internal(ptr);
        free(ptr);
}




/**
 * iodefv2_node_role_get_category:
 * @ptr: pointer to a #iodefv2_node_role_t object.
 *
 * Get category children of the #iodefv2_node_role_t object.
 *
 * Returns: a pointer to a iodefv2_node_role_category_t object, or NULL if the children object is not set.
 */
iodefv2_node_role_category_t iodefv2_node_role_get_category(iodefv2_node_role_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->category;

}


/**
 * iodefv2_node_role_set_category:
 * @ptr: pointer to a #iodefv2_node_role_t object.
 * @category: pointer to a #iodefv2_node_role_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */
void iodefv2_node_role_set_category(iodefv2_node_role_t *ptr, iodefv2_node_role_category_t category)
{
        libiodefv2_return_if_fail(ptr);
        ptr->category = category;
}
/**
 * iodefv2_node_role_new_category:
 * @ptr: pointer to a #iodefv2_node_role_t object.
 * @ret: pointer to an address where to store the created #iodefv2_node_role_category_t object.
 *
 * Create a new category object, children of #iodefv2_node_role_t.
 * If @ptr already contain a #iodefv2_node_role_category_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_node_role_new_category(iodefv2_node_role_t *ptr, iodefv2_node_role_category_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->category;
        return 0;
}




/**
 * iodefv2_node_role_get_ext_category:
 * @ptr: pointer to a #iodefv2_node_role_t object.
 *
 * Get ext_category children of the #iodefv2_node_role_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_node_role_get_ext_category(iodefv2_node_role_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_category;

}


/**
 * iodefv2_node_role_set_ext_category:
 * @ptr: pointer to a #iodefv2_node_role_t object.
 * @ext_category: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_category object as a children of @ptr.
 * if @ptr already contain an @ext_category object, then it is destroyed,
 * and updated to point to the provided @ext_category object.
 */

void iodefv2_node_role_set_ext_category(iodefv2_node_role_t *ptr, libiodefv2_string_t *ext_category)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_category )
                libiodefv2_string_destroy(ptr->ext_category);

        ptr->ext_category = ext_category;
}
/**
 * iodefv2_node_role_new_ext_category:
 * @ptr: pointer to a #iodefv2_node_role_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_category object, children of #iodefv2_node_role_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_node_role_new_ext_category(iodefv2_node_role_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_category ) {
                retval = libiodefv2_string_new(&ptr->ext_category);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_category;
        return 0;
}




/**
 * iodefv2_node_role_get_description:
 * @ptr: pointer to a #iodefv2_node_role_t object.
 *
 * Get description children of the #iodefv2_node_role_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_node_role_get_description(iodefv2_node_role_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_node_role_set_description:
 * @ptr: pointer to a #iodefv2_node_role_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_node_role_set_description(iodefv2_node_role_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_node_role_new_description:
 * @ptr: pointer to a #iodefv2_node_role_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_node_role_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_node_role_new_description(iodefv2_node_role_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}



/**
 * iodefv2_node_role_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_node_role_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_node_role_copy(const iodefv2_node_role_t *src, iodefv2_node_role_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->category = src->category;



        if ( dst->ext_category ) {
                libiodefv2_string_destroy(dst->ext_category);
                dst->ext_category = NULL;
        }

        if ( src->ext_category ) {
                ret = libiodefv2_string_clone(src->ext_category, &dst->ext_category);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_node_role_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_node_role_clone(iodefv2_node_role_t *src, iodefv2_node_role_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_node_role_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_node_role_copy(src, *dst);
}


/**
 * iodefv2_node_role_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_node_role_compare(const iodefv2_node_role_t *obj1, const iodefv2_node_role_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->category != obj2->category )
                return -1;

        ret = libiodefv2_string_compare(obj1->ext_category, obj2->ext_category);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_incident_id_new:
 * @ret: Pointer where to store the created #iodefv2_incident_id_t object.
 *
 * Create a new #iodefv2_incident_id_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_incident_id_new(iodefv2_incident_id_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_INCIDENT_ID;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;



        {
            int retval = libiodefv2_string_new(&(*ret)->name);

            if ( retval < 0 ) {
                    iodefv2_incident_id_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }


            return 0;
}


/**
 * iodefv2_incident_id_ref:
 * @incident_id: pointer to a #iodefv2_incident_id_t object.
 *
 * Increase @incident_id reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @incident_id.
 */
iodefv2_incident_id_t *iodefv2_incident_id_ref(iodefv2_incident_id_t *incident_id)
{
        libiodefv2_return_val_if_fail(incident_id, NULL);
        incident_id->refcount++;

        return incident_id;
}



int _iodefv2_incident_id_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_incident_id_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->instance, TRUE);



            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->name, TRUE);


            case 3:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_INCIDENT_ID_RESTRICTION , ptr->restriction);

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_incident_id_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_incident_id_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_incident_id_new_instance(ptr, (libiodefv2_string_t **) ret);

                case 1:
                    return iodefv2_incident_id_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_incident_id_new_name(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_incident_id_new_restriction(ptr, (iodefv2_incident_id_restriction_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_incident_id_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_incident_id_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->instance ) {
                                libiodefv2_string_destroy(ptr->instance);
                                ptr->instance = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->name ) {
                                libiodefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;

                case 3:
                        ptr->restriction_is_set = 0;
                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_incident_id_destroy_internal(iodefv2_incident_id_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->instance ) {
                libiodefv2_string_destroy(ptr->instance);
                ptr->instance = NULL;
        }



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }



        if ( ptr->name ) {
                libiodefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }




        /* free() should be done by the caller */
}


/**
 * iodefv2_incident_id_destroy:
 * @ptr: pointer to a #iodefv2_incident_id_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_incident_id_destroy(iodefv2_incident_id_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_incident_id_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_incident_id_get_instance:
 * @ptr: pointer to a #iodefv2_incident_id_t object.
 *
 * Get instance children of the #iodefv2_incident_id_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_incident_id_get_instance(iodefv2_incident_id_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->instance;

}


/**
 * iodefv2_incident_id_set_instance:
 * @ptr: pointer to a #iodefv2_incident_id_t object.
 * @instance: pointer to a #libiodefv2_string_t object.
 *
 * Set @instance object as a children of @ptr.
 * if @ptr already contain an @instance object, then it is destroyed,
 * and updated to point to the provided @instance object.
 */

void iodefv2_incident_id_set_instance(iodefv2_incident_id_t *ptr, libiodefv2_string_t *instance)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->instance )
                libiodefv2_string_destroy(ptr->instance);

        ptr->instance = instance;
}
/**
 * iodefv2_incident_id_new_instance:
 * @ptr: pointer to a #iodefv2_incident_id_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new instance object, children of #iodefv2_incident_id_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_id_new_instance(iodefv2_incident_id_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->instance ) {
                retval = libiodefv2_string_new(&ptr->instance);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->instance;
        return 0;
}




/**
 * iodefv2_incident_id_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_incident_id_t object.
 *
 * Get ext_restriction children of the #iodefv2_incident_id_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_incident_id_get_ext_restriction(iodefv2_incident_id_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_incident_id_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_incident_id_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_incident_id_set_ext_restriction(iodefv2_incident_id_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_incident_id_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_incident_id_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_incident_id_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_id_new_ext_restriction(iodefv2_incident_id_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_incident_id_get_name:
 * @ptr: pointer to a #iodefv2_incident_id_t object.
 *
 * Get name children of the #iodefv2_incident_id_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_incident_id_get_name(iodefv2_incident_id_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * iodefv2_incident_id_set_name:
 * @ptr: pointer to a #iodefv2_incident_id_t object.
 * @name: pointer to a #libiodefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void iodefv2_incident_id_set_name(iodefv2_incident_id_t *ptr, libiodefv2_string_t *name)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->name )
                libiodefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * iodefv2_incident_id_new_name:
 * @ptr: pointer to a #iodefv2_incident_id_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new name object, children of #iodefv2_incident_id_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_id_new_name(iodefv2_incident_id_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libiodefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}




/**
 * iodefv2_incident_id_get_restriction:
 * @ptr: pointer to a #iodefv2_incident_id_t object.
 *
 * Get restriction children of the #iodefv2_incident_id_t object.
 *
 * Returns: a pointer to a iodefv2_incident_id_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_incident_id_restriction_t *iodefv2_incident_id_get_restriction(iodefv2_incident_id_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_incident_id_set_restriction:
 * @ptr: pointer to a #iodefv2_incident_id_t object.
 * @restriction: pointer to a #iodefv2_incident_id_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_incident_id_set_restriction(iodefv2_incident_id_t *ptr, iodefv2_incident_id_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_incident_id_unset_restriction(iodefv2_incident_id_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_incident_id_new_restriction:
 * @ptr: pointer to a #iodefv2_incident_id_t object.
 * @ret: pointer to an address where to store the created #iodefv2_incident_id_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_incident_id_t.
 * If @ptr already contain a #iodefv2_incident_id_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_id_new_restriction(iodefv2_incident_id_t *ptr, iodefv2_incident_id_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}



/**
 * iodefv2_incident_id_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_incident_id_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_incident_id_copy(const iodefv2_incident_id_t *src, iodefv2_incident_id_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->instance ) {
                libiodefv2_string_destroy(dst->instance);
                dst->instance = NULL;
        }

        if ( src->instance ) {
                ret = libiodefv2_string_clone(src->instance, &dst->instance);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->name ) {
                ret = libiodefv2_string_copy(src->name, dst->name);
                if ( ret < 0 )
                        return ret;
        }



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;
    return 0 ;
}


/**
 * iodefv2_incident_id_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_incident_id_clone(iodefv2_incident_id_t *src, iodefv2_incident_id_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_incident_id_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_incident_id_copy(src, *dst);
}


/**
 * iodefv2_incident_id_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_incident_id_compare(const iodefv2_incident_id_t *obj1, const iodefv2_incident_id_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->instance, obj2->instance);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;

        return ret;
}


        



/**
 * iodefv2_alternative_indicator_id_new:
 * @ret: Pointer where to store the created #iodefv2_alternative_indicator_id_t object.
 *
 * Create a new #iodefv2_alternative_indicator_id_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_alternative_indicator_id_new(iodefv2_alternative_indicator_id_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_ALTERNATIVE_INDICATOR_ID;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;




            return 0;
}


/**
 * iodefv2_alternative_indicator_id_ref:
 * @alternative_indicator_id: pointer to a #iodefv2_alternative_indicator_id_t object.
 *
 * Increase @alternative_indicator_id reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @alternative_indicator_id.
 */
iodefv2_alternative_indicator_id_t *iodefv2_alternative_indicator_id_ref(iodefv2_alternative_indicator_id_t *alternative_indicator_id)
{
        libiodefv2_return_val_if_fail(alternative_indicator_id, NULL);
        alternative_indicator_id->refcount++;

        return alternative_indicator_id;
}



int _iodefv2_alternative_indicator_id_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_alternative_indicator_id_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_ALTERNATIVE_INDICATOR_ID_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->indicator_reference, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_alternative_indicator_id_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_alternative_indicator_id_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_alternative_indicator_id_new_restriction(ptr, (iodefv2_alternative_indicator_id_restriction_t **) ret);

                case 1:
                    return iodefv2_alternative_indicator_id_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_alternative_indicator_id_new_indicator_reference(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_alternative_indicator_id_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_alternative_indicator_id_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->indicator_reference ) {
                                libiodefv2_string_destroy(ptr->indicator_reference);
                                ptr->indicator_reference = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_alternative_indicator_id_destroy_internal(iodefv2_alternative_indicator_id_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }



        if ( ptr->indicator_reference ) {
                libiodefv2_string_destroy(ptr->indicator_reference);
                ptr->indicator_reference = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_alternative_indicator_id_destroy:
 * @ptr: pointer to a #iodefv2_alternative_indicator_id_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_alternative_indicator_id_destroy(iodefv2_alternative_indicator_id_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_alternative_indicator_id_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_alternative_indicator_id_get_restriction:
 * @ptr: pointer to a #iodefv2_alternative_indicator_id_t object.
 *
 * Get restriction children of the #iodefv2_alternative_indicator_id_t object.
 *
 * Returns: a pointer to a iodefv2_alternative_indicator_id_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_alternative_indicator_id_restriction_t *iodefv2_alternative_indicator_id_get_restriction(iodefv2_alternative_indicator_id_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_alternative_indicator_id_set_restriction:
 * @ptr: pointer to a #iodefv2_alternative_indicator_id_t object.
 * @restriction: pointer to a #iodefv2_alternative_indicator_id_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_alternative_indicator_id_set_restriction(iodefv2_alternative_indicator_id_t *ptr, iodefv2_alternative_indicator_id_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_alternative_indicator_id_unset_restriction(iodefv2_alternative_indicator_id_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_alternative_indicator_id_new_restriction:
 * @ptr: pointer to a #iodefv2_alternative_indicator_id_t object.
 * @ret: pointer to an address where to store the created #iodefv2_alternative_indicator_id_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_alternative_indicator_id_t.
 * If @ptr already contain a #iodefv2_alternative_indicator_id_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_alternative_indicator_id_new_restriction(iodefv2_alternative_indicator_id_t *ptr, iodefv2_alternative_indicator_id_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_alternative_indicator_id_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_alternative_indicator_id_t object.
 *
 * Get ext_restriction children of the #iodefv2_alternative_indicator_id_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_alternative_indicator_id_get_ext_restriction(iodefv2_alternative_indicator_id_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_alternative_indicator_id_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_alternative_indicator_id_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_alternative_indicator_id_set_ext_restriction(iodefv2_alternative_indicator_id_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_alternative_indicator_id_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_alternative_indicator_id_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_alternative_indicator_id_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_alternative_indicator_id_new_ext_restriction(iodefv2_alternative_indicator_id_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_alternative_indicator_id_get_indicator_reference:
 * @ptr: pointer to a #iodefv2_alternative_indicator_id_t object.
 *
 * Get indicator_reference children of the #iodefv2_alternative_indicator_id_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_alternative_indicator_id_get_indicator_reference(iodefv2_alternative_indicator_id_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->indicator_reference;

}


/**
 * iodefv2_alternative_indicator_id_set_indicator_reference:
 * @ptr: pointer to a #iodefv2_alternative_indicator_id_t object.
 * @indicator_reference: pointer to a #libiodefv2_string_t object.
 *
 * Set @indicator_reference object as a children of @ptr.
 * if @ptr already contain an @indicator_reference object, then it is destroyed,
 * and updated to point to the provided @indicator_reference object.
 */

void iodefv2_alternative_indicator_id_set_indicator_reference(iodefv2_alternative_indicator_id_t *ptr, libiodefv2_string_t *indicator_reference)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->indicator_reference )
                libiodefv2_string_destroy(ptr->indicator_reference);

        ptr->indicator_reference = indicator_reference;
}
/**
 * iodefv2_alternative_indicator_id_new_indicator_reference:
 * @ptr: pointer to a #iodefv2_alternative_indicator_id_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new indicator_reference object, children of #iodefv2_alternative_indicator_id_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_alternative_indicator_id_new_indicator_reference(iodefv2_alternative_indicator_id_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->indicator_reference ) {
                retval = libiodefv2_string_new(&ptr->indicator_reference);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->indicator_reference;
        return 0;
}



/**
 * iodefv2_alternative_indicator_id_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_alternative_indicator_id_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_alternative_indicator_id_copy(const iodefv2_alternative_indicator_id_t *src, iodefv2_alternative_indicator_id_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->indicator_reference ) {
                libiodefv2_string_destroy(dst->indicator_reference);
                dst->indicator_reference = NULL;
        }

        if ( src->indicator_reference ) {
                ret = libiodefv2_string_clone(src->indicator_reference, &dst->indicator_reference);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_alternative_indicator_id_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_alternative_indicator_id_clone(iodefv2_alternative_indicator_id_t *src, iodefv2_alternative_indicator_id_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_alternative_indicator_id_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_alternative_indicator_id_copy(src, *dst);
}


/**
 * iodefv2_alternative_indicator_id_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_alternative_indicator_id_compare(const iodefv2_alternative_indicator_id_t *obj1, const iodefv2_alternative_indicator_id_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->indicator_reference, obj2->indicator_reference);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_confidence_new:
 * @ret: Pointer where to store the created #iodefv2_confidence_t object.
 *
 * Create a new #iodefv2_confidence_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_confidence_new(iodefv2_confidence_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_CONFIDENCE;


        (*ret)->refcount = 1;



            return 0;
}


/**
 * iodefv2_confidence_ref:
 * @confidence: pointer to a #iodefv2_confidence_t object.
 *
 * Increase @confidence reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @confidence.
 */
iodefv2_confidence_t *iodefv2_confidence_ref(iodefv2_confidence_t *confidence)
{
        libiodefv2_return_val_if_fail(confidence, NULL);
        confidence->refcount++;

        return confidence;
}



int _iodefv2_confidence_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_confidence_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_CONFIDENCE_RATING , ptr->rating);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_rating, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_confidence_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_confidence_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_confidence_new_rating(ptr, (iodefv2_confidence_rating_t **) ret);

                case 1:
                    return iodefv2_confidence_new_ext_rating(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_confidence_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_confidence_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->rating = 0;
                    return 0;




                case 1:
                        if ( ptr->ext_rating ) {
                                libiodefv2_string_destroy(ptr->ext_rating);
                                ptr->ext_rating = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_confidence_destroy_internal(iodefv2_confidence_t *ptr)
{
        libiodefv2_return_if_fail(ptr);



        if ( ptr->ext_rating ) {
                libiodefv2_string_destroy(ptr->ext_rating);
                ptr->ext_rating = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_confidence_destroy:
 * @ptr: pointer to a #iodefv2_confidence_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_confidence_destroy(iodefv2_confidence_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_confidence_destroy_internal(ptr);
        free(ptr);
}




/**
 * iodefv2_confidence_get_rating:
 * @ptr: pointer to a #iodefv2_confidence_t object.
 *
 * Get rating children of the #iodefv2_confidence_t object.
 *
 * Returns: a pointer to a iodefv2_confidence_rating_t object, or NULL if the children object is not set.
 */
iodefv2_confidence_rating_t iodefv2_confidence_get_rating(iodefv2_confidence_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->rating;

}


/**
 * iodefv2_confidence_set_rating:
 * @ptr: pointer to a #iodefv2_confidence_t object.
 * @rating: pointer to a #iodefv2_confidence_rating_t object.
 *
 * Set @rating object as a children of @ptr.
 * if @ptr already contain an @rating object, then it is destroyed,
 * and updated to point to the provided @rating object.
 */
void iodefv2_confidence_set_rating(iodefv2_confidence_t *ptr, iodefv2_confidence_rating_t rating)
{
        libiodefv2_return_if_fail(ptr);
        ptr->rating = rating;
}
/**
 * iodefv2_confidence_new_rating:
 * @ptr: pointer to a #iodefv2_confidence_t object.
 * @ret: pointer to an address where to store the created #iodefv2_confidence_rating_t object.
 *
 * Create a new rating object, children of #iodefv2_confidence_t.
 * If @ptr already contain a #iodefv2_confidence_rating_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_confidence_new_rating(iodefv2_confidence_t *ptr, iodefv2_confidence_rating_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->rating;
        return 0;
}




/**
 * iodefv2_confidence_get_ext_rating:
 * @ptr: pointer to a #iodefv2_confidence_t object.
 *
 * Get ext_rating children of the #iodefv2_confidence_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_confidence_get_ext_rating(iodefv2_confidence_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_rating;

}


/**
 * iodefv2_confidence_set_ext_rating:
 * @ptr: pointer to a #iodefv2_confidence_t object.
 * @ext_rating: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_rating object as a children of @ptr.
 * if @ptr already contain an @ext_rating object, then it is destroyed,
 * and updated to point to the provided @ext_rating object.
 */

void iodefv2_confidence_set_ext_rating(iodefv2_confidence_t *ptr, libiodefv2_string_t *ext_rating)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_rating )
                libiodefv2_string_destroy(ptr->ext_rating);

        ptr->ext_rating = ext_rating;
}
/**
 * iodefv2_confidence_new_ext_rating:
 * @ptr: pointer to a #iodefv2_confidence_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_rating object, children of #iodefv2_confidence_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_confidence_new_ext_rating(iodefv2_confidence_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_rating ) {
                retval = libiodefv2_string_new(&ptr->ext_rating);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_rating;
        return 0;
}



/**
 * iodefv2_confidence_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_confidence_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_confidence_copy(const iodefv2_confidence_t *src, iodefv2_confidence_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->rating = src->rating;



        if ( dst->ext_rating ) {
                libiodefv2_string_destroy(dst->ext_rating);
                dst->ext_rating = NULL;
        }

        if ( src->ext_rating ) {
                ret = libiodefv2_string_clone(src->ext_rating, &dst->ext_rating);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_confidence_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_confidence_clone(iodefv2_confidence_t *src, iodefv2_confidence_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_confidence_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_confidence_copy(src, *dst);
}


/**
 * iodefv2_confidence_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_confidence_compare(const iodefv2_confidence_t *obj1, const iodefv2_confidence_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->rating != obj2->rating )
                return -1;

        ret = libiodefv2_string_compare(obj1->ext_rating, obj2->ext_rating);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_system_impact_new:
 * @ret: Pointer where to store the created #iodefv2_system_impact_t object.
 *
 * Create a new #iodefv2_system_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_system_impact_new(iodefv2_system_impact_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_SYSTEM_IMPACT;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;








            return 0;
}


/**
 * iodefv2_system_impact_ref:
 * @system_impact: pointer to a #iodefv2_system_impact_t object.
 *
 * Increase @system_impact reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @system_impact.
 */
iodefv2_system_impact_t *iodefv2_system_impact_ref(iodefv2_system_impact_t *system_impact)
{
        libiodefv2_return_val_if_fail(system_impact, NULL);
        system_impact->refcount++;

        return system_impact;
}



int _iodefv2_system_impact_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_system_impact_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->completion_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_SYSTEM_IMPACT_COMPLETION , ptr->completion);

            case 1:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_SYSTEM_IMPACT_TYPE , ptr->type);

            case 2:

                    if ( ! ptr->severity_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_SYSTEM_IMPACT_SEVERITY , ptr->severity);


            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_type, TRUE);



            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_system_impact_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_system_impact_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_system_impact_new_completion(ptr, (iodefv2_system_impact_completion_t **) ret);

                case 1:
                    return iodefv2_system_impact_new_type(ptr, (iodefv2_system_impact_type_t **) ret);

                case 2:
                    return iodefv2_system_impact_new_severity(ptr, (iodefv2_system_impact_severity_t **) ret);

                case 3:
                    return iodefv2_system_impact_new_ext_type(ptr, (libiodefv2_string_t **) ret);

                case 4:
                    return iodefv2_system_impact_new_description(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_system_impact_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_system_impact_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->completion_is_set = 0;
                        return 0;




                case 1:
                    ptr->type = 0;
                    return 0;

                case 2:
                        ptr->severity_is_set = 0;
                        return 0;




                case 3:
                        if ( ptr->ext_type ) {
                                libiodefv2_string_destroy(ptr->ext_type);
                                ptr->ext_type = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_system_impact_destroy_internal(iodefv2_system_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);







        if ( ptr->ext_type ) {
                libiodefv2_string_destroy(ptr->ext_type);
                ptr->ext_type = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_system_impact_destroy:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_system_impact_destroy(iodefv2_system_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_system_impact_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_system_impact_get_completion:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 *
 * Get completion children of the #iodefv2_system_impact_t object.
 *
 * Returns: a pointer to a iodefv2_system_impact_completion_t object, or NULL if the children object is not set.
 */
iodefv2_system_impact_completion_t *iodefv2_system_impact_get_completion(iodefv2_system_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->completion_is_set ? &ptr->completion : NULL;


}


/**
 * iodefv2_system_impact_set_completion:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 * @completion: pointer to a #iodefv2_system_impact_completion_t object.
 *
 * Set @completion object as a children of @ptr.
 * if @ptr already contain an @completion object, then it is destroyed,
 * and updated to point to the provided @completion object.
 */
void iodefv2_system_impact_set_completion(iodefv2_system_impact_t *ptr, iodefv2_system_impact_completion_t completion)
{
        libiodefv2_return_if_fail(ptr);
        ptr->completion = completion;
        ptr->completion_is_set = 1;
}

void iodefv2_system_impact_unset_completion(iodefv2_system_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->completion_is_set = 0;
}
/**
 * iodefv2_system_impact_new_completion:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 * @ret: pointer to an address where to store the created #iodefv2_system_impact_completion_t object.
 *
 * Create a new completion object, children of #iodefv2_system_impact_t.
 * If @ptr already contain a #iodefv2_system_impact_completion_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_impact_new_completion(iodefv2_system_impact_t *ptr, iodefv2_system_impact_completion_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->completion_is_set = 1;



        *ret = &ptr->completion;
        return 0;
}



/**
 * iodefv2_system_impact_get_type:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 *
 * Get type children of the #iodefv2_system_impact_t object.
 *
 * Returns: a pointer to a iodefv2_system_impact_type_t object, or NULL if the children object is not set.
 */
iodefv2_system_impact_type_t iodefv2_system_impact_get_type(iodefv2_system_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type;

}


/**
 * iodefv2_system_impact_set_type:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 * @type: pointer to a #iodefv2_system_impact_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */
void iodefv2_system_impact_set_type(iodefv2_system_impact_t *ptr, iodefv2_system_impact_type_t type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type = type;
}
/**
 * iodefv2_system_impact_new_type:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 * @ret: pointer to an address where to store the created #iodefv2_system_impact_type_t object.
 *
 * Create a new type object, children of #iodefv2_system_impact_t.
 * If @ptr already contain a #iodefv2_system_impact_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_impact_new_type(iodefv2_system_impact_t *ptr, iodefv2_system_impact_type_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->type;
        return 0;
}




/**
 * iodefv2_system_impact_get_severity:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 *
 * Get severity children of the #iodefv2_system_impact_t object.
 *
 * Returns: a pointer to a iodefv2_system_impact_severity_t object, or NULL if the children object is not set.
 */
iodefv2_system_impact_severity_t *iodefv2_system_impact_get_severity(iodefv2_system_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->severity_is_set ? &ptr->severity : NULL;


}


/**
 * iodefv2_system_impact_set_severity:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 * @severity: pointer to a #iodefv2_system_impact_severity_t object.
 *
 * Set @severity object as a children of @ptr.
 * if @ptr already contain an @severity object, then it is destroyed,
 * and updated to point to the provided @severity object.
 */
void iodefv2_system_impact_set_severity(iodefv2_system_impact_t *ptr, iodefv2_system_impact_severity_t severity)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity = severity;
        ptr->severity_is_set = 1;
}

void iodefv2_system_impact_unset_severity(iodefv2_system_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity_is_set = 0;
}
/**
 * iodefv2_system_impact_new_severity:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 * @ret: pointer to an address where to store the created #iodefv2_system_impact_severity_t object.
 *
 * Create a new severity object, children of #iodefv2_system_impact_t.
 * If @ptr already contain a #iodefv2_system_impact_severity_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_impact_new_severity(iodefv2_system_impact_t *ptr, iodefv2_system_impact_severity_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->severity_is_set = 1;



        *ret = &ptr->severity;
        return 0;
}




/**
 * iodefv2_system_impact_get_ext_type:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 *
 * Get ext_type children of the #iodefv2_system_impact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_system_impact_get_ext_type(iodefv2_system_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_type;

}


/**
 * iodefv2_system_impact_set_ext_type:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 * @ext_type: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_type object as a children of @ptr.
 * if @ptr already contain an @ext_type object, then it is destroyed,
 * and updated to point to the provided @ext_type object.
 */

void iodefv2_system_impact_set_ext_type(iodefv2_system_impact_t *ptr, libiodefv2_string_t *ext_type)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_type )
                libiodefv2_string_destroy(ptr->ext_type);

        ptr->ext_type = ext_type;
}
/**
 * iodefv2_system_impact_new_ext_type:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_type object, children of #iodefv2_system_impact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_impact_new_ext_type(iodefv2_system_impact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_type ) {
                retval = libiodefv2_string_new(&ptr->ext_type);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_type;
        return 0;
}




/**
 * iodefv2_system_impact_get_description:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 *
 * Get description children of the #iodefv2_system_impact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_system_impact_get_description(iodefv2_system_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_system_impact_set_description:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_system_impact_set_description(iodefv2_system_impact_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_system_impact_new_description:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_system_impact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_impact_new_description(iodefv2_system_impact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}



/**
 * iodefv2_system_impact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_system_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_system_impact_copy(const iodefv2_system_impact_t *src, iodefv2_system_impact_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->completion_is_set = src->completion_is_set;
        dst->completion = src->completion;



        dst->type = src->type;



        dst->severity_is_set = src->severity_is_set;
        dst->severity = src->severity;



        if ( dst->ext_type ) {
                libiodefv2_string_destroy(dst->ext_type);
                dst->ext_type = NULL;
        }

        if ( src->ext_type ) {
                ret = libiodefv2_string_clone(src->ext_type, &dst->ext_type);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_system_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_system_impact_clone(iodefv2_system_impact_t *src, iodefv2_system_impact_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_system_impact_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_system_impact_copy(src, *dst);
}


/**
 * iodefv2_system_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_system_impact_compare(const iodefv2_system_impact_t *obj1, const iodefv2_system_impact_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->completion_is_set != obj2->completion_is_set )
                return -1;

        if ( obj1->completion_is_set && obj1->completion != obj2->completion )
                return -1;



        if ( obj1->type != obj2->type )
                return -1;


        if ( obj1->severity_is_set != obj2->severity_is_set )
                return -1;

        if ( obj1->severity_is_set && obj1->severity != obj2->severity )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_type, obj2->ext_type);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_software_reference_new:
 * @ret: Pointer where to store the created #iodefv2_software_reference_t object.
 *
 * Create a new #iodefv2_software_reference_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_software_reference_new(iodefv2_software_reference_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_SOFTWARE_REFERENCE;


        (*ret)->refcount = 1;




            return 0;
}


/**
 * iodefv2_software_reference_ref:
 * @software_reference: pointer to a #iodefv2_software_reference_t object.
 *
 * Increase @software_reference reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @software_reference.
 */
iodefv2_software_reference_t *iodefv2_software_reference_ref(iodefv2_software_reference_t *software_reference)
{
        libiodefv2_return_val_if_fail(software_reference, NULL);
        software_reference->refcount++;

        return software_reference;
}



int _iodefv2_software_reference_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_software_reference_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->dtype_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_SOFTWARE_REFERENCE_DTYPE , ptr->dtype);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_spec_name, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_dtype, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_software_reference_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_software_reference_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_software_reference_new_dtype(ptr, (iodefv2_software_reference_dtype_t **) ret);

                case 1:
                    return iodefv2_software_reference_new_ext_spec_name(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_software_reference_new_ext_dtype(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_software_reference_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_software_reference_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->dtype_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_spec_name ) {
                                libiodefv2_string_destroy(ptr->ext_spec_name);
                                ptr->ext_spec_name = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->ext_dtype ) {
                                libiodefv2_string_destroy(ptr->ext_dtype);
                                ptr->ext_dtype = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_software_reference_destroy_internal(iodefv2_software_reference_t *ptr)
{
        libiodefv2_return_if_fail(ptr);



        if ( ptr->ext_spec_name ) {
                libiodefv2_string_destroy(ptr->ext_spec_name);
                ptr->ext_spec_name = NULL;
        }



        if ( ptr->ext_dtype ) {
                libiodefv2_string_destroy(ptr->ext_dtype);
                ptr->ext_dtype = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_software_reference_destroy:
 * @ptr: pointer to a #iodefv2_software_reference_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_software_reference_destroy(iodefv2_software_reference_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_software_reference_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_software_reference_get_dtype:
 * @ptr: pointer to a #iodefv2_software_reference_t object.
 *
 * Get dtype children of the #iodefv2_software_reference_t object.
 *
 * Returns: a pointer to a iodefv2_software_reference_dtype_t object, or NULL if the children object is not set.
 */
iodefv2_software_reference_dtype_t *iodefv2_software_reference_get_dtype(iodefv2_software_reference_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->dtype_is_set ? &ptr->dtype : NULL;


}


/**
 * iodefv2_software_reference_set_dtype:
 * @ptr: pointer to a #iodefv2_software_reference_t object.
 * @dtype: pointer to a #iodefv2_software_reference_dtype_t object.
 *
 * Set @dtype object as a children of @ptr.
 * if @ptr already contain an @dtype object, then it is destroyed,
 * and updated to point to the provided @dtype object.
 */
void iodefv2_software_reference_set_dtype(iodefv2_software_reference_t *ptr, iodefv2_software_reference_dtype_t dtype)
{
        libiodefv2_return_if_fail(ptr);
        ptr->dtype = dtype;
        ptr->dtype_is_set = 1;
}

void iodefv2_software_reference_unset_dtype(iodefv2_software_reference_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->dtype_is_set = 0;
}
/**
 * iodefv2_software_reference_new_dtype:
 * @ptr: pointer to a #iodefv2_software_reference_t object.
 * @ret: pointer to an address where to store the created #iodefv2_software_reference_dtype_t object.
 *
 * Create a new dtype object, children of #iodefv2_software_reference_t.
 * If @ptr already contain a #iodefv2_software_reference_dtype_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_software_reference_new_dtype(iodefv2_software_reference_t *ptr, iodefv2_software_reference_dtype_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->dtype_is_set = 1;



        *ret = &ptr->dtype;
        return 0;
}




/**
 * iodefv2_software_reference_get_ext_spec_name:
 * @ptr: pointer to a #iodefv2_software_reference_t object.
 *
 * Get ext_spec_name children of the #iodefv2_software_reference_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_software_reference_get_ext_spec_name(iodefv2_software_reference_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_spec_name;

}


/**
 * iodefv2_software_reference_set_ext_spec_name:
 * @ptr: pointer to a #iodefv2_software_reference_t object.
 * @ext_spec_name: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_spec_name object as a children of @ptr.
 * if @ptr already contain an @ext_spec_name object, then it is destroyed,
 * and updated to point to the provided @ext_spec_name object.
 */

void iodefv2_software_reference_set_ext_spec_name(iodefv2_software_reference_t *ptr, libiodefv2_string_t *ext_spec_name)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_spec_name )
                libiodefv2_string_destroy(ptr->ext_spec_name);

        ptr->ext_spec_name = ext_spec_name;
}
/**
 * iodefv2_software_reference_new_ext_spec_name:
 * @ptr: pointer to a #iodefv2_software_reference_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_spec_name object, children of #iodefv2_software_reference_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_software_reference_new_ext_spec_name(iodefv2_software_reference_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_spec_name ) {
                retval = libiodefv2_string_new(&ptr->ext_spec_name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_spec_name;
        return 0;
}




/**
 * iodefv2_software_reference_get_ext_dtype:
 * @ptr: pointer to a #iodefv2_software_reference_t object.
 *
 * Get ext_dtype children of the #iodefv2_software_reference_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_software_reference_get_ext_dtype(iodefv2_software_reference_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_dtype;

}


/**
 * iodefv2_software_reference_set_ext_dtype:
 * @ptr: pointer to a #iodefv2_software_reference_t object.
 * @ext_dtype: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_dtype object as a children of @ptr.
 * if @ptr already contain an @ext_dtype object, then it is destroyed,
 * and updated to point to the provided @ext_dtype object.
 */

void iodefv2_software_reference_set_ext_dtype(iodefv2_software_reference_t *ptr, libiodefv2_string_t *ext_dtype)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_dtype )
                libiodefv2_string_destroy(ptr->ext_dtype);

        ptr->ext_dtype = ext_dtype;
}
/**
 * iodefv2_software_reference_new_ext_dtype:
 * @ptr: pointer to a #iodefv2_software_reference_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_dtype object, children of #iodefv2_software_reference_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_software_reference_new_ext_dtype(iodefv2_software_reference_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_dtype ) {
                retval = libiodefv2_string_new(&ptr->ext_dtype);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_dtype;
        return 0;
}



/**
 * iodefv2_software_reference_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_software_reference_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_software_reference_copy(const iodefv2_software_reference_t *src, iodefv2_software_reference_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->dtype_is_set = src->dtype_is_set;
        dst->dtype = src->dtype;



        if ( dst->ext_spec_name ) {
                libiodefv2_string_destroy(dst->ext_spec_name);
                dst->ext_spec_name = NULL;
        }

        if ( src->ext_spec_name ) {
                ret = libiodefv2_string_clone(src->ext_spec_name, &dst->ext_spec_name);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->ext_dtype ) {
                libiodefv2_string_destroy(dst->ext_dtype);
                dst->ext_dtype = NULL;
        }

        if ( src->ext_dtype ) {
                ret = libiodefv2_string_clone(src->ext_dtype, &dst->ext_dtype);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_software_reference_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_software_reference_clone(iodefv2_software_reference_t *src, iodefv2_software_reference_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_software_reference_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_software_reference_copy(src, *dst);
}


/**
 * iodefv2_software_reference_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_software_reference_compare(const iodefv2_software_reference_t *obj1, const iodefv2_software_reference_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->dtype_is_set != obj2->dtype_is_set )
                return -1;

        if ( obj1->dtype_is_set && obj1->dtype != obj2->dtype )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_spec_name, obj2->ext_spec_name);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->ext_dtype, obj2->ext_dtype);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_business_impact_new:
 * @ret: Pointer where to store the created #iodefv2_business_impact_t object.
 *
 * Create a new #iodefv2_business_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_business_impact_new(iodefv2_business_impact_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_BUSINESS_IMPACT;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;







            return 0;
}


/**
 * iodefv2_business_impact_ref:
 * @business_impact: pointer to a #iodefv2_business_impact_t object.
 *
 * Increase @business_impact reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @business_impact.
 */
iodefv2_business_impact_t *iodefv2_business_impact_ref(iodefv2_business_impact_t *business_impact)
{
        libiodefv2_return_val_if_fail(business_impact, NULL);
        business_impact->refcount++;

        return business_impact;
}



int _iodefv2_business_impact_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_business_impact_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_severity, TRUE);


            case 1:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_BUSINESS_IMPACT_TYPE , ptr->type);

            case 2:

                    if ( ! ptr->severity_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_BUSINESS_IMPACT_SEVERITY , ptr->severity);


            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_type, TRUE);



            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_business_impact_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_business_impact_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_business_impact_new_ext_severity(ptr, (libiodefv2_string_t **) ret);

                case 1:
                    return iodefv2_business_impact_new_type(ptr, (iodefv2_business_impact_type_t **) ret);

                case 2:
                    return iodefv2_business_impact_new_severity(ptr, (iodefv2_business_impact_severity_t **) ret);

                case 3:
                    return iodefv2_business_impact_new_ext_type(ptr, (libiodefv2_string_t **) ret);

                case 4:
                    return iodefv2_business_impact_new_description(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_business_impact_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_business_impact_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->ext_severity ) {
                                libiodefv2_string_destroy(ptr->ext_severity);
                                ptr->ext_severity = NULL;
                        }

                        return 0;




                case 1:
                    ptr->type = 0;
                    return 0;

                case 2:
                        ptr->severity_is_set = 0;
                        return 0;




                case 3:
                        if ( ptr->ext_type ) {
                                libiodefv2_string_destroy(ptr->ext_type);
                                ptr->ext_type = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_business_impact_destroy_internal(iodefv2_business_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->ext_severity ) {
                libiodefv2_string_destroy(ptr->ext_severity);
                ptr->ext_severity = NULL;
        }







        if ( ptr->ext_type ) {
                libiodefv2_string_destroy(ptr->ext_type);
                ptr->ext_type = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_business_impact_destroy:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_business_impact_destroy(iodefv2_business_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_business_impact_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_business_impact_get_ext_severity:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 *
 * Get ext_severity children of the #iodefv2_business_impact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_business_impact_get_ext_severity(iodefv2_business_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_severity;

}


/**
 * iodefv2_business_impact_set_ext_severity:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 * @ext_severity: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_severity object as a children of @ptr.
 * if @ptr already contain an @ext_severity object, then it is destroyed,
 * and updated to point to the provided @ext_severity object.
 */

void iodefv2_business_impact_set_ext_severity(iodefv2_business_impact_t *ptr, libiodefv2_string_t *ext_severity)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_severity )
                libiodefv2_string_destroy(ptr->ext_severity);

        ptr->ext_severity = ext_severity;
}
/**
 * iodefv2_business_impact_new_ext_severity:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_severity object, children of #iodefv2_business_impact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_business_impact_new_ext_severity(iodefv2_business_impact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_severity ) {
                retval = libiodefv2_string_new(&ptr->ext_severity);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_severity;
        return 0;
}



/**
 * iodefv2_business_impact_get_type:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 *
 * Get type children of the #iodefv2_business_impact_t object.
 *
 * Returns: a pointer to a iodefv2_business_impact_type_t object, or NULL if the children object is not set.
 */
iodefv2_business_impact_type_t iodefv2_business_impact_get_type(iodefv2_business_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type;

}


/**
 * iodefv2_business_impact_set_type:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 * @type: pointer to a #iodefv2_business_impact_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */
void iodefv2_business_impact_set_type(iodefv2_business_impact_t *ptr, iodefv2_business_impact_type_t type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type = type;
}
/**
 * iodefv2_business_impact_new_type:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 * @ret: pointer to an address where to store the created #iodefv2_business_impact_type_t object.
 *
 * Create a new type object, children of #iodefv2_business_impact_t.
 * If @ptr already contain a #iodefv2_business_impact_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_business_impact_new_type(iodefv2_business_impact_t *ptr, iodefv2_business_impact_type_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->type;
        return 0;
}




/**
 * iodefv2_business_impact_get_severity:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 *
 * Get severity children of the #iodefv2_business_impact_t object.
 *
 * Returns: a pointer to a iodefv2_business_impact_severity_t object, or NULL if the children object is not set.
 */
iodefv2_business_impact_severity_t *iodefv2_business_impact_get_severity(iodefv2_business_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->severity_is_set ? &ptr->severity : NULL;


}


/**
 * iodefv2_business_impact_set_severity:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 * @severity: pointer to a #iodefv2_business_impact_severity_t object.
 *
 * Set @severity object as a children of @ptr.
 * if @ptr already contain an @severity object, then it is destroyed,
 * and updated to point to the provided @severity object.
 */
void iodefv2_business_impact_set_severity(iodefv2_business_impact_t *ptr, iodefv2_business_impact_severity_t severity)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity = severity;
        ptr->severity_is_set = 1;
}

void iodefv2_business_impact_unset_severity(iodefv2_business_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity_is_set = 0;
}
/**
 * iodefv2_business_impact_new_severity:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 * @ret: pointer to an address where to store the created #iodefv2_business_impact_severity_t object.
 *
 * Create a new severity object, children of #iodefv2_business_impact_t.
 * If @ptr already contain a #iodefv2_business_impact_severity_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_business_impact_new_severity(iodefv2_business_impact_t *ptr, iodefv2_business_impact_severity_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->severity_is_set = 1;



        *ret = &ptr->severity;
        return 0;
}




/**
 * iodefv2_business_impact_get_ext_type:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 *
 * Get ext_type children of the #iodefv2_business_impact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_business_impact_get_ext_type(iodefv2_business_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_type;

}


/**
 * iodefv2_business_impact_set_ext_type:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 * @ext_type: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_type object as a children of @ptr.
 * if @ptr already contain an @ext_type object, then it is destroyed,
 * and updated to point to the provided @ext_type object.
 */

void iodefv2_business_impact_set_ext_type(iodefv2_business_impact_t *ptr, libiodefv2_string_t *ext_type)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_type )
                libiodefv2_string_destroy(ptr->ext_type);

        ptr->ext_type = ext_type;
}
/**
 * iodefv2_business_impact_new_ext_type:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_type object, children of #iodefv2_business_impact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_business_impact_new_ext_type(iodefv2_business_impact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_type ) {
                retval = libiodefv2_string_new(&ptr->ext_type);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_type;
        return 0;
}




/**
 * iodefv2_business_impact_get_description:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 *
 * Get description children of the #iodefv2_business_impact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_business_impact_get_description(iodefv2_business_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_business_impact_set_description:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_business_impact_set_description(iodefv2_business_impact_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_business_impact_new_description:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_business_impact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_business_impact_new_description(iodefv2_business_impact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}



/**
 * iodefv2_business_impact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_business_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_business_impact_copy(const iodefv2_business_impact_t *src, iodefv2_business_impact_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->ext_severity ) {
                libiodefv2_string_destroy(dst->ext_severity);
                dst->ext_severity = NULL;
        }

        if ( src->ext_severity ) {
                ret = libiodefv2_string_clone(src->ext_severity, &dst->ext_severity);
                if ( ret < 0 )
                        return ret;
        }




        dst->type = src->type;



        dst->severity_is_set = src->severity_is_set;
        dst->severity = src->severity;



        if ( dst->ext_type ) {
                libiodefv2_string_destroy(dst->ext_type);
                dst->ext_type = NULL;
        }

        if ( src->ext_type ) {
                ret = libiodefv2_string_clone(src->ext_type, &dst->ext_type);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_business_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_business_impact_clone(iodefv2_business_impact_t *src, iodefv2_business_impact_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_business_impact_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_business_impact_copy(src, *dst);
}


/**
 * iodefv2_business_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_business_impact_compare(const iodefv2_business_impact_t *obj1, const iodefv2_business_impact_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->ext_severity, obj2->ext_severity);
        if ( ret != 0 )
                return ret;


        if ( obj1->type != obj2->type )
                return -1;


        if ( obj1->severity_is_set != obj2->severity_is_set )
                return -1;

        if ( obj1->severity_is_set && obj1->severity != obj2->severity )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_type, obj2->ext_type);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_indicator_reference_new:
 * @ret: Pointer where to store the created #iodefv2_indicator_reference_t object.
 *
 * Create a new #iodefv2_indicator_reference_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_indicator_reference_new(iodefv2_indicator_reference_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_INDICATOR_REFERENCE;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;



            return 0;
}


/**
 * iodefv2_indicator_reference_ref:
 * @indicator_reference: pointer to a #iodefv2_indicator_reference_t object.
 *
 * Increase @indicator_reference reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @indicator_reference.
 */
iodefv2_indicator_reference_t *iodefv2_indicator_reference_ref(iodefv2_indicator_reference_t *indicator_reference)
{
        libiodefv2_return_val_if_fail(indicator_reference, NULL);
        indicator_reference->refcount++;

        return indicator_reference;
}



int _iodefv2_indicator_reference_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_indicator_reference_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->uid_ref, TRUE);



            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->version, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->euid_ref, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_indicator_reference_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_indicator_reference_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_indicator_reference_new_uid_ref(ptr, (libiodefv2_string_t **) ret);

                case 1:
                    return iodefv2_indicator_reference_new_version(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_indicator_reference_new_euid_ref(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_indicator_reference_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_indicator_reference_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->uid_ref ) {
                                libiodefv2_string_destroy(ptr->uid_ref);
                                ptr->uid_ref = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->version ) {
                                libiodefv2_string_destroy(ptr->version);
                                ptr->version = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->euid_ref ) {
                                libiodefv2_string_destroy(ptr->euid_ref);
                                ptr->euid_ref = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_indicator_reference_destroy_internal(iodefv2_indicator_reference_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->uid_ref ) {
                libiodefv2_string_destroy(ptr->uid_ref);
                ptr->uid_ref = NULL;
        }



        if ( ptr->version ) {
                libiodefv2_string_destroy(ptr->version);
                ptr->version = NULL;
        }



        if ( ptr->euid_ref ) {
                libiodefv2_string_destroy(ptr->euid_ref);
                ptr->euid_ref = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_indicator_reference_destroy:
 * @ptr: pointer to a #iodefv2_indicator_reference_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_indicator_reference_destroy(iodefv2_indicator_reference_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_indicator_reference_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_indicator_reference_get_uid_ref:
 * @ptr: pointer to a #iodefv2_indicator_reference_t object.
 *
 * Get uid_ref children of the #iodefv2_indicator_reference_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_indicator_reference_get_uid_ref(iodefv2_indicator_reference_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->uid_ref;

}


/**
 * iodefv2_indicator_reference_set_uid_ref:
 * @ptr: pointer to a #iodefv2_indicator_reference_t object.
 * @uid_ref: pointer to a #libiodefv2_string_t object.
 *
 * Set @uid_ref object as a children of @ptr.
 * if @ptr already contain an @uid_ref object, then it is destroyed,
 * and updated to point to the provided @uid_ref object.
 */

void iodefv2_indicator_reference_set_uid_ref(iodefv2_indicator_reference_t *ptr, libiodefv2_string_t *uid_ref)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->uid_ref )
                libiodefv2_string_destroy(ptr->uid_ref);

        ptr->uid_ref = uid_ref;
}
/**
 * iodefv2_indicator_reference_new_uid_ref:
 * @ptr: pointer to a #iodefv2_indicator_reference_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new uid_ref object, children of #iodefv2_indicator_reference_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_reference_new_uid_ref(iodefv2_indicator_reference_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->uid_ref ) {
                retval = libiodefv2_string_new(&ptr->uid_ref);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->uid_ref;
        return 0;
}




/**
 * iodefv2_indicator_reference_get_version:
 * @ptr: pointer to a #iodefv2_indicator_reference_t object.
 *
 * Get version children of the #iodefv2_indicator_reference_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_indicator_reference_get_version(iodefv2_indicator_reference_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->version;

}


/**
 * iodefv2_indicator_reference_set_version:
 * @ptr: pointer to a #iodefv2_indicator_reference_t object.
 * @version: pointer to a #libiodefv2_string_t object.
 *
 * Set @version object as a children of @ptr.
 * if @ptr already contain an @version object, then it is destroyed,
 * and updated to point to the provided @version object.
 */

void iodefv2_indicator_reference_set_version(iodefv2_indicator_reference_t *ptr, libiodefv2_string_t *version)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->version )
                libiodefv2_string_destroy(ptr->version);

        ptr->version = version;
}
/**
 * iodefv2_indicator_reference_new_version:
 * @ptr: pointer to a #iodefv2_indicator_reference_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new version object, children of #iodefv2_indicator_reference_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_reference_new_version(iodefv2_indicator_reference_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->version ) {
                retval = libiodefv2_string_new(&ptr->version);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->version;
        return 0;
}




/**
 * iodefv2_indicator_reference_get_euid_ref:
 * @ptr: pointer to a #iodefv2_indicator_reference_t object.
 *
 * Get euid_ref children of the #iodefv2_indicator_reference_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_indicator_reference_get_euid_ref(iodefv2_indicator_reference_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->euid_ref;

}


/**
 * iodefv2_indicator_reference_set_euid_ref:
 * @ptr: pointer to a #iodefv2_indicator_reference_t object.
 * @euid_ref: pointer to a #libiodefv2_string_t object.
 *
 * Set @euid_ref object as a children of @ptr.
 * if @ptr already contain an @euid_ref object, then it is destroyed,
 * and updated to point to the provided @euid_ref object.
 */

void iodefv2_indicator_reference_set_euid_ref(iodefv2_indicator_reference_t *ptr, libiodefv2_string_t *euid_ref)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->euid_ref )
                libiodefv2_string_destroy(ptr->euid_ref);

        ptr->euid_ref = euid_ref;
}
/**
 * iodefv2_indicator_reference_new_euid_ref:
 * @ptr: pointer to a #iodefv2_indicator_reference_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new euid_ref object, children of #iodefv2_indicator_reference_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_reference_new_euid_ref(iodefv2_indicator_reference_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->euid_ref ) {
                retval = libiodefv2_string_new(&ptr->euid_ref);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->euid_ref;
        return 0;
}



/**
 * iodefv2_indicator_reference_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_indicator_reference_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_indicator_reference_copy(const iodefv2_indicator_reference_t *src, iodefv2_indicator_reference_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->uid_ref ) {
                libiodefv2_string_destroy(dst->uid_ref);
                dst->uid_ref = NULL;
        }

        if ( src->uid_ref ) {
                ret = libiodefv2_string_clone(src->uid_ref, &dst->uid_ref);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->version ) {
                libiodefv2_string_destroy(dst->version);
                dst->version = NULL;
        }

        if ( src->version ) {
                ret = libiodefv2_string_clone(src->version, &dst->version);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->euid_ref ) {
                libiodefv2_string_destroy(dst->euid_ref);
                dst->euid_ref = NULL;
        }

        if ( src->euid_ref ) {
                ret = libiodefv2_string_clone(src->euid_ref, &dst->euid_ref);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_indicator_reference_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_indicator_reference_clone(iodefv2_indicator_reference_t *src, iodefv2_indicator_reference_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_indicator_reference_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_indicator_reference_copy(src, *dst);
}


/**
 * iodefv2_indicator_reference_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_indicator_reference_compare(const iodefv2_indicator_reference_t *obj1, const iodefv2_indicator_reference_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->uid_ref, obj2->uid_ref);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->version, obj2->version);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->euid_ref, obj2->euid_ref);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_email_new:
 * @ret: Pointer where to store the created #iodefv2_email_t object.
 *
 * Create a new #iodefv2_email_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_email_new(iodefv2_email_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_EMAIL;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;




        {
            int retval = libiodefv2_string_new(&(*ret)->email_to);

            if ( retval < 0 ) {
                    iodefv2_email_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

            return 0;
}


/**
 * iodefv2_email_ref:
 * @email: pointer to a #iodefv2_email_t object.
 *
 * Increase @email reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @email.
 */
iodefv2_email_t *iodefv2_email_ref(iodefv2_email_t *email)
{
        libiodefv2_return_val_if_fail(email, NULL);
        email->refcount++;

        return email;
}



int _iodefv2_email_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_email_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->type_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_EMAIL_TYPE , ptr->type);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_type, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->email_to, TRUE);



            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_email_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_email_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_email_new_type(ptr, (iodefv2_email_type_t **) ret);

                case 1:
                    return iodefv2_email_new_ext_type(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_email_new_email_to(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_email_new_description(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_email_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_email_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->type_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_type ) {
                                libiodefv2_string_destroy(ptr->ext_type);
                                ptr->ext_type = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->email_to ) {
                                libiodefv2_string_destroy(ptr->email_to);
                                ptr->email_to = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_email_destroy_internal(iodefv2_email_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_type ) {
                libiodefv2_string_destroy(ptr->ext_type);
                ptr->ext_type = NULL;
        }



        if ( ptr->email_to ) {
                libiodefv2_string_destroy(ptr->email_to);
                ptr->email_to = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_email_destroy:
 * @ptr: pointer to a #iodefv2_email_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_email_destroy(iodefv2_email_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_email_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_email_get_type:
 * @ptr: pointer to a #iodefv2_email_t object.
 *
 * Get type children of the #iodefv2_email_t object.
 *
 * Returns: a pointer to a iodefv2_email_type_t object, or NULL if the children object is not set.
 */
iodefv2_email_type_t *iodefv2_email_get_type(iodefv2_email_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type_is_set ? &ptr->type : NULL;


}


/**
 * iodefv2_email_set_type:
 * @ptr: pointer to a #iodefv2_email_t object.
 * @type: pointer to a #iodefv2_email_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */
void iodefv2_email_set_type(iodefv2_email_t *ptr, iodefv2_email_type_t type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type = type;
        ptr->type_is_set = 1;
}

void iodefv2_email_unset_type(iodefv2_email_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type_is_set = 0;
}
/**
 * iodefv2_email_new_type:
 * @ptr: pointer to a #iodefv2_email_t object.
 * @ret: pointer to an address where to store the created #iodefv2_email_type_t object.
 *
 * Create a new type object, children of #iodefv2_email_t.
 * If @ptr already contain a #iodefv2_email_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_new_type(iodefv2_email_t *ptr, iodefv2_email_type_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->type_is_set = 1;



        *ret = &ptr->type;
        return 0;
}




/**
 * iodefv2_email_get_ext_type:
 * @ptr: pointer to a #iodefv2_email_t object.
 *
 * Get ext_type children of the #iodefv2_email_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_email_get_ext_type(iodefv2_email_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_type;

}


/**
 * iodefv2_email_set_ext_type:
 * @ptr: pointer to a #iodefv2_email_t object.
 * @ext_type: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_type object as a children of @ptr.
 * if @ptr already contain an @ext_type object, then it is destroyed,
 * and updated to point to the provided @ext_type object.
 */

void iodefv2_email_set_ext_type(iodefv2_email_t *ptr, libiodefv2_string_t *ext_type)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_type )
                libiodefv2_string_destroy(ptr->ext_type);

        ptr->ext_type = ext_type;
}
/**
 * iodefv2_email_new_ext_type:
 * @ptr: pointer to a #iodefv2_email_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_type object, children of #iodefv2_email_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_new_ext_type(iodefv2_email_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_type ) {
                retval = libiodefv2_string_new(&ptr->ext_type);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_type;
        return 0;
}




/**
 * iodefv2_email_get_email_to:
 * @ptr: pointer to a #iodefv2_email_t object.
 *
 * Get email_to children of the #iodefv2_email_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_email_get_email_to(iodefv2_email_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->email_to;

}


/**
 * iodefv2_email_set_email_to:
 * @ptr: pointer to a #iodefv2_email_t object.
 * @email_to: pointer to a #libiodefv2_string_t object.
 *
 * Set @email_to object as a children of @ptr.
 * if @ptr already contain an @email_to object, then it is destroyed,
 * and updated to point to the provided @email_to object.
 */

void iodefv2_email_set_email_to(iodefv2_email_t *ptr, libiodefv2_string_t *email_to)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->email_to )
                libiodefv2_string_destroy(ptr->email_to);

        ptr->email_to = email_to;
}
/**
 * iodefv2_email_new_email_to:
 * @ptr: pointer to a #iodefv2_email_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new email_to object, children of #iodefv2_email_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_new_email_to(iodefv2_email_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->email_to ) {
                retval = libiodefv2_string_new(&ptr->email_to);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->email_to;
        return 0;
}




/**
 * iodefv2_email_get_description:
 * @ptr: pointer to a #iodefv2_email_t object.
 *
 * Get description children of the #iodefv2_email_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_email_get_description(iodefv2_email_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_email_set_description:
 * @ptr: pointer to a #iodefv2_email_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_email_set_description(iodefv2_email_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_email_new_description:
 * @ptr: pointer to a #iodefv2_email_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_email_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_new_description(iodefv2_email_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}



/**
 * iodefv2_email_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_email_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_email_copy(const iodefv2_email_t *src, iodefv2_email_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->type_is_set = src->type_is_set;
        dst->type = src->type;



        if ( dst->ext_type ) {
                libiodefv2_string_destroy(dst->ext_type);
                dst->ext_type = NULL;
        }

        if ( src->ext_type ) {
                ret = libiodefv2_string_clone(src->ext_type, &dst->ext_type);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->email_to ) {
                ret = libiodefv2_string_copy(src->email_to, dst->email_to);
                if ( ret < 0 )
                        return ret;
        }



        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_email_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_email_clone(iodefv2_email_t *src, iodefv2_email_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_email_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_email_copy(src, *dst);
}


/**
 * iodefv2_email_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_email_compare(const iodefv2_email_t *obj1, const iodefv2_email_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->type_is_set != obj2->type_is_set )
                return -1;

        if ( obj1->type_is_set && obj1->type != obj2->type )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_type, obj2->ext_type);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->email_to, obj2->email_to);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_intended_impact_new:
 * @ret: Pointer where to store the created #iodefv2_intended_impact_t object.
 *
 * Create a new #iodefv2_intended_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_intended_impact_new(iodefv2_intended_impact_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_INTENDED_IMPACT;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;







            return 0;
}


/**
 * iodefv2_intended_impact_ref:
 * @intended_impact: pointer to a #iodefv2_intended_impact_t object.
 *
 * Increase @intended_impact reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @intended_impact.
 */
iodefv2_intended_impact_t *iodefv2_intended_impact_ref(iodefv2_intended_impact_t *intended_impact)
{
        libiodefv2_return_val_if_fail(intended_impact, NULL);
        intended_impact->refcount++;

        return intended_impact;
}



int _iodefv2_intended_impact_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_intended_impact_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_severity, TRUE);


            case 1:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_INTENDED_IMPACT_TYPE , ptr->type);

            case 2:

                    if ( ! ptr->severity_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_INTENDED_IMPACT_SEVERITY , ptr->severity);


            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_type, TRUE);



            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_intended_impact_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_intended_impact_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_intended_impact_new_ext_severity(ptr, (libiodefv2_string_t **) ret);

                case 1:
                    return iodefv2_intended_impact_new_type(ptr, (iodefv2_intended_impact_type_t **) ret);

                case 2:
                    return iodefv2_intended_impact_new_severity(ptr, (iodefv2_intended_impact_severity_t **) ret);

                case 3:
                    return iodefv2_intended_impact_new_ext_type(ptr, (libiodefv2_string_t **) ret);

                case 4:
                    return iodefv2_intended_impact_new_description(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_intended_impact_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_intended_impact_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->ext_severity ) {
                                libiodefv2_string_destroy(ptr->ext_severity);
                                ptr->ext_severity = NULL;
                        }

                        return 0;




                case 1:
                    ptr->type = 0;
                    return 0;

                case 2:
                        ptr->severity_is_set = 0;
                        return 0;




                case 3:
                        if ( ptr->ext_type ) {
                                libiodefv2_string_destroy(ptr->ext_type);
                                ptr->ext_type = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_intended_impact_destroy_internal(iodefv2_intended_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->ext_severity ) {
                libiodefv2_string_destroy(ptr->ext_severity);
                ptr->ext_severity = NULL;
        }







        if ( ptr->ext_type ) {
                libiodefv2_string_destroy(ptr->ext_type);
                ptr->ext_type = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_intended_impact_destroy:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_intended_impact_destroy(iodefv2_intended_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_intended_impact_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_intended_impact_get_ext_severity:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 *
 * Get ext_severity children of the #iodefv2_intended_impact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_intended_impact_get_ext_severity(iodefv2_intended_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_severity;

}


/**
 * iodefv2_intended_impact_set_ext_severity:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 * @ext_severity: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_severity object as a children of @ptr.
 * if @ptr already contain an @ext_severity object, then it is destroyed,
 * and updated to point to the provided @ext_severity object.
 */

void iodefv2_intended_impact_set_ext_severity(iodefv2_intended_impact_t *ptr, libiodefv2_string_t *ext_severity)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_severity )
                libiodefv2_string_destroy(ptr->ext_severity);

        ptr->ext_severity = ext_severity;
}
/**
 * iodefv2_intended_impact_new_ext_severity:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_severity object, children of #iodefv2_intended_impact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_intended_impact_new_ext_severity(iodefv2_intended_impact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_severity ) {
                retval = libiodefv2_string_new(&ptr->ext_severity);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_severity;
        return 0;
}



/**
 * iodefv2_intended_impact_get_type:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 *
 * Get type children of the #iodefv2_intended_impact_t object.
 *
 * Returns: a pointer to a iodefv2_intended_impact_type_t object, or NULL if the children object is not set.
 */
iodefv2_intended_impact_type_t iodefv2_intended_impact_get_type(iodefv2_intended_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type;

}


/**
 * iodefv2_intended_impact_set_type:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 * @type: pointer to a #iodefv2_intended_impact_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */
void iodefv2_intended_impact_set_type(iodefv2_intended_impact_t *ptr, iodefv2_intended_impact_type_t type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type = type;
}
/**
 * iodefv2_intended_impact_new_type:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 * @ret: pointer to an address where to store the created #iodefv2_intended_impact_type_t object.
 *
 * Create a new type object, children of #iodefv2_intended_impact_t.
 * If @ptr already contain a #iodefv2_intended_impact_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_intended_impact_new_type(iodefv2_intended_impact_t *ptr, iodefv2_intended_impact_type_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->type;
        return 0;
}




/**
 * iodefv2_intended_impact_get_severity:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 *
 * Get severity children of the #iodefv2_intended_impact_t object.
 *
 * Returns: a pointer to a iodefv2_intended_impact_severity_t object, or NULL if the children object is not set.
 */
iodefv2_intended_impact_severity_t *iodefv2_intended_impact_get_severity(iodefv2_intended_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->severity_is_set ? &ptr->severity : NULL;


}


/**
 * iodefv2_intended_impact_set_severity:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 * @severity: pointer to a #iodefv2_intended_impact_severity_t object.
 *
 * Set @severity object as a children of @ptr.
 * if @ptr already contain an @severity object, then it is destroyed,
 * and updated to point to the provided @severity object.
 */
void iodefv2_intended_impact_set_severity(iodefv2_intended_impact_t *ptr, iodefv2_intended_impact_severity_t severity)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity = severity;
        ptr->severity_is_set = 1;
}

void iodefv2_intended_impact_unset_severity(iodefv2_intended_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity_is_set = 0;
}
/**
 * iodefv2_intended_impact_new_severity:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 * @ret: pointer to an address where to store the created #iodefv2_intended_impact_severity_t object.
 *
 * Create a new severity object, children of #iodefv2_intended_impact_t.
 * If @ptr already contain a #iodefv2_intended_impact_severity_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_intended_impact_new_severity(iodefv2_intended_impact_t *ptr, iodefv2_intended_impact_severity_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->severity_is_set = 1;



        *ret = &ptr->severity;
        return 0;
}




/**
 * iodefv2_intended_impact_get_ext_type:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 *
 * Get ext_type children of the #iodefv2_intended_impact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_intended_impact_get_ext_type(iodefv2_intended_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_type;

}


/**
 * iodefv2_intended_impact_set_ext_type:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 * @ext_type: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_type object as a children of @ptr.
 * if @ptr already contain an @ext_type object, then it is destroyed,
 * and updated to point to the provided @ext_type object.
 */

void iodefv2_intended_impact_set_ext_type(iodefv2_intended_impact_t *ptr, libiodefv2_string_t *ext_type)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_type )
                libiodefv2_string_destroy(ptr->ext_type);

        ptr->ext_type = ext_type;
}
/**
 * iodefv2_intended_impact_new_ext_type:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_type object, children of #iodefv2_intended_impact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_intended_impact_new_ext_type(iodefv2_intended_impact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_type ) {
                retval = libiodefv2_string_new(&ptr->ext_type);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_type;
        return 0;
}




/**
 * iodefv2_intended_impact_get_description:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 *
 * Get description children of the #iodefv2_intended_impact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_intended_impact_get_description(iodefv2_intended_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_intended_impact_set_description:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_intended_impact_set_description(iodefv2_intended_impact_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_intended_impact_new_description:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_intended_impact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_intended_impact_new_description(iodefv2_intended_impact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}



/**
 * iodefv2_intended_impact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_intended_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_intended_impact_copy(const iodefv2_intended_impact_t *src, iodefv2_intended_impact_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->ext_severity ) {
                libiodefv2_string_destroy(dst->ext_severity);
                dst->ext_severity = NULL;
        }

        if ( src->ext_severity ) {
                ret = libiodefv2_string_clone(src->ext_severity, &dst->ext_severity);
                if ( ret < 0 )
                        return ret;
        }




        dst->type = src->type;



        dst->severity_is_set = src->severity_is_set;
        dst->severity = src->severity;



        if ( dst->ext_type ) {
                libiodefv2_string_destroy(dst->ext_type);
                dst->ext_type = NULL;
        }

        if ( src->ext_type ) {
                ret = libiodefv2_string_clone(src->ext_type, &dst->ext_type);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_intended_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_intended_impact_clone(iodefv2_intended_impact_t *src, iodefv2_intended_impact_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_intended_impact_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_intended_impact_copy(src, *dst);
}


/**
 * iodefv2_intended_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_intended_impact_compare(const iodefv2_intended_impact_t *obj1, const iodefv2_intended_impact_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->ext_severity, obj2->ext_severity);
        if ( ret != 0 )
                return ret;


        if ( obj1->type != obj2->type )
                return -1;


        if ( obj1->severity_is_set != obj2->severity_is_set )
                return -1;

        if ( obj1->severity_is_set && obj1->severity != obj2->severity )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_type, obj2->ext_type);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_additional_data_new:
 * @ret: Pointer where to store the created #iodefv2_additional_data_t object.
 *
 * Create a new #iodefv2_additional_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_additional_data_new(iodefv2_additional_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_ADDITIONAL_DATA;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;











        {
            int retval = iodefv2_data_new(&(*ret)->data);

            if ( retval < 0 ) {
                    iodefv2_additional_data_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }
            return 0;
}


/**
 * iodefv2_additional_data_ref:
 * @additional_data: pointer to a #iodefv2_additional_data_t object.
 *
 * Increase @additional_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @additional_data.
 */
iodefv2_additional_data_t *iodefv2_additional_data_ref(iodefv2_additional_data_t *additional_data)
{
        libiodefv2_return_val_if_fail(additional_data, NULL);
        additional_data->refcount++;

        return additional_data;
}



int _iodefv2_additional_data_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_additional_data_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_ADDITIONAL_DATA_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->name, TRUE);


            case 2:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_ADDITIONAL_DATA_TYPE , ptr->type);


            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);



            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->formatid, TRUE);



            case 5:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);



            case 6:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->meaning, TRUE);



            case 7:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_dtype, TRUE);



            case 8:

                return get_value_from_data((iodefv2_value_t **) childptr,  ptr->data, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_additional_data_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_additional_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_additional_data_new_restriction(ptr, (iodefv2_additional_data_restriction_t **) ret);

                case 1:
                    return iodefv2_additional_data_new_name(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_additional_data_new_type(ptr, (iodefv2_additional_data_type_t **) ret);

                case 3:
                    return iodefv2_additional_data_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 4:
                    return iodefv2_additional_data_new_formatid(ptr, (libiodefv2_string_t **) ret);

                case 5:
                    return iodefv2_additional_data_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 6:
                    return iodefv2_additional_data_new_meaning(ptr, (libiodefv2_string_t **) ret);

                case 7:
                    return iodefv2_additional_data_new_ext_dtype(ptr, (libiodefv2_string_t **) ret);

                case 8:
                    return iodefv2_additional_data_new_data(ptr, (iodefv2_data_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_additional_data_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_additional_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->name ) {
                                libiodefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;




                case 2:
                    ptr->type = 0;
                    return 0;




                case 3:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->formatid ) {
                                libiodefv2_string_destroy(ptr->formatid);
                                ptr->formatid = NULL;
                        }

                        return 0;




                case 5:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;




                case 6:
                        if ( ptr->meaning ) {
                                libiodefv2_string_destroy(ptr->meaning);
                                ptr->meaning = NULL;
                        }

                        return 0;




                case 7:
                        if ( ptr->ext_dtype ) {
                                libiodefv2_string_destroy(ptr->ext_dtype);
                                ptr->ext_dtype = NULL;
                        }

                        return 0;




                case 8:
                        if ( ptr->data ) {
                                iodefv2_data_destroy(ptr->data);
                                ptr->data = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_additional_data_destroy_internal(iodefv2_additional_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->name ) {
                libiodefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }





        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }



        if ( ptr->formatid ) {
                libiodefv2_string_destroy(ptr->formatid);
                ptr->formatid = NULL;
        }



        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }



        if ( ptr->meaning ) {
                libiodefv2_string_destroy(ptr->meaning);
                ptr->meaning = NULL;
        }



        if ( ptr->ext_dtype ) {
                libiodefv2_string_destroy(ptr->ext_dtype);
                ptr->ext_dtype = NULL;
        }



        if ( ptr->data ) {
                iodefv2_data_destroy(ptr->data);
                ptr->data = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_additional_data_destroy:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_additional_data_destroy(iodefv2_additional_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_additional_data_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_additional_data_get_restriction:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 *
 * Get restriction children of the #iodefv2_additional_data_t object.
 *
 * Returns: a pointer to a iodefv2_additional_data_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_additional_data_restriction_t *iodefv2_additional_data_get_restriction(iodefv2_additional_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_additional_data_set_restriction:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @restriction: pointer to a #iodefv2_additional_data_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_additional_data_set_restriction(iodefv2_additional_data_t *ptr, iodefv2_additional_data_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_additional_data_unset_restriction(iodefv2_additional_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_additional_data_new_restriction:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_additional_data_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_additional_data_t.
 * If @ptr already contain a #iodefv2_additional_data_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_additional_data_new_restriction(iodefv2_additional_data_t *ptr, iodefv2_additional_data_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_additional_data_get_name:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 *
 * Get name children of the #iodefv2_additional_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_additional_data_get_name(iodefv2_additional_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * iodefv2_additional_data_set_name:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @name: pointer to a #libiodefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void iodefv2_additional_data_set_name(iodefv2_additional_data_t *ptr, libiodefv2_string_t *name)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->name )
                libiodefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * iodefv2_additional_data_new_name:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new name object, children of #iodefv2_additional_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_additional_data_new_name(iodefv2_additional_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libiodefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}



/**
 * iodefv2_additional_data_get_type:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 *
 * Get type children of the #iodefv2_additional_data_t object.
 *
 * Returns: a pointer to a iodefv2_additional_data_type_t object, or NULL if the children object is not set.
 */
iodefv2_additional_data_type_t iodefv2_additional_data_get_type(iodefv2_additional_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type;

}


/**
 * iodefv2_additional_data_set_type:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @type: pointer to a #iodefv2_additional_data_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */
void iodefv2_additional_data_set_type(iodefv2_additional_data_t *ptr, iodefv2_additional_data_type_t type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type = type;
        ptr->_type_is_set = TRUE;

}
/**
 * iodefv2_additional_data_new_type:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_additional_data_type_t object.
 *
 * Create a new type object, children of #iodefv2_additional_data_t.
 * If @ptr already contain a #iodefv2_additional_data_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_additional_data_new_type(iodefv2_additional_data_t *ptr, iodefv2_additional_data_type_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->_type_is_set = TRUE;
        *ret = &ptr->type;
        return 0;
}




/**
 * iodefv2_additional_data_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 *
 * Get ext_restriction children of the #iodefv2_additional_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_additional_data_get_ext_restriction(iodefv2_additional_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_additional_data_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_additional_data_set_ext_restriction(iodefv2_additional_data_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_additional_data_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_additional_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_additional_data_new_ext_restriction(iodefv2_additional_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_additional_data_get_formatid:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 *
 * Get formatid children of the #iodefv2_additional_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_additional_data_get_formatid(iodefv2_additional_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->formatid;

}


/**
 * iodefv2_additional_data_set_formatid:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @formatid: pointer to a #libiodefv2_string_t object.
 *
 * Set @formatid object as a children of @ptr.
 * if @ptr already contain an @formatid object, then it is destroyed,
 * and updated to point to the provided @formatid object.
 */

void iodefv2_additional_data_set_formatid(iodefv2_additional_data_t *ptr, libiodefv2_string_t *formatid)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->formatid )
                libiodefv2_string_destroy(ptr->formatid);

        ptr->formatid = formatid;
}
/**
 * iodefv2_additional_data_new_formatid:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new formatid object, children of #iodefv2_additional_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_additional_data_new_formatid(iodefv2_additional_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->formatid ) {
                retval = libiodefv2_string_new(&ptr->formatid);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->formatid;
        return 0;
}




/**
 * iodefv2_additional_data_get_observable_id:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 *
 * Get observable_id children of the #iodefv2_additional_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_additional_data_get_observable_id(iodefv2_additional_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_additional_data_set_observable_id:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_additional_data_set_observable_id(iodefv2_additional_data_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_additional_data_new_observable_id:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_additional_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_additional_data_new_observable_id(iodefv2_additional_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}




/**
 * iodefv2_additional_data_get_meaning:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 *
 * Get meaning children of the #iodefv2_additional_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_additional_data_get_meaning(iodefv2_additional_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->meaning;

}


/**
 * iodefv2_additional_data_set_meaning:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @meaning: pointer to a #libiodefv2_string_t object.
 *
 * Set @meaning object as a children of @ptr.
 * if @ptr already contain an @meaning object, then it is destroyed,
 * and updated to point to the provided @meaning object.
 */

void iodefv2_additional_data_set_meaning(iodefv2_additional_data_t *ptr, libiodefv2_string_t *meaning)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->meaning )
                libiodefv2_string_destroy(ptr->meaning);

        ptr->meaning = meaning;
}
/**
 * iodefv2_additional_data_new_meaning:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new meaning object, children of #iodefv2_additional_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_additional_data_new_meaning(iodefv2_additional_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->meaning ) {
                retval = libiodefv2_string_new(&ptr->meaning);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->meaning;
        return 0;
}




/**
 * iodefv2_additional_data_get_ext_dtype:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 *
 * Get ext_dtype children of the #iodefv2_additional_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_additional_data_get_ext_dtype(iodefv2_additional_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_dtype;

}


/**
 * iodefv2_additional_data_set_ext_dtype:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @ext_dtype: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_dtype object as a children of @ptr.
 * if @ptr already contain an @ext_dtype object, then it is destroyed,
 * and updated to point to the provided @ext_dtype object.
 */

void iodefv2_additional_data_set_ext_dtype(iodefv2_additional_data_t *ptr, libiodefv2_string_t *ext_dtype)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_dtype )
                libiodefv2_string_destroy(ptr->ext_dtype);

        ptr->ext_dtype = ext_dtype;
}
/**
 * iodefv2_additional_data_new_ext_dtype:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_dtype object, children of #iodefv2_additional_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_additional_data_new_ext_dtype(iodefv2_additional_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_dtype ) {
                retval = libiodefv2_string_new(&ptr->ext_dtype);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_dtype;
        return 0;
}




/**
 * iodefv2_additional_data_get_data:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 *
 * Get data children of the #iodefv2_additional_data_t object.
 *
 * Returns: a pointer to a iodefv2_data_t object, or NULL if the children object is not set.
 */
iodefv2_data_t *iodefv2_additional_data_get_data(iodefv2_additional_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->data;

}


/**
 * iodefv2_additional_data_set_data:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @data: pointer to a #iodefv2_data_t object.
 *
 * Set @data object as a children of @ptr.
 * if @ptr already contain an @data object, then it is destroyed,
 * and updated to point to the provided @data object.
 */

void iodefv2_additional_data_set_data(iodefv2_additional_data_t *ptr, iodefv2_data_t *data)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->data )
                iodefv2_data_destroy(ptr->data);

        ptr->data = data;
}
/**
 * iodefv2_additional_data_new_data:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_data_t object.
 *
 * Create a new data object, children of #iodefv2_additional_data_t.
 * If @ptr already contain a #iodefv2_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_additional_data_new_data(iodefv2_additional_data_t *ptr, iodefv2_data_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->data ) {
                retval = iodefv2_data_new(&ptr->data);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->data;
        return 0;
}



/**
 * iodefv2_additional_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_additional_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_additional_data_copy(const iodefv2_additional_data_t *src, iodefv2_additional_data_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->name ) {
                libiodefv2_string_destroy(dst->name);
                dst->name = NULL;
        }

        if ( src->name ) {
                ret = libiodefv2_string_clone(src->name, &dst->name);
                if ( ret < 0 )
                        return ret;
        }




        dst->type = src->type;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->formatid ) {
                libiodefv2_string_destroy(dst->formatid);
                dst->formatid = NULL;
        }

        if ( src->formatid ) {
                ret = libiodefv2_string_clone(src->formatid, &dst->formatid);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->meaning ) {
                libiodefv2_string_destroy(dst->meaning);
                dst->meaning = NULL;
        }

        if ( src->meaning ) {
                ret = libiodefv2_string_clone(src->meaning, &dst->meaning);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->ext_dtype ) {
                libiodefv2_string_destroy(dst->ext_dtype);
                dst->ext_dtype = NULL;
        }

        if ( src->ext_dtype ) {
                ret = libiodefv2_string_clone(src->ext_dtype, &dst->ext_dtype);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->data ) {
                ret = iodefv2_data_copy(src->data, dst->data);
                if ( ret < 0 )
                        return ret;
        }
    return 0 ;
}


/**
 * iodefv2_additional_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_additional_data_clone(iodefv2_additional_data_t *src, iodefv2_additional_data_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_additional_data_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_additional_data_copy(src, *dst);
}


/**
 * iodefv2_additional_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_additional_data_compare(const iodefv2_additional_data_t *obj1, const iodefv2_additional_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;


        if ( obj1->type != obj2->type )
                return -1;

        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->formatid, obj2->formatid);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->meaning, obj2->meaning);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->ext_dtype, obj2->ext_dtype);
        if ( ret != 0 )
                return ret;

        ret = iodefv2_data_compare(obj1->data, obj2->data);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_counter_new:
 * @ret: Pointer where to store the created #iodefv2_counter_t object.
 *
 * Create a new #iodefv2_counter_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_counter_new(iodefv2_counter_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_COUNTER;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;










            return 0;
}


/**
 * iodefv2_counter_ref:
 * @counter: pointer to a #iodefv2_counter_t object.
 *
 * Increase @counter reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @counter.
 */
iodefv2_counter_t *iodefv2_counter_ref(iodefv2_counter_t *counter)
{
        libiodefv2_return_val_if_fail(counter, NULL);
        counter->refcount++;

        return counter;
}



int _iodefv2_counter_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_counter_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->meaning, TRUE);


            case 1:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_COUNTER_UNIT , ptr->unit);


            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_type, TRUE);


            case 3:

                    if ( ! ptr->duration_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_COUNTER_DURATION , ptr->duration);


            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_unit, TRUE);


            case 5:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_COUNTER_TYPE , ptr->type);


            case 6:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_duration, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_counter_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_counter_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_counter_new_meaning(ptr, (libiodefv2_string_t **) ret);

                case 1:
                    return iodefv2_counter_new_unit(ptr, (iodefv2_counter_unit_t **) ret);

                case 2:
                    return iodefv2_counter_new_ext_type(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_counter_new_duration(ptr, (iodefv2_counter_duration_t **) ret);

                case 4:
                    return iodefv2_counter_new_ext_unit(ptr, (libiodefv2_string_t **) ret);

                case 5:
                    return iodefv2_counter_new_type(ptr, (iodefv2_counter_type_t **) ret);

                case 6:
                    return iodefv2_counter_new_ext_duration(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_counter_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_counter_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->meaning ) {
                                libiodefv2_string_destroy(ptr->meaning);
                                ptr->meaning = NULL;
                        }

                        return 0;




                case 1:
                    ptr->unit = 0;
                    return 0;




                case 2:
                        if ( ptr->ext_type ) {
                                libiodefv2_string_destroy(ptr->ext_type);
                                ptr->ext_type = NULL;
                        }

                        return 0;

                case 3:
                        ptr->duration_is_set = 0;
                        return 0;




                case 4:
                        if ( ptr->ext_unit ) {
                                libiodefv2_string_destroy(ptr->ext_unit);
                                ptr->ext_unit = NULL;
                        }

                        return 0;




                case 5:
                    ptr->type = 0;
                    return 0;




                case 6:
                        if ( ptr->ext_duration ) {
                                libiodefv2_string_destroy(ptr->ext_duration);
                                ptr->ext_duration = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_counter_destroy_internal(iodefv2_counter_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->meaning ) {
                libiodefv2_string_destroy(ptr->meaning);
                ptr->meaning = NULL;
        }





        if ( ptr->ext_type ) {
                libiodefv2_string_destroy(ptr->ext_type);
                ptr->ext_type = NULL;
        }





        if ( ptr->ext_unit ) {
                libiodefv2_string_destroy(ptr->ext_unit);
                ptr->ext_unit = NULL;
        }





        if ( ptr->ext_duration ) {
                libiodefv2_string_destroy(ptr->ext_duration);
                ptr->ext_duration = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_counter_destroy:
 * @ptr: pointer to a #iodefv2_counter_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_counter_destroy(iodefv2_counter_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_counter_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_counter_get_meaning:
 * @ptr: pointer to a #iodefv2_counter_t object.
 *
 * Get meaning children of the #iodefv2_counter_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_counter_get_meaning(iodefv2_counter_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->meaning;

}


/**
 * iodefv2_counter_set_meaning:
 * @ptr: pointer to a #iodefv2_counter_t object.
 * @meaning: pointer to a #libiodefv2_string_t object.
 *
 * Set @meaning object as a children of @ptr.
 * if @ptr already contain an @meaning object, then it is destroyed,
 * and updated to point to the provided @meaning object.
 */

void iodefv2_counter_set_meaning(iodefv2_counter_t *ptr, libiodefv2_string_t *meaning)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->meaning )
                libiodefv2_string_destroy(ptr->meaning);

        ptr->meaning = meaning;
}
/**
 * iodefv2_counter_new_meaning:
 * @ptr: pointer to a #iodefv2_counter_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new meaning object, children of #iodefv2_counter_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_counter_new_meaning(iodefv2_counter_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->meaning ) {
                retval = libiodefv2_string_new(&ptr->meaning);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->meaning;
        return 0;
}



/**
 * iodefv2_counter_get_unit:
 * @ptr: pointer to a #iodefv2_counter_t object.
 *
 * Get unit children of the #iodefv2_counter_t object.
 *
 * Returns: a pointer to a iodefv2_counter_unit_t object, or NULL if the children object is not set.
 */
iodefv2_counter_unit_t iodefv2_counter_get_unit(iodefv2_counter_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->unit;

}


/**
 * iodefv2_counter_set_unit:
 * @ptr: pointer to a #iodefv2_counter_t object.
 * @unit: pointer to a #iodefv2_counter_unit_t object.
 *
 * Set @unit object as a children of @ptr.
 * if @ptr already contain an @unit object, then it is destroyed,
 * and updated to point to the provided @unit object.
 */
void iodefv2_counter_set_unit(iodefv2_counter_t *ptr, iodefv2_counter_unit_t unit)
{
        libiodefv2_return_if_fail(ptr);
        ptr->unit = unit;
}
/**
 * iodefv2_counter_new_unit:
 * @ptr: pointer to a #iodefv2_counter_t object.
 * @ret: pointer to an address where to store the created #iodefv2_counter_unit_t object.
 *
 * Create a new unit object, children of #iodefv2_counter_t.
 * If @ptr already contain a #iodefv2_counter_unit_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_counter_new_unit(iodefv2_counter_t *ptr, iodefv2_counter_unit_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->unit;
        return 0;
}




/**
 * iodefv2_counter_get_ext_type:
 * @ptr: pointer to a #iodefv2_counter_t object.
 *
 * Get ext_type children of the #iodefv2_counter_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_counter_get_ext_type(iodefv2_counter_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_type;

}


/**
 * iodefv2_counter_set_ext_type:
 * @ptr: pointer to a #iodefv2_counter_t object.
 * @ext_type: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_type object as a children of @ptr.
 * if @ptr already contain an @ext_type object, then it is destroyed,
 * and updated to point to the provided @ext_type object.
 */

void iodefv2_counter_set_ext_type(iodefv2_counter_t *ptr, libiodefv2_string_t *ext_type)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_type )
                libiodefv2_string_destroy(ptr->ext_type);

        ptr->ext_type = ext_type;
}
/**
 * iodefv2_counter_new_ext_type:
 * @ptr: pointer to a #iodefv2_counter_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_type object, children of #iodefv2_counter_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_counter_new_ext_type(iodefv2_counter_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_type ) {
                retval = libiodefv2_string_new(&ptr->ext_type);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_type;
        return 0;
}




/**
 * iodefv2_counter_get_duration:
 * @ptr: pointer to a #iodefv2_counter_t object.
 *
 * Get duration children of the #iodefv2_counter_t object.
 *
 * Returns: a pointer to a iodefv2_counter_duration_t object, or NULL if the children object is not set.
 */
iodefv2_counter_duration_t *iodefv2_counter_get_duration(iodefv2_counter_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->duration_is_set ? &ptr->duration : NULL;


}


/**
 * iodefv2_counter_set_duration:
 * @ptr: pointer to a #iodefv2_counter_t object.
 * @duration: pointer to a #iodefv2_counter_duration_t object.
 *
 * Set @duration object as a children of @ptr.
 * if @ptr already contain an @duration object, then it is destroyed,
 * and updated to point to the provided @duration object.
 */
void iodefv2_counter_set_duration(iodefv2_counter_t *ptr, iodefv2_counter_duration_t duration)
{
        libiodefv2_return_if_fail(ptr);
        ptr->duration = duration;
        ptr->duration_is_set = 1;
}

void iodefv2_counter_unset_duration(iodefv2_counter_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->duration_is_set = 0;
}
/**
 * iodefv2_counter_new_duration:
 * @ptr: pointer to a #iodefv2_counter_t object.
 * @ret: pointer to an address where to store the created #iodefv2_counter_duration_t object.
 *
 * Create a new duration object, children of #iodefv2_counter_t.
 * If @ptr already contain a #iodefv2_counter_duration_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_counter_new_duration(iodefv2_counter_t *ptr, iodefv2_counter_duration_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->duration_is_set = 1;



        *ret = &ptr->duration;
        return 0;
}




/**
 * iodefv2_counter_get_ext_unit:
 * @ptr: pointer to a #iodefv2_counter_t object.
 *
 * Get ext_unit children of the #iodefv2_counter_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_counter_get_ext_unit(iodefv2_counter_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_unit;

}


/**
 * iodefv2_counter_set_ext_unit:
 * @ptr: pointer to a #iodefv2_counter_t object.
 * @ext_unit: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_unit object as a children of @ptr.
 * if @ptr already contain an @ext_unit object, then it is destroyed,
 * and updated to point to the provided @ext_unit object.
 */

void iodefv2_counter_set_ext_unit(iodefv2_counter_t *ptr, libiodefv2_string_t *ext_unit)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_unit )
                libiodefv2_string_destroy(ptr->ext_unit);

        ptr->ext_unit = ext_unit;
}
/**
 * iodefv2_counter_new_ext_unit:
 * @ptr: pointer to a #iodefv2_counter_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_unit object, children of #iodefv2_counter_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_counter_new_ext_unit(iodefv2_counter_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_unit ) {
                retval = libiodefv2_string_new(&ptr->ext_unit);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_unit;
        return 0;
}



/**
 * iodefv2_counter_get_type:
 * @ptr: pointer to a #iodefv2_counter_t object.
 *
 * Get type children of the #iodefv2_counter_t object.
 *
 * Returns: a pointer to a iodefv2_counter_type_t object, or NULL if the children object is not set.
 */
iodefv2_counter_type_t iodefv2_counter_get_type(iodefv2_counter_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type;

}


/**
 * iodefv2_counter_set_type:
 * @ptr: pointer to a #iodefv2_counter_t object.
 * @type: pointer to a #iodefv2_counter_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */
void iodefv2_counter_set_type(iodefv2_counter_t *ptr, iodefv2_counter_type_t type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type = type;
}
/**
 * iodefv2_counter_new_type:
 * @ptr: pointer to a #iodefv2_counter_t object.
 * @ret: pointer to an address where to store the created #iodefv2_counter_type_t object.
 *
 * Create a new type object, children of #iodefv2_counter_t.
 * If @ptr already contain a #iodefv2_counter_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_counter_new_type(iodefv2_counter_t *ptr, iodefv2_counter_type_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->type;
        return 0;
}




/**
 * iodefv2_counter_get_ext_duration:
 * @ptr: pointer to a #iodefv2_counter_t object.
 *
 * Get ext_duration children of the #iodefv2_counter_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_counter_get_ext_duration(iodefv2_counter_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_duration;

}


/**
 * iodefv2_counter_set_ext_duration:
 * @ptr: pointer to a #iodefv2_counter_t object.
 * @ext_duration: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_duration object as a children of @ptr.
 * if @ptr already contain an @ext_duration object, then it is destroyed,
 * and updated to point to the provided @ext_duration object.
 */

void iodefv2_counter_set_ext_duration(iodefv2_counter_t *ptr, libiodefv2_string_t *ext_duration)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_duration )
                libiodefv2_string_destroy(ptr->ext_duration);

        ptr->ext_duration = ext_duration;
}
/**
 * iodefv2_counter_new_ext_duration:
 * @ptr: pointer to a #iodefv2_counter_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_duration object, children of #iodefv2_counter_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_counter_new_ext_duration(iodefv2_counter_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_duration ) {
                retval = libiodefv2_string_new(&ptr->ext_duration);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_duration;
        return 0;
}



/**
 * iodefv2_counter_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_counter_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_counter_copy(const iodefv2_counter_t *src, iodefv2_counter_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->meaning ) {
                libiodefv2_string_destroy(dst->meaning);
                dst->meaning = NULL;
        }

        if ( src->meaning ) {
                ret = libiodefv2_string_clone(src->meaning, &dst->meaning);
                if ( ret < 0 )
                        return ret;
        }




        dst->unit = src->unit;



        if ( dst->ext_type ) {
                libiodefv2_string_destroy(dst->ext_type);
                dst->ext_type = NULL;
        }

        if ( src->ext_type ) {
                ret = libiodefv2_string_clone(src->ext_type, &dst->ext_type);
                if ( ret < 0 )
                        return ret;
        }




        dst->duration_is_set = src->duration_is_set;
        dst->duration = src->duration;



        if ( dst->ext_unit ) {
                libiodefv2_string_destroy(dst->ext_unit);
                dst->ext_unit = NULL;
        }

        if ( src->ext_unit ) {
                ret = libiodefv2_string_clone(src->ext_unit, &dst->ext_unit);
                if ( ret < 0 )
                        return ret;
        }




        dst->type = src->type;



        if ( dst->ext_duration ) {
                libiodefv2_string_destroy(dst->ext_duration);
                dst->ext_duration = NULL;
        }

        if ( src->ext_duration ) {
                ret = libiodefv2_string_clone(src->ext_duration, &dst->ext_duration);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_counter_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_counter_clone(iodefv2_counter_t *src, iodefv2_counter_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_counter_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_counter_copy(src, *dst);
}


/**
 * iodefv2_counter_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_counter_compare(const iodefv2_counter_t *obj1, const iodefv2_counter_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->meaning, obj2->meaning);
        if ( ret != 0 )
                return ret;


        if ( obj1->unit != obj2->unit )
                return -1;

        ret = libiodefv2_string_compare(obj1->ext_type, obj2->ext_type);
        if ( ret != 0 )
                return ret;


        if ( obj1->duration_is_set != obj2->duration_is_set )
                return -1;

        if ( obj1->duration_is_set && obj1->duration != obj2->duration )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_unit, obj2->ext_unit);
        if ( ret != 0 )
                return ret;


        if ( obj1->type != obj2->type )
                return -1;

        ret = libiodefv2_string_compare(obj1->ext_duration, obj2->ext_duration);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_monetary_impact_new:
 * @ret: Pointer where to store the created #iodefv2_monetary_impact_t object.
 *
 * Create a new #iodefv2_monetary_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_monetary_impact_new(iodefv2_monetary_impact_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_MONETARY_IMPACT;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        {
            int retval = libiodefv2_string_new(&(*ret)->currency);

            if ( retval < 0 ) {
                    iodefv2_monetary_impact_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }


            return 0;
}


/**
 * iodefv2_monetary_impact_ref:
 * @monetary_impact: pointer to a #iodefv2_monetary_impact_t object.
 *
 * Increase @monetary_impact reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @monetary_impact.
 */
iodefv2_monetary_impact_t *iodefv2_monetary_impact_ref(iodefv2_monetary_impact_t *monetary_impact)
{
        libiodefv2_return_val_if_fail(monetary_impact, NULL);
        monetary_impact->refcount++;

        return monetary_impact;
}



int _iodefv2_monetary_impact_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_monetary_impact_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->currency, TRUE);


            case 1:

                    if ( ! ptr->severity_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_MONETARY_IMPACT_SEVERITY , ptr->severity);

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_monetary_impact_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_monetary_impact_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_monetary_impact_new_currency(ptr, (libiodefv2_string_t **) ret);

                case 1:
                    return iodefv2_monetary_impact_new_severity(ptr, (iodefv2_monetary_impact_severity_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_monetary_impact_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_monetary_impact_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->currency ) {
                                libiodefv2_string_destroy(ptr->currency);
                                ptr->currency = NULL;
                        }

                        return 0;

                case 1:
                        ptr->severity_is_set = 0;
                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_monetary_impact_destroy_internal(iodefv2_monetary_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->currency ) {
                libiodefv2_string_destroy(ptr->currency);
                ptr->currency = NULL;
        }




        /* free() should be done by the caller */
}


/**
 * iodefv2_monetary_impact_destroy:
 * @ptr: pointer to a #iodefv2_monetary_impact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_monetary_impact_destroy(iodefv2_monetary_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_monetary_impact_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_monetary_impact_get_currency:
 * @ptr: pointer to a #iodefv2_monetary_impact_t object.
 *
 * Get currency children of the #iodefv2_monetary_impact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_monetary_impact_get_currency(iodefv2_monetary_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->currency;

}


/**
 * iodefv2_monetary_impact_set_currency:
 * @ptr: pointer to a #iodefv2_monetary_impact_t object.
 * @currency: pointer to a #libiodefv2_string_t object.
 *
 * Set @currency object as a children of @ptr.
 * if @ptr already contain an @currency object, then it is destroyed,
 * and updated to point to the provided @currency object.
 */

void iodefv2_monetary_impact_set_currency(iodefv2_monetary_impact_t *ptr, libiodefv2_string_t *currency)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->currency )
                libiodefv2_string_destroy(ptr->currency);

        ptr->currency = currency;
}
/**
 * iodefv2_monetary_impact_new_currency:
 * @ptr: pointer to a #iodefv2_monetary_impact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new currency object, children of #iodefv2_monetary_impact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_monetary_impact_new_currency(iodefv2_monetary_impact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->currency ) {
                retval = libiodefv2_string_new(&ptr->currency);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->currency;
        return 0;
}




/**
 * iodefv2_monetary_impact_get_severity:
 * @ptr: pointer to a #iodefv2_monetary_impact_t object.
 *
 * Get severity children of the #iodefv2_monetary_impact_t object.
 *
 * Returns: a pointer to a iodefv2_monetary_impact_severity_t object, or NULL if the children object is not set.
 */
iodefv2_monetary_impact_severity_t *iodefv2_monetary_impact_get_severity(iodefv2_monetary_impact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->severity_is_set ? &ptr->severity : NULL;


}


/**
 * iodefv2_monetary_impact_set_severity:
 * @ptr: pointer to a #iodefv2_monetary_impact_t object.
 * @severity: pointer to a #iodefv2_monetary_impact_severity_t object.
 *
 * Set @severity object as a children of @ptr.
 * if @ptr already contain an @severity object, then it is destroyed,
 * and updated to point to the provided @severity object.
 */
void iodefv2_monetary_impact_set_severity(iodefv2_monetary_impact_t *ptr, iodefv2_monetary_impact_severity_t severity)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity = severity;
        ptr->severity_is_set = 1;
}

void iodefv2_monetary_impact_unset_severity(iodefv2_monetary_impact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity_is_set = 0;
}
/**
 * iodefv2_monetary_impact_new_severity:
 * @ptr: pointer to a #iodefv2_monetary_impact_t object.
 * @ret: pointer to an address where to store the created #iodefv2_monetary_impact_severity_t object.
 *
 * Create a new severity object, children of #iodefv2_monetary_impact_t.
 * If @ptr already contain a #iodefv2_monetary_impact_severity_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_monetary_impact_new_severity(iodefv2_monetary_impact_t *ptr, iodefv2_monetary_impact_severity_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->severity_is_set = 1;



        *ret = &ptr->severity;
        return 0;
}



/**
 * iodefv2_monetary_impact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_monetary_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_monetary_impact_copy(const iodefv2_monetary_impact_t *src, iodefv2_monetary_impact_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;


        if ( src->currency ) {
                ret = libiodefv2_string_copy(src->currency, dst->currency);
                if ( ret < 0 )
                        return ret;
        }



        dst->severity_is_set = src->severity_is_set;
        dst->severity = src->severity;
    return 0 ;
}


/**
 * iodefv2_monetary_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_monetary_impact_clone(iodefv2_monetary_impact_t *src, iodefv2_monetary_impact_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_monetary_impact_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_monetary_impact_copy(src, *dst);
}


/**
 * iodefv2_monetary_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_monetary_impact_compare(const iodefv2_monetary_impact_t *obj1, const iodefv2_monetary_impact_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->currency, obj2->currency);
        if ( ret != 0 )
                return ret;


        if ( obj1->severity_is_set != obj2->severity_is_set )
                return -1;

        if ( obj1->severity_is_set && obj1->severity != obj2->severity )
                return -1;

        return ret;
}


        



/**
 * iodefv2_service_name_new:
 * @ret: Pointer where to store the created #iodefv2_service_name_t object.
 *
 * Create a new #iodefv2_service_name_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_service_name_new(iodefv2_service_name_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_SERVICE_NAME;


        (*ret)->refcount = 1;



            return 0;
}


/**
 * iodefv2_service_name_ref:
 * @service_name: pointer to a #iodefv2_service_name_t object.
 *
 * Increase @service_name reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @service_name.
 */
iodefv2_service_name_t *iodefv2_service_name_ref(iodefv2_service_name_t *service_name)
{
        libiodefv2_return_val_if_fail(service_name, NULL);
        service_name->refcount++;

        return service_name;
}



int _iodefv2_service_name_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_service_name_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->url, TRUE);



            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->iana_service, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_service_name_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_service_name_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_service_name_new_url(ptr, (libiodefv2_string_t **) ret);

                case 1:
                    return iodefv2_service_name_new_iana_service(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_service_name_new_description(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_service_name_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_service_name_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->url ) {
                                libiodefv2_string_destroy(ptr->url);
                                ptr->url = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->iana_service ) {
                                libiodefv2_string_destroy(ptr->iana_service);
                                ptr->iana_service = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_service_name_destroy_internal(iodefv2_service_name_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( ptr->url ) {
                libiodefv2_string_destroy(ptr->url);
                ptr->url = NULL;
        }



        if ( ptr->iana_service ) {
                libiodefv2_string_destroy(ptr->iana_service);
                ptr->iana_service = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_service_name_destroy:
 * @ptr: pointer to a #iodefv2_service_name_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_service_name_destroy(iodefv2_service_name_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_service_name_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_service_name_get_url:
 * @ptr: pointer to a #iodefv2_service_name_t object.
 *
 * Get url children of the #iodefv2_service_name_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_service_name_get_url(iodefv2_service_name_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->url;

}


/**
 * iodefv2_service_name_set_url:
 * @ptr: pointer to a #iodefv2_service_name_t object.
 * @url: pointer to a #libiodefv2_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void iodefv2_service_name_set_url(iodefv2_service_name_t *ptr, libiodefv2_string_t *url)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->url )
                libiodefv2_string_destroy(ptr->url);

        ptr->url = url;
}
/**
 * iodefv2_service_name_new_url:
 * @ptr: pointer to a #iodefv2_service_name_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new url object, children of #iodefv2_service_name_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_service_name_new_url(iodefv2_service_name_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->url ) {
                retval = libiodefv2_string_new(&ptr->url);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->url;
        return 0;
}




/**
 * iodefv2_service_name_get_iana_service:
 * @ptr: pointer to a #iodefv2_service_name_t object.
 *
 * Get iana_service children of the #iodefv2_service_name_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_service_name_get_iana_service(iodefv2_service_name_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->iana_service;

}


/**
 * iodefv2_service_name_set_iana_service:
 * @ptr: pointer to a #iodefv2_service_name_t object.
 * @iana_service: pointer to a #libiodefv2_string_t object.
 *
 * Set @iana_service object as a children of @ptr.
 * if @ptr already contain an @iana_service object, then it is destroyed,
 * and updated to point to the provided @iana_service object.
 */

void iodefv2_service_name_set_iana_service(iodefv2_service_name_t *ptr, libiodefv2_string_t *iana_service)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->iana_service )
                libiodefv2_string_destroy(ptr->iana_service);

        ptr->iana_service = iana_service;
}
/**
 * iodefv2_service_name_new_iana_service:
 * @ptr: pointer to a #iodefv2_service_name_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new iana_service object, children of #iodefv2_service_name_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_service_name_new_iana_service(iodefv2_service_name_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->iana_service ) {
                retval = libiodefv2_string_new(&ptr->iana_service);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->iana_service;
        return 0;
}




/**
 * iodefv2_service_name_get_description:
 * @ptr: pointer to a #iodefv2_service_name_t object.
 *
 * Get description children of the #iodefv2_service_name_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_service_name_get_description(iodefv2_service_name_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_service_name_set_description:
 * @ptr: pointer to a #iodefv2_service_name_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_service_name_set_description(iodefv2_service_name_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_service_name_new_description:
 * @ptr: pointer to a #iodefv2_service_name_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_service_name_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_service_name_new_description(iodefv2_service_name_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}



/**
 * iodefv2_service_name_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_service_name_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_service_name_copy(const iodefv2_service_name_t *src, iodefv2_service_name_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->url ) {
                libiodefv2_string_destroy(dst->url);
                dst->url = NULL;
        }

        if ( src->url ) {
                ret = libiodefv2_string_clone(src->url, &dst->url);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->iana_service ) {
                libiodefv2_string_destroy(dst->iana_service);
                dst->iana_service = NULL;
        }

        if ( src->iana_service ) {
                ret = libiodefv2_string_clone(src->iana_service, &dst->iana_service);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_service_name_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_service_name_clone(iodefv2_service_name_t *src, iodefv2_service_name_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_service_name_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_service_name_copy(src, *dst);
}


/**
 * iodefv2_service_name_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_service_name_compare(const iodefv2_service_name_t *obj1, const iodefv2_service_name_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->url, obj2->url);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->iana_service, obj2->iana_service);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_indicator_id_new:
 * @ret: Pointer where to store the created #iodefv2_indicator_id_t object.
 *
 * Create a new #iodefv2_indicator_id_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_indicator_id_new(iodefv2_indicator_id_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_INDICATOR_ID;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;


            return 0;
}


/**
 * iodefv2_indicator_id_ref:
 * @indicator_id: pointer to a #iodefv2_indicator_id_t object.
 *
 * Increase @indicator_id reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @indicator_id.
 */
iodefv2_indicator_id_t *iodefv2_indicator_id_ref(iodefv2_indicator_id_t *indicator_id)
{
        libiodefv2_return_val_if_fail(indicator_id, NULL);
        indicator_id->refcount++;

        return indicator_id;
}



int _iodefv2_indicator_id_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_indicator_id_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->version, TRUE);



            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->name, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_indicator_id_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_indicator_id_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_indicator_id_new_version(ptr, (libiodefv2_string_t **) ret);

                case 1:
                    return iodefv2_indicator_id_new_name(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_indicator_id_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_indicator_id_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->version ) {
                                libiodefv2_string_destroy(ptr->version);
                                ptr->version = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->name ) {
                                libiodefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_indicator_id_destroy_internal(iodefv2_indicator_id_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->version ) {
                libiodefv2_string_destroy(ptr->version);
                ptr->version = NULL;
        }



        if ( ptr->name ) {
                libiodefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_indicator_id_destroy:
 * @ptr: pointer to a #iodefv2_indicator_id_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_indicator_id_destroy(iodefv2_indicator_id_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_indicator_id_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_indicator_id_get_version:
 * @ptr: pointer to a #iodefv2_indicator_id_t object.
 *
 * Get version children of the #iodefv2_indicator_id_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_indicator_id_get_version(iodefv2_indicator_id_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->version;

}


/**
 * iodefv2_indicator_id_set_version:
 * @ptr: pointer to a #iodefv2_indicator_id_t object.
 * @version: pointer to a #libiodefv2_string_t object.
 *
 * Set @version object as a children of @ptr.
 * if @ptr already contain an @version object, then it is destroyed,
 * and updated to point to the provided @version object.
 */

void iodefv2_indicator_id_set_version(iodefv2_indicator_id_t *ptr, libiodefv2_string_t *version)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->version )
                libiodefv2_string_destroy(ptr->version);

        ptr->version = version;
}
/**
 * iodefv2_indicator_id_new_version:
 * @ptr: pointer to a #iodefv2_indicator_id_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new version object, children of #iodefv2_indicator_id_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_id_new_version(iodefv2_indicator_id_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->version ) {
                retval = libiodefv2_string_new(&ptr->version);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->version;
        return 0;
}




/**
 * iodefv2_indicator_id_get_name:
 * @ptr: pointer to a #iodefv2_indicator_id_t object.
 *
 * Get name children of the #iodefv2_indicator_id_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_indicator_id_get_name(iodefv2_indicator_id_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * iodefv2_indicator_id_set_name:
 * @ptr: pointer to a #iodefv2_indicator_id_t object.
 * @name: pointer to a #libiodefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void iodefv2_indicator_id_set_name(iodefv2_indicator_id_t *ptr, libiodefv2_string_t *name)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->name )
                libiodefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * iodefv2_indicator_id_new_name:
 * @ptr: pointer to a #iodefv2_indicator_id_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new name object, children of #iodefv2_indicator_id_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_id_new_name(iodefv2_indicator_id_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libiodefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}



/**
 * iodefv2_indicator_id_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_indicator_id_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_indicator_id_copy(const iodefv2_indicator_id_t *src, iodefv2_indicator_id_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->version ) {
                libiodefv2_string_destroy(dst->version);
                dst->version = NULL;
        }

        if ( src->version ) {
                ret = libiodefv2_string_clone(src->version, &dst->version);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->name ) {
                libiodefv2_string_destroy(dst->name);
                dst->name = NULL;
        }

        if ( src->name ) {
                ret = libiodefv2_string_clone(src->name, &dst->name);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_indicator_id_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_indicator_id_clone(iodefv2_indicator_id_t *src, iodefv2_indicator_id_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_indicator_id_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_indicator_id_copy(src, *dst);
}


/**
 * iodefv2_indicator_id_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_indicator_id_compare(const iodefv2_indicator_id_t *obj1, const iodefv2_indicator_id_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->version, obj2->version);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_signature_data_new:
 * @ret: Pointer where to store the created #iodefv2_signature_data_t object.
 *
 * Create a new #iodefv2_signature_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_signature_data_new(iodefv2_signature_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_SIGNATURE_DATA;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

            return 0;
}


/**
 * iodefv2_signature_data_ref:
 * @signature_data: pointer to a #iodefv2_signature_data_t object.
 *
 * Increase @signature_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @signature_data.
 */
iodefv2_signature_data_t *iodefv2_signature_data_ref(iodefv2_signature_data_t *signature_data)
{
        libiodefv2_return_val_if_fail(signature_data, NULL);
        signature_data->refcount++;

        return signature_data;
}



int _iodefv2_signature_data_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_signature_data_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->signature, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_signature_data_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_signature_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_signature_data_new_signature(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_signature_data_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_signature_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->signature ) {
                                libiodefv2_string_destroy(ptr->signature);
                                ptr->signature = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_signature_data_destroy_internal(iodefv2_signature_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->signature ) {
                libiodefv2_string_destroy(ptr->signature);
                ptr->signature = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_signature_data_destroy:
 * @ptr: pointer to a #iodefv2_signature_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_signature_data_destroy(iodefv2_signature_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_signature_data_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_signature_data_get_signature:
 * @ptr: pointer to a #iodefv2_signature_data_t object.
 *
 * Get signature children of the #iodefv2_signature_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_signature_data_get_signature(iodefv2_signature_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->signature;

}


/**
 * iodefv2_signature_data_set_signature:
 * @ptr: pointer to a #iodefv2_signature_data_t object.
 * @signature: pointer to a #libiodefv2_string_t object.
 *
 * Set @signature object as a children of @ptr.
 * if @ptr already contain an @signature object, then it is destroyed,
 * and updated to point to the provided @signature object.
 */

void iodefv2_signature_data_set_signature(iodefv2_signature_data_t *ptr, libiodefv2_string_t *signature)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->signature )
                libiodefv2_string_destroy(ptr->signature);

        ptr->signature = signature;
}
/**
 * iodefv2_signature_data_new_signature:
 * @ptr: pointer to a #iodefv2_signature_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new signature object, children of #iodefv2_signature_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_signature_data_new_signature(iodefv2_signature_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->signature ) {
                retval = libiodefv2_string_new(&ptr->signature);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->signature;
        return 0;
}



/**
 * iodefv2_signature_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_signature_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_signature_data_copy(const iodefv2_signature_data_t *src, iodefv2_signature_data_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->signature ) {
                libiodefv2_string_destroy(dst->signature);
                dst->signature = NULL;
        }

        if ( src->signature ) {
                ret = libiodefv2_string_clone(src->signature, &dst->signature);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_signature_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_signature_data_clone(iodefv2_signature_data_t *src, iodefv2_signature_data_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_signature_data_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_signature_data_copy(src, *dst);
}


/**
 * iodefv2_signature_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_signature_data_compare(const iodefv2_signature_data_t *obj1, const iodefv2_signature_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->signature, obj2->signature);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_address_new:
 * @ret: Pointer where to store the created #iodefv2_address_t object.
 *
 * Create a new #iodefv2_address_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_address_new(iodefv2_address_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_ADDRESS;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;






            return 0;
}


/**
 * iodefv2_address_ref:
 * @address: pointer to a #iodefv2_address_t object.
 *
 * Increase @address reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @address.
 */
iodefv2_address_t *iodefv2_address_ref(iodefv2_address_t *address)
{
        libiodefv2_return_val_if_fail(address, NULL);
        address->refcount++;

        return address;
}



int _iodefv2_address_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_address_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_ADDRESS_CATEGORY , ptr->category);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->vlan_name, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_category, TRUE);



            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->vlan_num, TRUE);



            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_address_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_address_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_address_new_category(ptr, (iodefv2_address_category_t **) ret);

                case 1:
                    return iodefv2_address_new_vlan_name(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_address_new_ext_category(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_address_new_vlan_num(ptr, (libiodefv2_string_t **) ret);

                case 4:
                    return iodefv2_address_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_address_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_address_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->category = 0;
                    return 0;




                case 1:
                        if ( ptr->vlan_name ) {
                                libiodefv2_string_destroy(ptr->vlan_name);
                                ptr->vlan_name = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->ext_category ) {
                                libiodefv2_string_destroy(ptr->ext_category);
                                ptr->ext_category = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->vlan_num ) {
                                libiodefv2_string_destroy(ptr->vlan_num);
                                ptr->vlan_num = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_address_destroy_internal(iodefv2_address_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->vlan_name ) {
                libiodefv2_string_destroy(ptr->vlan_name);
                ptr->vlan_name = NULL;
        }



        if ( ptr->ext_category ) {
                libiodefv2_string_destroy(ptr->ext_category);
                ptr->ext_category = NULL;
        }



        if ( ptr->vlan_num ) {
                libiodefv2_string_destroy(ptr->vlan_num);
                ptr->vlan_num = NULL;
        }



        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_address_destroy:
 * @ptr: pointer to a #iodefv2_address_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_address_destroy(iodefv2_address_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_address_destroy_internal(ptr);
        free(ptr);
}




/**
 * iodefv2_address_get_category:
 * @ptr: pointer to a #iodefv2_address_t object.
 *
 * Get category children of the #iodefv2_address_t object.
 *
 * Returns: a pointer to a iodefv2_address_category_t object, or NULL if the children object is not set.
 */
iodefv2_address_category_t iodefv2_address_get_category(iodefv2_address_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->category;

}


/**
 * iodefv2_address_set_category:
 * @ptr: pointer to a #iodefv2_address_t object.
 * @category: pointer to a #iodefv2_address_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */
void iodefv2_address_set_category(iodefv2_address_t *ptr, iodefv2_address_category_t category)
{
        libiodefv2_return_if_fail(ptr);
        ptr->category = category;
}
/**
 * iodefv2_address_new_category:
 * @ptr: pointer to a #iodefv2_address_t object.
 * @ret: pointer to an address where to store the created #iodefv2_address_category_t object.
 *
 * Create a new category object, children of #iodefv2_address_t.
 * If @ptr already contain a #iodefv2_address_category_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_address_new_category(iodefv2_address_t *ptr, iodefv2_address_category_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->category;
        return 0;
}




/**
 * iodefv2_address_get_vlan_name:
 * @ptr: pointer to a #iodefv2_address_t object.
 *
 * Get vlan_name children of the #iodefv2_address_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_address_get_vlan_name(iodefv2_address_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->vlan_name;

}


/**
 * iodefv2_address_set_vlan_name:
 * @ptr: pointer to a #iodefv2_address_t object.
 * @vlan_name: pointer to a #libiodefv2_string_t object.
 *
 * Set @vlan_name object as a children of @ptr.
 * if @ptr already contain an @vlan_name object, then it is destroyed,
 * and updated to point to the provided @vlan_name object.
 */

void iodefv2_address_set_vlan_name(iodefv2_address_t *ptr, libiodefv2_string_t *vlan_name)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->vlan_name )
                libiodefv2_string_destroy(ptr->vlan_name);

        ptr->vlan_name = vlan_name;
}
/**
 * iodefv2_address_new_vlan_name:
 * @ptr: pointer to a #iodefv2_address_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new vlan_name object, children of #iodefv2_address_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_address_new_vlan_name(iodefv2_address_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->vlan_name ) {
                retval = libiodefv2_string_new(&ptr->vlan_name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->vlan_name;
        return 0;
}




/**
 * iodefv2_address_get_ext_category:
 * @ptr: pointer to a #iodefv2_address_t object.
 *
 * Get ext_category children of the #iodefv2_address_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_address_get_ext_category(iodefv2_address_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_category;

}


/**
 * iodefv2_address_set_ext_category:
 * @ptr: pointer to a #iodefv2_address_t object.
 * @ext_category: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_category object as a children of @ptr.
 * if @ptr already contain an @ext_category object, then it is destroyed,
 * and updated to point to the provided @ext_category object.
 */

void iodefv2_address_set_ext_category(iodefv2_address_t *ptr, libiodefv2_string_t *ext_category)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_category )
                libiodefv2_string_destroy(ptr->ext_category);

        ptr->ext_category = ext_category;
}
/**
 * iodefv2_address_new_ext_category:
 * @ptr: pointer to a #iodefv2_address_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_category object, children of #iodefv2_address_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_address_new_ext_category(iodefv2_address_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_category ) {
                retval = libiodefv2_string_new(&ptr->ext_category);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_category;
        return 0;
}




/**
 * iodefv2_address_get_vlan_num:
 * @ptr: pointer to a #iodefv2_address_t object.
 *
 * Get vlan_num children of the #iodefv2_address_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_address_get_vlan_num(iodefv2_address_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->vlan_num;

}


/**
 * iodefv2_address_set_vlan_num:
 * @ptr: pointer to a #iodefv2_address_t object.
 * @vlan_num: pointer to a #libiodefv2_string_t object.
 *
 * Set @vlan_num object as a children of @ptr.
 * if @ptr already contain an @vlan_num object, then it is destroyed,
 * and updated to point to the provided @vlan_num object.
 */

void iodefv2_address_set_vlan_num(iodefv2_address_t *ptr, libiodefv2_string_t *vlan_num)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->vlan_num )
                libiodefv2_string_destroy(ptr->vlan_num);

        ptr->vlan_num = vlan_num;
}
/**
 * iodefv2_address_new_vlan_num:
 * @ptr: pointer to a #iodefv2_address_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new vlan_num object, children of #iodefv2_address_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_address_new_vlan_num(iodefv2_address_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->vlan_num ) {
                retval = libiodefv2_string_new(&ptr->vlan_num);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->vlan_num;
        return 0;
}




/**
 * iodefv2_address_get_observable_id:
 * @ptr: pointer to a #iodefv2_address_t object.
 *
 * Get observable_id children of the #iodefv2_address_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_address_get_observable_id(iodefv2_address_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_address_set_observable_id:
 * @ptr: pointer to a #iodefv2_address_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_address_set_observable_id(iodefv2_address_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_address_new_observable_id:
 * @ptr: pointer to a #iodefv2_address_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_address_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_address_new_observable_id(iodefv2_address_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}



/**
 * iodefv2_address_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_address_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_address_copy(const iodefv2_address_t *src, iodefv2_address_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->category = src->category;



        if ( dst->vlan_name ) {
                libiodefv2_string_destroy(dst->vlan_name);
                dst->vlan_name = NULL;
        }

        if ( src->vlan_name ) {
                ret = libiodefv2_string_clone(src->vlan_name, &dst->vlan_name);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->ext_category ) {
                libiodefv2_string_destroy(dst->ext_category);
                dst->ext_category = NULL;
        }

        if ( src->ext_category ) {
                ret = libiodefv2_string_clone(src->ext_category, &dst->ext_category);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->vlan_num ) {
                libiodefv2_string_destroy(dst->vlan_num);
                dst->vlan_num = NULL;
        }

        if ( src->vlan_num ) {
                ret = libiodefv2_string_clone(src->vlan_num, &dst->vlan_num);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_address_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_address_clone(iodefv2_address_t *src, iodefv2_address_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_address_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_address_copy(src, *dst);
}


/**
 * iodefv2_address_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_address_compare(const iodefv2_address_t *obj1, const iodefv2_address_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->category != obj2->category )
                return -1;

        ret = libiodefv2_string_compare(obj1->vlan_name, obj2->vlan_name);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->ext_category, obj2->ext_category);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->vlan_num, obj2->vlan_num);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_application_header_new:
 * @ret: Pointer where to store the created #iodefv2_application_header_t object.
 *
 * Create a new #iodefv2_application_header_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_application_header_new(iodefv2_application_header_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_APPLICATION_HEADER;


        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);



            return 0;
}


/**
 * iodefv2_application_header_ref:
 * @application_header: pointer to a #iodefv2_application_header_t object.
 *
 * Increase @application_header reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @application_header.
 */
iodefv2_application_header_t *iodefv2_application_header_ref(iodefv2_application_header_t *application_header)
{
        libiodefv2_return_val_if_fail(application_header, NULL);
        application_header->refcount++;

        return application_header;
}



int _iodefv2_application_header_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_application_header_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:
                *childptr = &ptr->additional_data_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_application_header_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_application_header_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_application_header_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_application_header_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_application_header_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_application_header_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
    
                case 0: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_application_header_destroy_internal(iodefv2_application_header_t *ptr)
{
        libiodefv2_return_if_fail(ptr);


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_application_header_destroy:
 * @ptr: pointer to a #iodefv2_application_header_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_application_header_destroy(iodefv2_application_header_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_application_header_destroy_internal(ptr);
        free(ptr);
}






/**
 * iodefv2_application_header_get_next_additional_data:
 * @application_header: pointer to a #iodefv2_application_header_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_application_header_get_next_additional_data(iodefv2_application_header_t *application_header, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(application_header, NULL);

        libiodefv2_list_for_each_continue(&application_header->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_application_header_set_additional_data:
 * @ptr: pointer to a #iodefv2_application_header_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_application_header_set_additional_data(iodefv2_application_header_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_application_header_new_additional_data:
 *  @ptr: pointer to a #iodefv2_application_header_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_application_header_new_additional_data(iodefv2_application_header_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_application_header_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_application_header_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_application_header_copy(const iodefv2_application_header_t *src, iodefv2_application_header_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_application_header_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_application_header_clone(iodefv2_application_header_t *src, iodefv2_application_header_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_application_header_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_application_header_copy(src, *dst);
}


/**
 * iodefv2_application_header_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_application_header_compare(const iodefv2_application_header_t *obj1, const iodefv2_application_header_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_certificate_data_new:
 * @ret: Pointer where to store the created #iodefv2_certificate_data_t object.
 *
 * Create a new #iodefv2_certificate_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_certificate_data_new(iodefv2_certificate_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_CERTIFICATE_DATA;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->certificate_list);







            return 0;
}


/**
 * iodefv2_certificate_data_ref:
 * @certificate_data: pointer to a #iodefv2_certificate_data_t object.
 *
 * Increase @certificate_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @certificate_data.
 */
iodefv2_certificate_data_t *iodefv2_certificate_data_ref(iodefv2_certificate_data_t *certificate_data)
{
        libiodefv2_return_val_if_fail(certificate_data, NULL);
        certificate_data->refcount++;

        return certificate_data;
}



int _iodefv2_certificate_data_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_certificate_data_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_CERTIFICATE_DATA_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);


            case 3:
                *childptr = &ptr->certificate_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_certificate_data_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_certificate_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_certificate_data_new_restriction(ptr, (iodefv2_certificate_data_restriction_t **) ret);

                case 1:
                    return iodefv2_certificate_data_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_certificate_data_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 3: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_certificate_data_new_certificate(ptr, (iodefv2_certificate_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->certificate_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->certificate_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_certificate_data_new_certificate(ptr, (iodefv2_certificate_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_certificate_data_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_certificate_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;

    
                case 3: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->certificate_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_certificate_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->certificate_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_certificate_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_certificate_data_destroy_internal(iodefv2_certificate_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }



        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_certificate_t *entry;

                libiodefv2_list_for_each_safe(&ptr->certificate_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_certificate_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_certificate_data_destroy:
 * @ptr: pointer to a #iodefv2_certificate_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_certificate_data_destroy(iodefv2_certificate_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_certificate_data_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_certificate_data_get_restriction:
 * @ptr: pointer to a #iodefv2_certificate_data_t object.
 *
 * Get restriction children of the #iodefv2_certificate_data_t object.
 *
 * Returns: a pointer to a iodefv2_certificate_data_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_certificate_data_restriction_t *iodefv2_certificate_data_get_restriction(iodefv2_certificate_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_certificate_data_set_restriction:
 * @ptr: pointer to a #iodefv2_certificate_data_t object.
 * @restriction: pointer to a #iodefv2_certificate_data_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_certificate_data_set_restriction(iodefv2_certificate_data_t *ptr, iodefv2_certificate_data_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_certificate_data_unset_restriction(iodefv2_certificate_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_certificate_data_new_restriction:
 * @ptr: pointer to a #iodefv2_certificate_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_certificate_data_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_certificate_data_t.
 * If @ptr already contain a #iodefv2_certificate_data_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_certificate_data_new_restriction(iodefv2_certificate_data_t *ptr, iodefv2_certificate_data_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_certificate_data_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_certificate_data_t object.
 *
 * Get ext_restriction children of the #iodefv2_certificate_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_certificate_data_get_ext_restriction(iodefv2_certificate_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_certificate_data_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_certificate_data_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_certificate_data_set_ext_restriction(iodefv2_certificate_data_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_certificate_data_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_certificate_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_certificate_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_certificate_data_new_ext_restriction(iodefv2_certificate_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_certificate_data_get_observable_id:
 * @ptr: pointer to a #iodefv2_certificate_data_t object.
 *
 * Get observable_id children of the #iodefv2_certificate_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_certificate_data_get_observable_id(iodefv2_certificate_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_certificate_data_set_observable_id:
 * @ptr: pointer to a #iodefv2_certificate_data_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_certificate_data_set_observable_id(iodefv2_certificate_data_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_certificate_data_new_observable_id:
 * @ptr: pointer to a #iodefv2_certificate_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_certificate_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_certificate_data_new_observable_id(iodefv2_certificate_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}





/**
 * iodefv2_certificate_data_get_next_certificate:
 * @certificate_data: pointer to a #iodefv2_certificate_data_t object.
 * @certificate_cur: pointer to a #iodefv2_certificate_t object.
 *
 * Get the next #iodefv2_certificate_t object listed in @ptr.
 * When iterating over the iodefv2_certificate_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_certificate_t object.
 *
 * Returns: the next #iodefv2_certificate_t in the list.
 */
iodefv2_certificate_t *iodefv2_certificate_data_get_next_certificate(iodefv2_certificate_data_t *certificate_data, iodefv2_certificate_t *certificate_cur)
{
        libiodefv2_list_t *tmp = (certificate_cur) ? &((libiodefv2_linked_object_t *) certificate_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(certificate_data, NULL);

        libiodefv2_list_for_each_continue(&certificate_data->certificate_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_certificate_data_set_certificate:
 * @ptr: pointer to a #iodefv2_certificate_data_t object.
 * @object: pointer to a #iodefv2_certificate_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_certificate_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_certificate_data_set_certificate(iodefv2_certificate_data_t *ptr, iodefv2_certificate_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->certificate_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_certificate_data_new_certificate:
 *  @ptr: pointer to a #iodefv2_certificate_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_certificate_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_certificate_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_certificate_t object. The created #iodefv2_certificate_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_certificate_data_new_certificate(iodefv2_certificate_data_t *ptr, iodefv2_certificate_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_certificate_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->certificate_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_certificate_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_certificate_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_certificate_data_copy(const iodefv2_certificate_data_t *src, iodefv2_certificate_data_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_certificate_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->certificate_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_certificate_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->certificate_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_certificate_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->certificate_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_certificate_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_certificate_data_clone(iodefv2_certificate_data_t *src, iodefv2_certificate_data_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_certificate_data_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_certificate_data_copy(src, *dst);
}


/**
 * iodefv2_certificate_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_certificate_data_compare(const iodefv2_certificate_data_t *obj1, const iodefv2_certificate_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_certificate_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->certificate_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->certificate_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_certificate_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_threat_actor_new:
 * @ret: Pointer where to store the created #iodefv2_threat_actor_t object.
 *
 * Create a new #iodefv2_threat_actor_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_threat_actor_new(iodefv2_threat_actor_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_THREAT_ACTOR;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);









            return 0;
}


/**
 * iodefv2_threat_actor_ref:
 * @threat_actor: pointer to a #iodefv2_threat_actor_t object.
 *
 * Increase @threat_actor reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @threat_actor.
 */
iodefv2_threat_actor_t *iodefv2_threat_actor_ref(iodefv2_threat_actor_t *threat_actor)
{
        libiodefv2_return_val_if_fail(threat_actor, NULL);
        threat_actor->refcount++;

        return threat_actor;
}



int _iodefv2_threat_actor_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_threat_actor_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_THREAT_ACTOR_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->url, TRUE);



            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->threat_actor_id, TRUE);



            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            case 5:
                *childptr = &ptr->additional_data_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_threat_actor_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_threat_actor_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_threat_actor_new_restriction(ptr, (iodefv2_threat_actor_restriction_t **) ret);

                case 1:
                    return iodefv2_threat_actor_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_threat_actor_new_url(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_threat_actor_new_threat_actor_id(ptr, (libiodefv2_string_t **) ret);

                case 4:
                    return iodefv2_threat_actor_new_description(ptr, (libiodefv2_string_t **) ret);

                case 5: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_threat_actor_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_threat_actor_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_threat_actor_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_threat_actor_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->url ) {
                                libiodefv2_string_destroy(ptr->url);
                                ptr->url = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->threat_actor_id ) {
                                libiodefv2_string_destroy(ptr->threat_actor_id);
                                ptr->threat_actor_id = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

    
                case 5: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_threat_actor_destroy_internal(iodefv2_threat_actor_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }



        if ( ptr->url ) {
                libiodefv2_string_destroy(ptr->url);
                ptr->url = NULL;
        }



        if ( ptr->threat_actor_id ) {
                libiodefv2_string_destroy(ptr->threat_actor_id);
                ptr->threat_actor_id = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_threat_actor_destroy:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_threat_actor_destroy(iodefv2_threat_actor_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_threat_actor_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_threat_actor_get_restriction:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 *
 * Get restriction children of the #iodefv2_threat_actor_t object.
 *
 * Returns: a pointer to a iodefv2_threat_actor_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_threat_actor_restriction_t *iodefv2_threat_actor_get_restriction(iodefv2_threat_actor_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_threat_actor_set_restriction:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 * @restriction: pointer to a #iodefv2_threat_actor_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_threat_actor_set_restriction(iodefv2_threat_actor_t *ptr, iodefv2_threat_actor_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_threat_actor_unset_restriction(iodefv2_threat_actor_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_threat_actor_new_restriction:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 * @ret: pointer to an address where to store the created #iodefv2_threat_actor_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_threat_actor_t.
 * If @ptr already contain a #iodefv2_threat_actor_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_threat_actor_new_restriction(iodefv2_threat_actor_t *ptr, iodefv2_threat_actor_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_threat_actor_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 *
 * Get ext_restriction children of the #iodefv2_threat_actor_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_threat_actor_get_ext_restriction(iodefv2_threat_actor_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_threat_actor_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_threat_actor_set_ext_restriction(iodefv2_threat_actor_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_threat_actor_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_threat_actor_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_threat_actor_new_ext_restriction(iodefv2_threat_actor_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_threat_actor_get_url:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 *
 * Get url children of the #iodefv2_threat_actor_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_threat_actor_get_url(iodefv2_threat_actor_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->url;

}


/**
 * iodefv2_threat_actor_set_url:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 * @url: pointer to a #libiodefv2_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void iodefv2_threat_actor_set_url(iodefv2_threat_actor_t *ptr, libiodefv2_string_t *url)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->url )
                libiodefv2_string_destroy(ptr->url);

        ptr->url = url;
}
/**
 * iodefv2_threat_actor_new_url:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new url object, children of #iodefv2_threat_actor_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_threat_actor_new_url(iodefv2_threat_actor_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->url ) {
                retval = libiodefv2_string_new(&ptr->url);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->url;
        return 0;
}




/**
 * iodefv2_threat_actor_get_threat_actor_id:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 *
 * Get threat_actor_id children of the #iodefv2_threat_actor_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_threat_actor_get_threat_actor_id(iodefv2_threat_actor_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->threat_actor_id;

}


/**
 * iodefv2_threat_actor_set_threat_actor_id:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 * @threat_actor_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @threat_actor_id object as a children of @ptr.
 * if @ptr already contain an @threat_actor_id object, then it is destroyed,
 * and updated to point to the provided @threat_actor_id object.
 */

void iodefv2_threat_actor_set_threat_actor_id(iodefv2_threat_actor_t *ptr, libiodefv2_string_t *threat_actor_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->threat_actor_id )
                libiodefv2_string_destroy(ptr->threat_actor_id);

        ptr->threat_actor_id = threat_actor_id;
}
/**
 * iodefv2_threat_actor_new_threat_actor_id:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new threat_actor_id object, children of #iodefv2_threat_actor_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_threat_actor_new_threat_actor_id(iodefv2_threat_actor_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->threat_actor_id ) {
                retval = libiodefv2_string_new(&ptr->threat_actor_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->threat_actor_id;
        return 0;
}




/**
 * iodefv2_threat_actor_get_description:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 *
 * Get description children of the #iodefv2_threat_actor_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_threat_actor_get_description(iodefv2_threat_actor_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_threat_actor_set_description:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_threat_actor_set_description(iodefv2_threat_actor_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_threat_actor_new_description:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_threat_actor_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_threat_actor_new_description(iodefv2_threat_actor_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}





/**
 * iodefv2_threat_actor_get_next_additional_data:
 * @threat_actor: pointer to a #iodefv2_threat_actor_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_threat_actor_get_next_additional_data(iodefv2_threat_actor_t *threat_actor, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(threat_actor, NULL);

        libiodefv2_list_for_each_continue(&threat_actor->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_threat_actor_set_additional_data:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_threat_actor_set_additional_data(iodefv2_threat_actor_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_threat_actor_new_additional_data:
 *  @ptr: pointer to a #iodefv2_threat_actor_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_threat_actor_new_additional_data(iodefv2_threat_actor_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_threat_actor_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_threat_actor_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_threat_actor_copy(const iodefv2_threat_actor_t *src, iodefv2_threat_actor_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->url ) {
                libiodefv2_string_destroy(dst->url);
                dst->url = NULL;
        }

        if ( src->url ) {
                ret = libiodefv2_string_clone(src->url, &dst->url);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->threat_actor_id ) {
                libiodefv2_string_destroy(dst->threat_actor_id);
                dst->threat_actor_id = NULL;
        }

        if ( src->threat_actor_id ) {
                ret = libiodefv2_string_clone(src->threat_actor_id, &dst->threat_actor_id);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_threat_actor_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_threat_actor_clone(iodefv2_threat_actor_t *src, iodefv2_threat_actor_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_threat_actor_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_threat_actor_copy(src, *dst);
}


/**
 * iodefv2_threat_actor_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_threat_actor_compare(const iodefv2_threat_actor_t *obj1, const iodefv2_threat_actor_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->url, obj2->url);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->threat_actor_id, obj2->threat_actor_id);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_method_new:
 * @ret: Pointer where to store the created #iodefv2_method_t object.
 *
 * Create a new #iodefv2_method_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_method_new(iodefv2_method_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_METHOD;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);


        libiodefv2_list_init(&(*ret)->reference_list);









            return 0;
}


/**
 * iodefv2_method_ref:
 * @method: pointer to a #iodefv2_method_t object.
 *
 * Increase @method reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @method.
 */
iodefv2_method_t *iodefv2_method_ref(iodefv2_method_t *method)
{
        libiodefv2_return_val_if_fail(method, NULL);
        method->refcount++;

        return method;
}



int _iodefv2_method_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_method_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_METHOD_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);


            case 2:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            case 4:
                *childptr = &ptr->reference_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_method_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_method_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_method_new_restriction(ptr, (iodefv2_method_restriction_t **) ret);

                case 1:
                    return iodefv2_method_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_method_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_method_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 3:
                    return iodefv2_method_new_description(ptr, (libiodefv2_string_t **) ret);

                case 4: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_method_new_reference(ptr, (iodefv2_reference_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->reference_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->reference_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_method_new_reference(ptr, (iodefv2_reference_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_method_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_method_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;

    
                case 2: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 3:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

    
                case 4: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->reference_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_reference_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->reference_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_reference_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_method_destroy_internal(iodefv2_method_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }

        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_reference_t *entry;

                libiodefv2_list_for_each_safe(&ptr->reference_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_reference_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_method_destroy:
 * @ptr: pointer to a #iodefv2_method_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_method_destroy(iodefv2_method_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_method_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_method_get_restriction:
 * @ptr: pointer to a #iodefv2_method_t object.
 *
 * Get restriction children of the #iodefv2_method_t object.
 *
 * Returns: a pointer to a iodefv2_method_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_method_restriction_t *iodefv2_method_get_restriction(iodefv2_method_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_method_set_restriction:
 * @ptr: pointer to a #iodefv2_method_t object.
 * @restriction: pointer to a #iodefv2_method_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_method_set_restriction(iodefv2_method_t *ptr, iodefv2_method_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_method_unset_restriction(iodefv2_method_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_method_new_restriction:
 * @ptr: pointer to a #iodefv2_method_t object.
 * @ret: pointer to an address where to store the created #iodefv2_method_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_method_t.
 * If @ptr already contain a #iodefv2_method_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_method_new_restriction(iodefv2_method_t *ptr, iodefv2_method_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_method_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_method_t object.
 *
 * Get ext_restriction children of the #iodefv2_method_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_method_get_ext_restriction(iodefv2_method_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_method_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_method_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_method_set_ext_restriction(iodefv2_method_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_method_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_method_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_method_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_method_new_ext_restriction(iodefv2_method_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}





/**
 * iodefv2_method_get_next_additional_data:
 * @method: pointer to a #iodefv2_method_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_method_get_next_additional_data(iodefv2_method_t *method, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(method, NULL);

        libiodefv2_list_for_each_continue(&method->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_method_set_additional_data:
 * @ptr: pointer to a #iodefv2_method_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_method_set_additional_data(iodefv2_method_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_method_new_additional_data:
 *  @ptr: pointer to a #iodefv2_method_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_method_new_additional_data(iodefv2_method_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_method_get_description:
 * @ptr: pointer to a #iodefv2_method_t object.
 *
 * Get description children of the #iodefv2_method_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_method_get_description(iodefv2_method_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_method_set_description:
 * @ptr: pointer to a #iodefv2_method_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_method_set_description(iodefv2_method_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_method_new_description:
 * @ptr: pointer to a #iodefv2_method_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_method_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_method_new_description(iodefv2_method_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}





/**
 * iodefv2_method_get_next_reference:
 * @method: pointer to a #iodefv2_method_t object.
 * @reference_cur: pointer to a #iodefv2_reference_t object.
 *
 * Get the next #iodefv2_reference_t object listed in @ptr.
 * When iterating over the iodefv2_reference_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_reference_t object.
 *
 * Returns: the next #iodefv2_reference_t in the list.
 */
iodefv2_reference_t *iodefv2_method_get_next_reference(iodefv2_method_t *method, iodefv2_reference_t *reference_cur)
{
        libiodefv2_list_t *tmp = (reference_cur) ? &((libiodefv2_linked_object_t *) reference_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(method, NULL);

        libiodefv2_list_for_each_continue(&method->reference_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_method_set_reference:
 * @ptr: pointer to a #iodefv2_method_t object.
 * @object: pointer to a #iodefv2_reference_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_reference_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_method_set_reference(iodefv2_method_t *ptr, iodefv2_reference_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->reference_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_method_new_reference:
 *  @ptr: pointer to a #iodefv2_method_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_reference_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_reference_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_reference_t object. The created #iodefv2_reference_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_method_new_reference(iodefv2_method_t *ptr, iodefv2_reference_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_reference_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->reference_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_method_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_method_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_method_copy(const iodefv2_method_t *src, iodefv2_method_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_reference_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->reference_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_reference_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->reference_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_reference_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->reference_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_method_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_method_clone(iodefv2_method_t *src, iodefv2_method_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_method_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_method_copy(src, *dst);
}


/**
 * iodefv2_method_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_method_compare(const iodefv2_method_t *obj1, const iodefv2_method_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_reference_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->reference_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->reference_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_reference_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_alternative_id_new:
 * @ret: Pointer where to store the created #iodefv2_alternative_id_t object.
 *
 * Create a new #iodefv2_alternative_id_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_alternative_id_new(iodefv2_alternative_id_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_ALTERNATIVE_ID;


        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->incident_id_list);






            return 0;
}


/**
 * iodefv2_alternative_id_ref:
 * @alternative_id: pointer to a #iodefv2_alternative_id_t object.
 *
 * Increase @alternative_id reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @alternative_id.
 */
iodefv2_alternative_id_t *iodefv2_alternative_id_ref(iodefv2_alternative_id_t *alternative_id)
{
        libiodefv2_return_val_if_fail(alternative_id, NULL);
        alternative_id->refcount++;

        return alternative_id;
}



int _iodefv2_alternative_id_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_alternative_id_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_ALTERNATIVE_ID_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);


            case 2:
                *childptr = &ptr->incident_id_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_alternative_id_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_alternative_id_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_alternative_id_new_restriction(ptr, (iodefv2_alternative_id_restriction_t **) ret);

                case 1:
                    return iodefv2_alternative_id_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_alternative_id_new_incident_id(ptr, (iodefv2_incident_id_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->incident_id_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->incident_id_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_alternative_id_new_incident_id(ptr, (iodefv2_incident_id_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_alternative_id_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_alternative_id_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;

    
                case 2: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->incident_id_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_incident_id_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->incident_id_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_incident_id_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_alternative_id_destroy_internal(iodefv2_alternative_id_t *ptr)
{
        libiodefv2_return_if_fail(ptr);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_incident_id_t *entry;

                libiodefv2_list_for_each_safe(&ptr->incident_id_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_incident_id_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_alternative_id_destroy:
 * @ptr: pointer to a #iodefv2_alternative_id_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_alternative_id_destroy(iodefv2_alternative_id_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_alternative_id_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_alternative_id_get_restriction:
 * @ptr: pointer to a #iodefv2_alternative_id_t object.
 *
 * Get restriction children of the #iodefv2_alternative_id_t object.
 *
 * Returns: a pointer to a iodefv2_alternative_id_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_alternative_id_restriction_t *iodefv2_alternative_id_get_restriction(iodefv2_alternative_id_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_alternative_id_set_restriction:
 * @ptr: pointer to a #iodefv2_alternative_id_t object.
 * @restriction: pointer to a #iodefv2_alternative_id_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_alternative_id_set_restriction(iodefv2_alternative_id_t *ptr, iodefv2_alternative_id_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_alternative_id_unset_restriction(iodefv2_alternative_id_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_alternative_id_new_restriction:
 * @ptr: pointer to a #iodefv2_alternative_id_t object.
 * @ret: pointer to an address where to store the created #iodefv2_alternative_id_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_alternative_id_t.
 * If @ptr already contain a #iodefv2_alternative_id_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_alternative_id_new_restriction(iodefv2_alternative_id_t *ptr, iodefv2_alternative_id_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_alternative_id_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_alternative_id_t object.
 *
 * Get ext_restriction children of the #iodefv2_alternative_id_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_alternative_id_get_ext_restriction(iodefv2_alternative_id_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_alternative_id_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_alternative_id_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_alternative_id_set_ext_restriction(iodefv2_alternative_id_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_alternative_id_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_alternative_id_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_alternative_id_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_alternative_id_new_ext_restriction(iodefv2_alternative_id_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}





/**
 * iodefv2_alternative_id_get_next_incident_id:
 * @alternative_id: pointer to a #iodefv2_alternative_id_t object.
 * @incident_id_cur: pointer to a #iodefv2_incident_id_t object.
 *
 * Get the next #iodefv2_incident_id_t object listed in @ptr.
 * When iterating over the iodefv2_incident_id_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_incident_id_t object.
 *
 * Returns: the next #iodefv2_incident_id_t in the list.
 */
iodefv2_incident_id_t *iodefv2_alternative_id_get_next_incident_id(iodefv2_alternative_id_t *alternative_id, iodefv2_incident_id_t *incident_id_cur)
{
        libiodefv2_list_t *tmp = (incident_id_cur) ? &((libiodefv2_linked_object_t *) incident_id_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(alternative_id, NULL);

        libiodefv2_list_for_each_continue(&alternative_id->incident_id_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_alternative_id_set_incident_id:
 * @ptr: pointer to a #iodefv2_alternative_id_t object.
 * @object: pointer to a #iodefv2_incident_id_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_incident_id_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_alternative_id_set_incident_id(iodefv2_alternative_id_t *ptr, iodefv2_incident_id_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->incident_id_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_alternative_id_new_incident_id:
 *  @ptr: pointer to a #iodefv2_alternative_id_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_incident_id_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_incident_id_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_incident_id_t object. The created #iodefv2_incident_id_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_alternative_id_new_incident_id(iodefv2_alternative_id_t *ptr, iodefv2_incident_id_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_incident_id_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->incident_id_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_alternative_id_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_alternative_id_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_alternative_id_copy(const iodefv2_alternative_id_t *src, iodefv2_alternative_id_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_incident_id_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->incident_id_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_incident_id_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->incident_id_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_incident_id_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->incident_id_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_alternative_id_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_alternative_id_clone(iodefv2_alternative_id_t *src, iodefv2_alternative_id_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_alternative_id_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_alternative_id_copy(src, *dst);
}


/**
 * iodefv2_alternative_id_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_alternative_id_compare(const iodefv2_alternative_id_t *obj1, const iodefv2_alternative_id_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_incident_id_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->incident_id_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->incident_id_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_incident_id_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_software_new:
 * @ret: Pointer where to store the created #iodefv2_software_t object.
 *
 * Create a new #iodefv2_software_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_software_new(iodefv2_software_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_SOFTWARE;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;




            return 0;
}


/**
 * iodefv2_software_ref:
 * @software: pointer to a #iodefv2_software_t object.
 *
 * Increase @software reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @software.
 */
iodefv2_software_t *iodefv2_software_ref(iodefv2_software_t *software)
{
        libiodefv2_return_val_if_fail(software, NULL);
        software->refcount++;

        return software;
}



int _iodefv2_software_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_software_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->url, TRUE);



            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);



            case 2:
                *childptr = ptr->software_reference;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_software_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_software_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_software_new_url(ptr, (libiodefv2_string_t **) ret);

                case 1:
                    return iodefv2_software_new_description(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_software_new_software_reference(ptr, (iodefv2_software_reference_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_software_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_software_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->url ) {
                                libiodefv2_string_destroy(ptr->url);
                                ptr->url = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->software_reference ) {
                                iodefv2_software_reference_destroy(ptr->software_reference);
                                ptr->software_reference = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_software_destroy_internal(iodefv2_software_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->url ) {
                libiodefv2_string_destroy(ptr->url);
                ptr->url = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }




        if ( ptr->software_reference ) {
                iodefv2_software_reference_destroy(ptr->software_reference);
                ptr->software_reference = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_software_destroy:
 * @ptr: pointer to a #iodefv2_software_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_software_destroy(iodefv2_software_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_software_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_software_get_url:
 * @ptr: pointer to a #iodefv2_software_t object.
 *
 * Get url children of the #iodefv2_software_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_software_get_url(iodefv2_software_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->url;

}


/**
 * iodefv2_software_set_url:
 * @ptr: pointer to a #iodefv2_software_t object.
 * @url: pointer to a #libiodefv2_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void iodefv2_software_set_url(iodefv2_software_t *ptr, libiodefv2_string_t *url)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->url )
                libiodefv2_string_destroy(ptr->url);

        ptr->url = url;
}
/**
 * iodefv2_software_new_url:
 * @ptr: pointer to a #iodefv2_software_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new url object, children of #iodefv2_software_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_software_new_url(iodefv2_software_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->url ) {
                retval = libiodefv2_string_new(&ptr->url);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->url;
        return 0;
}




/**
 * iodefv2_software_get_description:
 * @ptr: pointer to a #iodefv2_software_t object.
 *
 * Get description children of the #iodefv2_software_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_software_get_description(iodefv2_software_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_software_set_description:
 * @ptr: pointer to a #iodefv2_software_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_software_set_description(iodefv2_software_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_software_new_description:
 * @ptr: pointer to a #iodefv2_software_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_software_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_software_new_description(iodefv2_software_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}




/**
 * iodefv2_software_get_software_reference:
 * @ptr: pointer to a #iodefv2_software_t object.
 *
 * Get software_reference children of the #iodefv2_software_t object.
 *
 * Returns: a pointer to a iodefv2_software_reference_t object, or NULL if the children object is not set.
 */
iodefv2_software_reference_t *iodefv2_software_get_software_reference(iodefv2_software_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->software_reference;

}


/**
 * iodefv2_software_set_software_reference:
 * @ptr: pointer to a #iodefv2_software_t object.
 * @software_reference: pointer to a #iodefv2_software_reference_t object.
 *
 * Set @software_reference object as a children of @ptr.
 * if @ptr already contain an @software_reference object, then it is destroyed,
 * and updated to point to the provided @software_reference object.
 */

void iodefv2_software_set_software_reference(iodefv2_software_t *ptr, iodefv2_software_reference_t *software_reference)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->software_reference )
                iodefv2_software_reference_destroy(ptr->software_reference);

        ptr->software_reference = software_reference;
}
/**
 * iodefv2_software_new_software_reference:
 * @ptr: pointer to a #iodefv2_software_t object.
 * @ret: pointer to an address where to store the created #iodefv2_software_reference_t object.
 *
 * Create a new software_reference object, children of #iodefv2_software_t.
 * If @ptr already contain a #iodefv2_software_reference_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_software_new_software_reference(iodefv2_software_t *ptr, iodefv2_software_reference_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->software_reference ) {
                retval = iodefv2_software_reference_new(&ptr->software_reference);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->software_reference;
        return 0;
}



/**
 * iodefv2_software_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_software_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_software_copy(const iodefv2_software_t *src, iodefv2_software_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->url ) {
                libiodefv2_string_destroy(dst->url);
                dst->url = NULL;
        }

        if ( src->url ) {
                ret = libiodefv2_string_clone(src->url, &dst->url);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->software_reference ) {
                iodefv2_software_reference_destroy(dst->software_reference);
                dst->software_reference = NULL;
        }

        if ( src->software_reference ) {
                ret = iodefv2_software_reference_clone(src->software_reference, &dst->software_reference);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_software_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_software_clone(iodefv2_software_t *src, iodefv2_software_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_software_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_software_copy(src, *dst);
}


/**
 * iodefv2_software_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_software_compare(const iodefv2_software_t *obj1, const iodefv2_software_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->url, obj2->url);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_software_reference_compare(obj1->software_reference, obj2->software_reference);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_nameservers_new:
 * @ret: Pointer where to store the created #iodefv2_nameservers_t object.
 *
 * Create a new #iodefv2_nameservers_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_nameservers_new(iodefv2_nameservers_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_NAMESERVERS;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->address_list);




        {
            int retval = libiodefv2_string_new(&(*ret)->server);

            if ( retval < 0 ) {
                    iodefv2_nameservers_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }
            return 0;
}


/**
 * iodefv2_nameservers_ref:
 * @nameservers: pointer to a #iodefv2_nameservers_t object.
 *
 * Increase @nameservers reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @nameservers.
 */
iodefv2_nameservers_t *iodefv2_nameservers_ref(iodefv2_nameservers_t *nameservers)
{
        libiodefv2_return_val_if_fail(nameservers, NULL);
        nameservers->refcount++;

        return nameservers;
}



int _iodefv2_nameservers_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_nameservers_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:
                *childptr = &ptr->address_list;
                return 0;


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->server, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_nameservers_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_nameservers_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_nameservers_new_address(ptr, (iodefv2_address_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->address_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->address_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_nameservers_new_address(ptr, (iodefv2_address_t **) ret, n);
                }

                case 1:
                    return iodefv2_nameservers_new_server(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_nameservers_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_nameservers_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
    
                case 0: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->address_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_address_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->address_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_address_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 1:
                        if ( ptr->server ) {
                                libiodefv2_string_destroy(ptr->server);
                                ptr->server = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_nameservers_destroy_internal(iodefv2_nameservers_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_address_t *entry;

                libiodefv2_list_for_each_safe(&ptr->address_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_address_destroy(entry);
                }
        }

        if ( ptr->server ) {
                libiodefv2_string_destroy(ptr->server);
                ptr->server = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_nameservers_destroy:
 * @ptr: pointer to a #iodefv2_nameservers_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_nameservers_destroy(iodefv2_nameservers_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_nameservers_destroy_internal(ptr);
        free(ptr);
}






/**
 * iodefv2_nameservers_get_next_address:
 * @nameservers: pointer to a #iodefv2_nameservers_t object.
 * @address_cur: pointer to a #iodefv2_address_t object.
 *
 * Get the next #iodefv2_address_t object listed in @ptr.
 * When iterating over the iodefv2_address_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_address_t object.
 *
 * Returns: the next #iodefv2_address_t in the list.
 */
iodefv2_address_t *iodefv2_nameservers_get_next_address(iodefv2_nameservers_t *nameservers, iodefv2_address_t *address_cur)
{
        libiodefv2_list_t *tmp = (address_cur) ? &((libiodefv2_linked_object_t *) address_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(nameservers, NULL);

        libiodefv2_list_for_each_continue(&nameservers->address_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_nameservers_set_address:
 * @ptr: pointer to a #iodefv2_nameservers_t object.
 * @object: pointer to a #iodefv2_address_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_address_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_nameservers_set_address(iodefv2_nameservers_t *ptr, iodefv2_address_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->address_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_nameservers_new_address:
 *  @ptr: pointer to a #iodefv2_nameservers_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_address_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_address_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_address_t object. The created #iodefv2_address_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_nameservers_new_address(iodefv2_nameservers_t *ptr, iodefv2_address_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_address_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->address_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_nameservers_get_server:
 * @ptr: pointer to a #iodefv2_nameservers_t object.
 *
 * Get server children of the #iodefv2_nameservers_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_nameservers_get_server(iodefv2_nameservers_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->server;

}


/**
 * iodefv2_nameservers_set_server:
 * @ptr: pointer to a #iodefv2_nameservers_t object.
 * @server: pointer to a #libiodefv2_string_t object.
 *
 * Set @server object as a children of @ptr.
 * if @ptr already contain an @server object, then it is destroyed,
 * and updated to point to the provided @server object.
 */

void iodefv2_nameservers_set_server(iodefv2_nameservers_t *ptr, libiodefv2_string_t *server)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->server )
                libiodefv2_string_destroy(ptr->server);

        ptr->server = server;
}
/**
 * iodefv2_nameservers_new_server:
 * @ptr: pointer to a #iodefv2_nameservers_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new server object, children of #iodefv2_nameservers_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_nameservers_new_server(iodefv2_nameservers_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->server ) {
                retval = libiodefv2_string_new(&ptr->server);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->server;
        return 0;
}



/**
 * iodefv2_nameservers_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_nameservers_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_nameservers_copy(const iodefv2_nameservers_t *src, iodefv2_nameservers_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_address_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->address_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_address_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->address_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_address_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->address_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }


        if ( src->server ) {
                ret = libiodefv2_string_copy(src->server, dst->server);
                if ( ret < 0 )
                        return ret;
        }
    return 0 ;
}


/**
 * iodefv2_nameservers_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_nameservers_clone(iodefv2_nameservers_t *src, iodefv2_nameservers_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_nameservers_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_nameservers_copy(src, *dst);
}


/**
 * iodefv2_nameservers_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_nameservers_compare(const iodefv2_nameservers_t *obj1, const iodefv2_nameservers_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_address_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->address_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->address_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_address_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->server, obj2->server);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_windows_registry_keys_modified_new:
 * @ret: Pointer where to store the created #iodefv2_windows_registry_keys_modified_t object.
 *
 * Create a new #iodefv2_windows_registry_keys_modified_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_windows_registry_keys_modified_new(iodefv2_windows_registry_keys_modified_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_WINDOWS_REGISTRY_KEYS_MODIFIED;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->key_list);




            return 0;
}


/**
 * iodefv2_windows_registry_keys_modified_ref:
 * @windows_registry_keys_modified: pointer to a #iodefv2_windows_registry_keys_modified_t object.
 *
 * Increase @windows_registry_keys_modified reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @windows_registry_keys_modified.
 */
iodefv2_windows_registry_keys_modified_t *iodefv2_windows_registry_keys_modified_ref(iodefv2_windows_registry_keys_modified_t *windows_registry_keys_modified)
{
        libiodefv2_return_val_if_fail(windows_registry_keys_modified, NULL);
        windows_registry_keys_modified->refcount++;

        return windows_registry_keys_modified;
}



int _iodefv2_windows_registry_keys_modified_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_windows_registry_keys_modified_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);


            case 1:
                *childptr = &ptr->key_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_windows_registry_keys_modified_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_windows_registry_keys_modified_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_windows_registry_keys_modified_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 1: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_windows_registry_keys_modified_new_key(ptr, (iodefv2_key_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->key_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->key_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_windows_registry_keys_modified_new_key(ptr, (iodefv2_key_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_windows_registry_keys_modified_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_windows_registry_keys_modified_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;

    
                case 1: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->key_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_key_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->key_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_key_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_windows_registry_keys_modified_destroy_internal(iodefv2_windows_registry_keys_modified_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_key_t *entry;

                libiodefv2_list_for_each_safe(&ptr->key_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_key_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_windows_registry_keys_modified_destroy:
 * @ptr: pointer to a #iodefv2_windows_registry_keys_modified_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_windows_registry_keys_modified_destroy(iodefv2_windows_registry_keys_modified_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_windows_registry_keys_modified_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_windows_registry_keys_modified_get_observable_id:
 * @ptr: pointer to a #iodefv2_windows_registry_keys_modified_t object.
 *
 * Get observable_id children of the #iodefv2_windows_registry_keys_modified_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_windows_registry_keys_modified_get_observable_id(iodefv2_windows_registry_keys_modified_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_windows_registry_keys_modified_set_observable_id:
 * @ptr: pointer to a #iodefv2_windows_registry_keys_modified_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_windows_registry_keys_modified_set_observable_id(iodefv2_windows_registry_keys_modified_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_windows_registry_keys_modified_new_observable_id:
 * @ptr: pointer to a #iodefv2_windows_registry_keys_modified_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_windows_registry_keys_modified_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_windows_registry_keys_modified_new_observable_id(iodefv2_windows_registry_keys_modified_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}





/**
 * iodefv2_windows_registry_keys_modified_get_next_key:
 * @windows_registry_keys_modified: pointer to a #iodefv2_windows_registry_keys_modified_t object.
 * @key_cur: pointer to a #iodefv2_key_t object.
 *
 * Get the next #iodefv2_key_t object listed in @ptr.
 * When iterating over the iodefv2_key_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_key_t object.
 *
 * Returns: the next #iodefv2_key_t in the list.
 */
iodefv2_key_t *iodefv2_windows_registry_keys_modified_get_next_key(iodefv2_windows_registry_keys_modified_t *windows_registry_keys_modified, iodefv2_key_t *key_cur)
{
        libiodefv2_list_t *tmp = (key_cur) ? &((libiodefv2_linked_object_t *) key_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(windows_registry_keys_modified, NULL);

        libiodefv2_list_for_each_continue(&windows_registry_keys_modified->key_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_windows_registry_keys_modified_set_key:
 * @ptr: pointer to a #iodefv2_windows_registry_keys_modified_t object.
 * @object: pointer to a #iodefv2_key_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_key_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_windows_registry_keys_modified_set_key(iodefv2_windows_registry_keys_modified_t *ptr, iodefv2_key_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->key_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_windows_registry_keys_modified_new_key:
 *  @ptr: pointer to a #iodefv2_windows_registry_keys_modified_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_key_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_key_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_key_t object. The created #iodefv2_key_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_windows_registry_keys_modified_new_key(iodefv2_windows_registry_keys_modified_t *ptr, iodefv2_key_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_key_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->key_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_windows_registry_keys_modified_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_windows_registry_keys_modified_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_windows_registry_keys_modified_copy(const iodefv2_windows_registry_keys_modified_t *src, iodefv2_windows_registry_keys_modified_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_key_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->key_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_key_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->key_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_key_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->key_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_windows_registry_keys_modified_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_windows_registry_keys_modified_clone(iodefv2_windows_registry_keys_modified_t *src, iodefv2_windows_registry_keys_modified_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_windows_registry_keys_modified_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_windows_registry_keys_modified_copy(src, *dst);
}


/**
 * iodefv2_windows_registry_keys_modified_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_windows_registry_keys_modified_compare(const iodefv2_windows_registry_keys_modified_t *obj1, const iodefv2_windows_registry_keys_modified_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_key_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->key_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->key_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_key_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_campaign_new:
 * @ret: Pointer where to store the created #iodefv2_campaign_t object.
 *
 * Create a new #iodefv2_campaign_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_campaign_new(iodefv2_campaign_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_CAMPAIGN;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);









            return 0;
}


/**
 * iodefv2_campaign_ref:
 * @campaign: pointer to a #iodefv2_campaign_t object.
 *
 * Increase @campaign reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @campaign.
 */
iodefv2_campaign_t *iodefv2_campaign_ref(iodefv2_campaign_t *campaign)
{
        libiodefv2_return_val_if_fail(campaign, NULL);
        campaign->refcount++;

        return campaign;
}



int _iodefv2_campaign_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_campaign_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_CAMPAIGN_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->url, TRUE);


            case 3:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);



            case 5:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->campaign_id, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_campaign_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_campaign_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_campaign_new_restriction(ptr, (iodefv2_campaign_restriction_t **) ret);

                case 1:
                    return iodefv2_campaign_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_campaign_new_url(ptr, (libiodefv2_string_t **) ret);

                case 3: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_campaign_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_campaign_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 4:
                    return iodefv2_campaign_new_description(ptr, (libiodefv2_string_t **) ret);

                case 5:
                    return iodefv2_campaign_new_campaign_id(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_campaign_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_campaign_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->url ) {
                                libiodefv2_string_destroy(ptr->url);
                                ptr->url = NULL;
                        }

                        return 0;

    
                case 3: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 4:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;




                case 5:
                        if ( ptr->campaign_id ) {
                                libiodefv2_string_destroy(ptr->campaign_id);
                                ptr->campaign_id = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_campaign_destroy_internal(iodefv2_campaign_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }



        if ( ptr->url ) {
                libiodefv2_string_destroy(ptr->url);
                ptr->url = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }

        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }



        if ( ptr->campaign_id ) {
                libiodefv2_string_destroy(ptr->campaign_id);
                ptr->campaign_id = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_campaign_destroy:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_campaign_destroy(iodefv2_campaign_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_campaign_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_campaign_get_restriction:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 *
 * Get restriction children of the #iodefv2_campaign_t object.
 *
 * Returns: a pointer to a iodefv2_campaign_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_campaign_restriction_t *iodefv2_campaign_get_restriction(iodefv2_campaign_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_campaign_set_restriction:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 * @restriction: pointer to a #iodefv2_campaign_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_campaign_set_restriction(iodefv2_campaign_t *ptr, iodefv2_campaign_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_campaign_unset_restriction(iodefv2_campaign_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_campaign_new_restriction:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 * @ret: pointer to an address where to store the created #iodefv2_campaign_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_campaign_t.
 * If @ptr already contain a #iodefv2_campaign_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_campaign_new_restriction(iodefv2_campaign_t *ptr, iodefv2_campaign_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_campaign_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 *
 * Get ext_restriction children of the #iodefv2_campaign_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_campaign_get_ext_restriction(iodefv2_campaign_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_campaign_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_campaign_set_ext_restriction(iodefv2_campaign_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_campaign_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_campaign_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_campaign_new_ext_restriction(iodefv2_campaign_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_campaign_get_url:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 *
 * Get url children of the #iodefv2_campaign_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_campaign_get_url(iodefv2_campaign_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->url;

}


/**
 * iodefv2_campaign_set_url:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 * @url: pointer to a #libiodefv2_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void iodefv2_campaign_set_url(iodefv2_campaign_t *ptr, libiodefv2_string_t *url)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->url )
                libiodefv2_string_destroy(ptr->url);

        ptr->url = url;
}
/**
 * iodefv2_campaign_new_url:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new url object, children of #iodefv2_campaign_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_campaign_new_url(iodefv2_campaign_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->url ) {
                retval = libiodefv2_string_new(&ptr->url);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->url;
        return 0;
}





/**
 * iodefv2_campaign_get_next_additional_data:
 * @campaign: pointer to a #iodefv2_campaign_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_campaign_get_next_additional_data(iodefv2_campaign_t *campaign, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(campaign, NULL);

        libiodefv2_list_for_each_continue(&campaign->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_campaign_set_additional_data:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_campaign_set_additional_data(iodefv2_campaign_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_campaign_new_additional_data:
 *  @ptr: pointer to a #iodefv2_campaign_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_campaign_new_additional_data(iodefv2_campaign_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_campaign_get_description:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 *
 * Get description children of the #iodefv2_campaign_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_campaign_get_description(iodefv2_campaign_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_campaign_set_description:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_campaign_set_description(iodefv2_campaign_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_campaign_new_description:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_campaign_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_campaign_new_description(iodefv2_campaign_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}




/**
 * iodefv2_campaign_get_campaign_id:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 *
 * Get campaign_id children of the #iodefv2_campaign_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_campaign_get_campaign_id(iodefv2_campaign_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->campaign_id;

}


/**
 * iodefv2_campaign_set_campaign_id:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 * @campaign_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @campaign_id object as a children of @ptr.
 * if @ptr already contain an @campaign_id object, then it is destroyed,
 * and updated to point to the provided @campaign_id object.
 */

void iodefv2_campaign_set_campaign_id(iodefv2_campaign_t *ptr, libiodefv2_string_t *campaign_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->campaign_id )
                libiodefv2_string_destroy(ptr->campaign_id);

        ptr->campaign_id = campaign_id;
}
/**
 * iodefv2_campaign_new_campaign_id:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new campaign_id object, children of #iodefv2_campaign_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_campaign_new_campaign_id(iodefv2_campaign_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->campaign_id ) {
                retval = libiodefv2_string_new(&ptr->campaign_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->campaign_id;
        return 0;
}



/**
 * iodefv2_campaign_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_campaign_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_campaign_copy(const iodefv2_campaign_t *src, iodefv2_campaign_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->url ) {
                libiodefv2_string_destroy(dst->url);
                dst->url = NULL;
        }

        if ( src->url ) {
                ret = libiodefv2_string_clone(src->url, &dst->url);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->campaign_id ) {
                libiodefv2_string_destroy(dst->campaign_id);
                dst->campaign_id = NULL;
        }

        if ( src->campaign_id ) {
                ret = libiodefv2_string_clone(src->campaign_id, &dst->campaign_id);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_campaign_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_campaign_clone(iodefv2_campaign_t *src, iodefv2_campaign_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_campaign_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_campaign_copy(src, *dst);
}


/**
 * iodefv2_campaign_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_campaign_compare(const iodefv2_campaign_t *obj1, const iodefv2_campaign_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->url, obj2->url);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->campaign_id, obj2->campaign_id);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_assessment_new:
 * @ret: Pointer where to store the created #iodefv2_assessment_t object.
 *
 * Create a new #iodefv2_assessment_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_assessment_new(iodefv2_assessment_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_ASSESSMENT;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->intended_impact_list);


        libiodefv2_list_init(&(*ret)->time_impact_list);


        libiodefv2_list_init(&(*ret)->additional_data_list);


        libiodefv2_list_init(&(*ret)->monetary_impact_list);


        libiodefv2_list_init(&(*ret)->counter_list);


        libiodefv2_list_init(&(*ret)->system_impact_list);


        libiodefv2_list_init(&(*ret)->business_impact_list);


























            return 0;
}


/**
 * iodefv2_assessment_ref:
 * @assessment: pointer to a #iodefv2_assessment_t object.
 *
 * Increase @assessment reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @assessment.
 */
iodefv2_assessment_t *iodefv2_assessment_ref(iodefv2_assessment_t *assessment)
{
        libiodefv2_return_val_if_fail(assessment, NULL);
        assessment->refcount++;

        return assessment;
}



int _iodefv2_assessment_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_assessment_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_ASSESSMENT_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);


            case 2:

                    if ( ! ptr->occurrence_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_ASSESSMENT_OCCURRENCE , ptr->occurrence);


            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);


            case 4:
                *childptr = &ptr->intended_impact_list;
                return 0;


            case 5:
                *childptr = ptr->confidence;
                return 0;

            case 6:
                *childptr = &ptr->time_impact_list;
                return 0;

            case 7:
                *childptr = &ptr->additional_data_list;
                return 0;

            case 8:
                *childptr = &ptr->monetary_impact_list;
                return 0;

            case 9:
                *childptr = &ptr->counter_list;
                return 0;

            case 10:
                *childptr = &ptr->system_impact_list;
                return 0;

            case 11:
                *childptr = &ptr->business_impact_list;
                return 0;


            case 12:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->incident_category, TRUE);



            case 13:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->mitigating_factor, TRUE);



            case 14:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->cause, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_assessment_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_assessment_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_assessment_new_restriction(ptr, (iodefv2_assessment_restriction_t **) ret);

                case 1:
                    return iodefv2_assessment_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_assessment_new_occurrence(ptr, (iodefv2_assessment_occurrence_t **) ret);

                case 3:
                    return iodefv2_assessment_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 4: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_assessment_new_intended_impact(ptr, (iodefv2_intended_impact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->intended_impact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->intended_impact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_assessment_new_intended_impact(ptr, (iodefv2_intended_impact_t **) ret, n);
                }

                case 5:
                    return iodefv2_assessment_new_confidence(ptr, (iodefv2_confidence_t **) ret);

                case 6: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_assessment_new_time_impact(ptr, (iodefv2_time_impact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->time_impact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->time_impact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_assessment_new_time_impact(ptr, (iodefv2_time_impact_t **) ret, n);
                }

                case 7: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_assessment_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_assessment_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 8: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_assessment_new_monetary_impact(ptr, (iodefv2_monetary_impact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->monetary_impact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->monetary_impact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_assessment_new_monetary_impact(ptr, (iodefv2_monetary_impact_t **) ret, n);
                }

                case 9: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_assessment_new_counter(ptr, (iodefv2_counter_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->counter_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->counter_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_assessment_new_counter(ptr, (iodefv2_counter_t **) ret, n);
                }

                case 10: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_assessment_new_system_impact(ptr, (iodefv2_system_impact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->system_impact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->system_impact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_assessment_new_system_impact(ptr, (iodefv2_system_impact_t **) ret, n);
                }

                case 11: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_assessment_new_business_impact(ptr, (iodefv2_business_impact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->business_impact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->business_impact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_assessment_new_business_impact(ptr, (iodefv2_business_impact_t **) ret, n);
                }

                case 12:
                    return iodefv2_assessment_new_incident_category(ptr, (libiodefv2_string_t **) ret);

                case 13:
                    return iodefv2_assessment_new_mitigating_factor(ptr, (libiodefv2_string_t **) ret);

                case 14:
                    return iodefv2_assessment_new_cause(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_assessment_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_assessment_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;

                case 2:
                        ptr->occurrence_is_set = 0;
                        return 0;




                case 3:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;

    
                case 4: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->intended_impact_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_intended_impact_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->intended_impact_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_intended_impact_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 5:
                        if ( ptr->confidence ) {
                                iodefv2_confidence_destroy(ptr->confidence);
                                ptr->confidence = NULL;
                        }

                        return 0;

    
                case 6: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->time_impact_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_time_impact_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->time_impact_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_time_impact_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 7: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 8: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->monetary_impact_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_monetary_impact_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->monetary_impact_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_monetary_impact_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 9: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->counter_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_counter_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->counter_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_counter_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 10: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->system_impact_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_system_impact_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->system_impact_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_system_impact_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 11: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->business_impact_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_business_impact_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->business_impact_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_business_impact_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 12:
                        if ( ptr->incident_category ) {
                                libiodefv2_string_destroy(ptr->incident_category);
                                ptr->incident_category = NULL;
                        }

                        return 0;




                case 13:
                        if ( ptr->mitigating_factor ) {
                                libiodefv2_string_destroy(ptr->mitigating_factor);
                                ptr->mitigating_factor = NULL;
                        }

                        return 0;




                case 14:
                        if ( ptr->cause ) {
                                libiodefv2_string_destroy(ptr->cause);
                                ptr->cause = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_assessment_destroy_internal(iodefv2_assessment_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }





        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_intended_impact_t *entry;

                libiodefv2_list_for_each_safe(&ptr->intended_impact_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_intended_impact_destroy(entry);
                }
        }


        if ( ptr->confidence ) {
                iodefv2_confidence_destroy(ptr->confidence);
                ptr->confidence = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_time_impact_t *entry;

                libiodefv2_list_for_each_safe(&ptr->time_impact_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_time_impact_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_monetary_impact_t *entry;

                libiodefv2_list_for_each_safe(&ptr->monetary_impact_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_monetary_impact_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_counter_t *entry;

                libiodefv2_list_for_each_safe(&ptr->counter_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_counter_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_system_impact_t *entry;

                libiodefv2_list_for_each_safe(&ptr->system_impact_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_system_impact_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_business_impact_t *entry;

                libiodefv2_list_for_each_safe(&ptr->business_impact_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_business_impact_destroy(entry);
                }
        }

        if ( ptr->incident_category ) {
                libiodefv2_string_destroy(ptr->incident_category);
                ptr->incident_category = NULL;
        }



        if ( ptr->mitigating_factor ) {
                libiodefv2_string_destroy(ptr->mitigating_factor);
                ptr->mitigating_factor = NULL;
        }



        if ( ptr->cause ) {
                libiodefv2_string_destroy(ptr->cause);
                ptr->cause = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_assessment_destroy:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_assessment_destroy(iodefv2_assessment_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_assessment_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_assessment_get_restriction:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 *
 * Get restriction children of the #iodefv2_assessment_t object.
 *
 * Returns: a pointer to a iodefv2_assessment_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_assessment_restriction_t *iodefv2_assessment_get_restriction(iodefv2_assessment_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_assessment_set_restriction:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @restriction: pointer to a #iodefv2_assessment_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_assessment_set_restriction(iodefv2_assessment_t *ptr, iodefv2_assessment_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_assessment_unset_restriction(iodefv2_assessment_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_assessment_new_restriction:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @ret: pointer to an address where to store the created #iodefv2_assessment_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_assessment_t.
 * If @ptr already contain a #iodefv2_assessment_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_assessment_new_restriction(iodefv2_assessment_t *ptr, iodefv2_assessment_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_assessment_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 *
 * Get ext_restriction children of the #iodefv2_assessment_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_assessment_get_ext_restriction(iodefv2_assessment_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_assessment_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_assessment_set_ext_restriction(iodefv2_assessment_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_assessment_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_assessment_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_assessment_new_ext_restriction(iodefv2_assessment_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_assessment_get_occurrence:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 *
 * Get occurrence children of the #iodefv2_assessment_t object.
 *
 * Returns: a pointer to a iodefv2_assessment_occurrence_t object, or NULL if the children object is not set.
 */
iodefv2_assessment_occurrence_t *iodefv2_assessment_get_occurrence(iodefv2_assessment_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->occurrence_is_set ? &ptr->occurrence : NULL;


}


/**
 * iodefv2_assessment_set_occurrence:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @occurrence: pointer to a #iodefv2_assessment_occurrence_t object.
 *
 * Set @occurrence object as a children of @ptr.
 * if @ptr already contain an @occurrence object, then it is destroyed,
 * and updated to point to the provided @occurrence object.
 */
void iodefv2_assessment_set_occurrence(iodefv2_assessment_t *ptr, iodefv2_assessment_occurrence_t occurrence)
{
        libiodefv2_return_if_fail(ptr);
        ptr->occurrence = occurrence;
        ptr->occurrence_is_set = 1;
}

void iodefv2_assessment_unset_occurrence(iodefv2_assessment_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->occurrence_is_set = 0;
}
/**
 * iodefv2_assessment_new_occurrence:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @ret: pointer to an address where to store the created #iodefv2_assessment_occurrence_t object.
 *
 * Create a new occurrence object, children of #iodefv2_assessment_t.
 * If @ptr already contain a #iodefv2_assessment_occurrence_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_assessment_new_occurrence(iodefv2_assessment_t *ptr, iodefv2_assessment_occurrence_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->occurrence_is_set = 1;



        *ret = &ptr->occurrence;
        return 0;
}




/**
 * iodefv2_assessment_get_observable_id:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 *
 * Get observable_id children of the #iodefv2_assessment_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_assessment_get_observable_id(iodefv2_assessment_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_assessment_set_observable_id:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_assessment_set_observable_id(iodefv2_assessment_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_assessment_new_observable_id:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_assessment_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_assessment_new_observable_id(iodefv2_assessment_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}





/**
 * iodefv2_assessment_get_next_intended_impact:
 * @assessment: pointer to a #iodefv2_assessment_t object.
 * @intended_impact_cur: pointer to a #iodefv2_intended_impact_t object.
 *
 * Get the next #iodefv2_intended_impact_t object listed in @ptr.
 * When iterating over the iodefv2_intended_impact_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_intended_impact_t object.
 *
 * Returns: the next #iodefv2_intended_impact_t in the list.
 */
iodefv2_intended_impact_t *iodefv2_assessment_get_next_intended_impact(iodefv2_assessment_t *assessment, iodefv2_intended_impact_t *intended_impact_cur)
{
        libiodefv2_list_t *tmp = (intended_impact_cur) ? &((libiodefv2_linked_object_t *) intended_impact_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(assessment, NULL);

        libiodefv2_list_for_each_continue(&assessment->intended_impact_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_assessment_set_intended_impact:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @object: pointer to a #iodefv2_intended_impact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_intended_impact_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_assessment_set_intended_impact(iodefv2_assessment_t *ptr, iodefv2_intended_impact_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->intended_impact_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_assessment_new_intended_impact:
 *  @ptr: pointer to a #iodefv2_assessment_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_intended_impact_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_intended_impact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_intended_impact_t object. The created #iodefv2_intended_impact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_assessment_new_intended_impact(iodefv2_assessment_t *ptr, iodefv2_intended_impact_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_intended_impact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->intended_impact_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_assessment_get_confidence:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 *
 * Get confidence children of the #iodefv2_assessment_t object.
 *
 * Returns: a pointer to a iodefv2_confidence_t object, or NULL if the children object is not set.
 */
iodefv2_confidence_t *iodefv2_assessment_get_confidence(iodefv2_assessment_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->confidence;

}


/**
 * iodefv2_assessment_set_confidence:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @confidence: pointer to a #iodefv2_confidence_t object.
 *
 * Set @confidence object as a children of @ptr.
 * if @ptr already contain an @confidence object, then it is destroyed,
 * and updated to point to the provided @confidence object.
 */

void iodefv2_assessment_set_confidence(iodefv2_assessment_t *ptr, iodefv2_confidence_t *confidence)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->confidence )
                iodefv2_confidence_destroy(ptr->confidence);

        ptr->confidence = confidence;
}
/**
 * iodefv2_assessment_new_confidence:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @ret: pointer to an address where to store the created #iodefv2_confidence_t object.
 *
 * Create a new confidence object, children of #iodefv2_assessment_t.
 * If @ptr already contain a #iodefv2_confidence_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_assessment_new_confidence(iodefv2_assessment_t *ptr, iodefv2_confidence_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->confidence ) {
                retval = iodefv2_confidence_new(&ptr->confidence);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->confidence;
        return 0;
}





/**
 * iodefv2_assessment_get_next_time_impact:
 * @assessment: pointer to a #iodefv2_assessment_t object.
 * @time_impact_cur: pointer to a #iodefv2_time_impact_t object.
 *
 * Get the next #iodefv2_time_impact_t object listed in @ptr.
 * When iterating over the iodefv2_time_impact_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_time_impact_t object.
 *
 * Returns: the next #iodefv2_time_impact_t in the list.
 */
iodefv2_time_impact_t *iodefv2_assessment_get_next_time_impact(iodefv2_assessment_t *assessment, iodefv2_time_impact_t *time_impact_cur)
{
        libiodefv2_list_t *tmp = (time_impact_cur) ? &((libiodefv2_linked_object_t *) time_impact_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(assessment, NULL);

        libiodefv2_list_for_each_continue(&assessment->time_impact_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_assessment_set_time_impact:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @object: pointer to a #iodefv2_time_impact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_time_impact_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_assessment_set_time_impact(iodefv2_assessment_t *ptr, iodefv2_time_impact_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->time_impact_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_assessment_new_time_impact:
 *  @ptr: pointer to a #iodefv2_assessment_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_time_impact_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_time_impact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_time_impact_t object. The created #iodefv2_time_impact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_assessment_new_time_impact(iodefv2_assessment_t *ptr, iodefv2_time_impact_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_time_impact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->time_impact_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_assessment_get_next_additional_data:
 * @assessment: pointer to a #iodefv2_assessment_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_assessment_get_next_additional_data(iodefv2_assessment_t *assessment, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(assessment, NULL);

        libiodefv2_list_for_each_continue(&assessment->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_assessment_set_additional_data:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_assessment_set_additional_data(iodefv2_assessment_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_assessment_new_additional_data:
 *  @ptr: pointer to a #iodefv2_assessment_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_assessment_new_additional_data(iodefv2_assessment_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_assessment_get_next_monetary_impact:
 * @assessment: pointer to a #iodefv2_assessment_t object.
 * @monetary_impact_cur: pointer to a #iodefv2_monetary_impact_t object.
 *
 * Get the next #iodefv2_monetary_impact_t object listed in @ptr.
 * When iterating over the iodefv2_monetary_impact_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_monetary_impact_t object.
 *
 * Returns: the next #iodefv2_monetary_impact_t in the list.
 */
iodefv2_monetary_impact_t *iodefv2_assessment_get_next_monetary_impact(iodefv2_assessment_t *assessment, iodefv2_monetary_impact_t *monetary_impact_cur)
{
        libiodefv2_list_t *tmp = (monetary_impact_cur) ? &((libiodefv2_linked_object_t *) monetary_impact_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(assessment, NULL);

        libiodefv2_list_for_each_continue(&assessment->monetary_impact_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_assessment_set_monetary_impact:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @object: pointer to a #iodefv2_monetary_impact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_monetary_impact_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_assessment_set_monetary_impact(iodefv2_assessment_t *ptr, iodefv2_monetary_impact_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->monetary_impact_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_assessment_new_monetary_impact:
 *  @ptr: pointer to a #iodefv2_assessment_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_monetary_impact_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_monetary_impact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_monetary_impact_t object. The created #iodefv2_monetary_impact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_assessment_new_monetary_impact(iodefv2_assessment_t *ptr, iodefv2_monetary_impact_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_monetary_impact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->monetary_impact_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_assessment_get_next_counter:
 * @assessment: pointer to a #iodefv2_assessment_t object.
 * @counter_cur: pointer to a #iodefv2_counter_t object.
 *
 * Get the next #iodefv2_counter_t object listed in @ptr.
 * When iterating over the iodefv2_counter_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_counter_t object.
 *
 * Returns: the next #iodefv2_counter_t in the list.
 */
iodefv2_counter_t *iodefv2_assessment_get_next_counter(iodefv2_assessment_t *assessment, iodefv2_counter_t *counter_cur)
{
        libiodefv2_list_t *tmp = (counter_cur) ? &((libiodefv2_linked_object_t *) counter_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(assessment, NULL);

        libiodefv2_list_for_each_continue(&assessment->counter_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_assessment_set_counter:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @object: pointer to a #iodefv2_counter_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_counter_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_assessment_set_counter(iodefv2_assessment_t *ptr, iodefv2_counter_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->counter_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_assessment_new_counter:
 *  @ptr: pointer to a #iodefv2_assessment_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_counter_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_counter_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_counter_t object. The created #iodefv2_counter_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_assessment_new_counter(iodefv2_assessment_t *ptr, iodefv2_counter_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_counter_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->counter_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_assessment_get_next_system_impact:
 * @assessment: pointer to a #iodefv2_assessment_t object.
 * @system_impact_cur: pointer to a #iodefv2_system_impact_t object.
 *
 * Get the next #iodefv2_system_impact_t object listed in @ptr.
 * When iterating over the iodefv2_system_impact_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_system_impact_t object.
 *
 * Returns: the next #iodefv2_system_impact_t in the list.
 */
iodefv2_system_impact_t *iodefv2_assessment_get_next_system_impact(iodefv2_assessment_t *assessment, iodefv2_system_impact_t *system_impact_cur)
{
        libiodefv2_list_t *tmp = (system_impact_cur) ? &((libiodefv2_linked_object_t *) system_impact_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(assessment, NULL);

        libiodefv2_list_for_each_continue(&assessment->system_impact_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_assessment_set_system_impact:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @object: pointer to a #iodefv2_system_impact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_system_impact_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_assessment_set_system_impact(iodefv2_assessment_t *ptr, iodefv2_system_impact_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->system_impact_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_assessment_new_system_impact:
 *  @ptr: pointer to a #iodefv2_assessment_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_system_impact_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_system_impact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_system_impact_t object. The created #iodefv2_system_impact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_assessment_new_system_impact(iodefv2_assessment_t *ptr, iodefv2_system_impact_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_system_impact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->system_impact_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_assessment_get_next_business_impact:
 * @assessment: pointer to a #iodefv2_assessment_t object.
 * @business_impact_cur: pointer to a #iodefv2_business_impact_t object.
 *
 * Get the next #iodefv2_business_impact_t object listed in @ptr.
 * When iterating over the iodefv2_business_impact_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_business_impact_t object.
 *
 * Returns: the next #iodefv2_business_impact_t in the list.
 */
iodefv2_business_impact_t *iodefv2_assessment_get_next_business_impact(iodefv2_assessment_t *assessment, iodefv2_business_impact_t *business_impact_cur)
{
        libiodefv2_list_t *tmp = (business_impact_cur) ? &((libiodefv2_linked_object_t *) business_impact_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(assessment, NULL);

        libiodefv2_list_for_each_continue(&assessment->business_impact_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_assessment_set_business_impact:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @object: pointer to a #iodefv2_business_impact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_business_impact_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_assessment_set_business_impact(iodefv2_assessment_t *ptr, iodefv2_business_impact_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->business_impact_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_assessment_new_business_impact:
 *  @ptr: pointer to a #iodefv2_assessment_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_business_impact_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_business_impact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_business_impact_t object. The created #iodefv2_business_impact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_assessment_new_business_impact(iodefv2_assessment_t *ptr, iodefv2_business_impact_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_business_impact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->business_impact_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_assessment_get_incident_category:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 *
 * Get incident_category children of the #iodefv2_assessment_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_assessment_get_incident_category(iodefv2_assessment_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->incident_category;

}


/**
 * iodefv2_assessment_set_incident_category:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @incident_category: pointer to a #libiodefv2_string_t object.
 *
 * Set @incident_category object as a children of @ptr.
 * if @ptr already contain an @incident_category object, then it is destroyed,
 * and updated to point to the provided @incident_category object.
 */

void iodefv2_assessment_set_incident_category(iodefv2_assessment_t *ptr, libiodefv2_string_t *incident_category)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->incident_category )
                libiodefv2_string_destroy(ptr->incident_category);

        ptr->incident_category = incident_category;
}
/**
 * iodefv2_assessment_new_incident_category:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new incident_category object, children of #iodefv2_assessment_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_assessment_new_incident_category(iodefv2_assessment_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->incident_category ) {
                retval = libiodefv2_string_new(&ptr->incident_category);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->incident_category;
        return 0;
}




/**
 * iodefv2_assessment_get_mitigating_factor:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 *
 * Get mitigating_factor children of the #iodefv2_assessment_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_assessment_get_mitigating_factor(iodefv2_assessment_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->mitigating_factor;

}


/**
 * iodefv2_assessment_set_mitigating_factor:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @mitigating_factor: pointer to a #libiodefv2_string_t object.
 *
 * Set @mitigating_factor object as a children of @ptr.
 * if @ptr already contain an @mitigating_factor object, then it is destroyed,
 * and updated to point to the provided @mitigating_factor object.
 */

void iodefv2_assessment_set_mitigating_factor(iodefv2_assessment_t *ptr, libiodefv2_string_t *mitigating_factor)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->mitigating_factor )
                libiodefv2_string_destroy(ptr->mitigating_factor);

        ptr->mitigating_factor = mitigating_factor;
}
/**
 * iodefv2_assessment_new_mitigating_factor:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new mitigating_factor object, children of #iodefv2_assessment_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_assessment_new_mitigating_factor(iodefv2_assessment_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->mitigating_factor ) {
                retval = libiodefv2_string_new(&ptr->mitigating_factor);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->mitigating_factor;
        return 0;
}




/**
 * iodefv2_assessment_get_cause:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 *
 * Get cause children of the #iodefv2_assessment_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_assessment_get_cause(iodefv2_assessment_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->cause;

}


/**
 * iodefv2_assessment_set_cause:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @cause: pointer to a #libiodefv2_string_t object.
 *
 * Set @cause object as a children of @ptr.
 * if @ptr already contain an @cause object, then it is destroyed,
 * and updated to point to the provided @cause object.
 */

void iodefv2_assessment_set_cause(iodefv2_assessment_t *ptr, libiodefv2_string_t *cause)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->cause )
                libiodefv2_string_destroy(ptr->cause);

        ptr->cause = cause;
}
/**
 * iodefv2_assessment_new_cause:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new cause object, children of #iodefv2_assessment_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_assessment_new_cause(iodefv2_assessment_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->cause ) {
                retval = libiodefv2_string_new(&ptr->cause);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->cause;
        return 0;
}



/**
 * iodefv2_assessment_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_assessment_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_assessment_copy(const iodefv2_assessment_t *src, iodefv2_assessment_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




        dst->occurrence_is_set = src->occurrence_is_set;
        dst->occurrence = src->occurrence;



        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_intended_impact_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->intended_impact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_intended_impact_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->intended_impact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_intended_impact_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->intended_impact_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->confidence ) {
                iodefv2_confidence_destroy(dst->confidence);
                dst->confidence = NULL;
        }

        if ( src->confidence ) {
                ret = iodefv2_confidence_clone(src->confidence, &dst->confidence);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_time_impact_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->time_impact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_time_impact_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->time_impact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_time_impact_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->time_impact_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_monetary_impact_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->monetary_impact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_monetary_impact_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->monetary_impact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_monetary_impact_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->monetary_impact_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_counter_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->counter_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_counter_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->counter_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_counter_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->counter_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_system_impact_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->system_impact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_system_impact_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->system_impact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_system_impact_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->system_impact_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_business_impact_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->business_impact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_business_impact_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->business_impact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_business_impact_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->business_impact_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->incident_category ) {
                libiodefv2_string_destroy(dst->incident_category);
                dst->incident_category = NULL;
        }

        if ( src->incident_category ) {
                ret = libiodefv2_string_clone(src->incident_category, &dst->incident_category);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->mitigating_factor ) {
                libiodefv2_string_destroy(dst->mitigating_factor);
                dst->mitigating_factor = NULL;
        }

        if ( src->mitigating_factor ) {
                ret = libiodefv2_string_clone(src->mitigating_factor, &dst->mitigating_factor);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->cause ) {
                libiodefv2_string_destroy(dst->cause);
                dst->cause = NULL;
        }

        if ( src->cause ) {
                ret = libiodefv2_string_clone(src->cause, &dst->cause);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_assessment_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_assessment_clone(iodefv2_assessment_t *src, iodefv2_assessment_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_assessment_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_assessment_copy(src, *dst);
}


/**
 * iodefv2_assessment_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_assessment_compare(const iodefv2_assessment_t *obj1, const iodefv2_assessment_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;


        if ( obj1->occurrence_is_set != obj2->occurrence_is_set )
                return -1;

        if ( obj1->occurrence_is_set && obj1->occurrence != obj2->occurrence )
                return -1;


        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_intended_impact_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->intended_impact_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->intended_impact_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_intended_impact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_confidence_compare(obj1->confidence, obj2->confidence);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_time_impact_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->time_impact_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->time_impact_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_time_impact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_monetary_impact_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->monetary_impact_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->monetary_impact_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_monetary_impact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_counter_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->counter_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->counter_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_counter_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_system_impact_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->system_impact_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->system_impact_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_system_impact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_business_impact_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->business_impact_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->business_impact_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_business_impact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->incident_category, obj2->incident_category);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->mitigating_factor, obj2->mitigating_factor);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->cause, obj2->cause);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_attack_phase_new:
 * @ret: Pointer where to store the created #iodefv2_attack_phase_t object.
 *
 * Create a new #iodefv2_attack_phase_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_attack_phase_new(iodefv2_attack_phase_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_ATTACK_PHASE;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);






            return 0;
}


/**
 * iodefv2_attack_phase_ref:
 * @attack_phase: pointer to a #iodefv2_attack_phase_t object.
 *
 * Increase @attack_phase reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @attack_phase.
 */
iodefv2_attack_phase_t *iodefv2_attack_phase_ref(iodefv2_attack_phase_t *attack_phase)
{
        libiodefv2_return_val_if_fail(attack_phase, NULL);
        attack_phase->refcount++;

        return attack_phase;
}



int _iodefv2_attack_phase_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_attack_phase_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->url, TRUE);


            case 1:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);



            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->attack_phase_id, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_attack_phase_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_attack_phase_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_attack_phase_new_url(ptr, (libiodefv2_string_t **) ret);

                case 1: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_attack_phase_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_attack_phase_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 2:
                    return iodefv2_attack_phase_new_description(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_attack_phase_new_attack_phase_id(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_attack_phase_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_attack_phase_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->url ) {
                                libiodefv2_string_destroy(ptr->url);
                                ptr->url = NULL;
                        }

                        return 0;

    
                case 1: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 2:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->attack_phase_id ) {
                                libiodefv2_string_destroy(ptr->attack_phase_id);
                                ptr->attack_phase_id = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_attack_phase_destroy_internal(iodefv2_attack_phase_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->url ) {
                libiodefv2_string_destroy(ptr->url);
                ptr->url = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }

        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }



        if ( ptr->attack_phase_id ) {
                libiodefv2_string_destroy(ptr->attack_phase_id);
                ptr->attack_phase_id = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_attack_phase_destroy:
 * @ptr: pointer to a #iodefv2_attack_phase_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_attack_phase_destroy(iodefv2_attack_phase_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_attack_phase_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_attack_phase_get_url:
 * @ptr: pointer to a #iodefv2_attack_phase_t object.
 *
 * Get url children of the #iodefv2_attack_phase_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_attack_phase_get_url(iodefv2_attack_phase_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->url;

}


/**
 * iodefv2_attack_phase_set_url:
 * @ptr: pointer to a #iodefv2_attack_phase_t object.
 * @url: pointer to a #libiodefv2_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void iodefv2_attack_phase_set_url(iodefv2_attack_phase_t *ptr, libiodefv2_string_t *url)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->url )
                libiodefv2_string_destroy(ptr->url);

        ptr->url = url;
}
/**
 * iodefv2_attack_phase_new_url:
 * @ptr: pointer to a #iodefv2_attack_phase_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new url object, children of #iodefv2_attack_phase_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_attack_phase_new_url(iodefv2_attack_phase_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->url ) {
                retval = libiodefv2_string_new(&ptr->url);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->url;
        return 0;
}





/**
 * iodefv2_attack_phase_get_next_additional_data:
 * @attack_phase: pointer to a #iodefv2_attack_phase_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_attack_phase_get_next_additional_data(iodefv2_attack_phase_t *attack_phase, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(attack_phase, NULL);

        libiodefv2_list_for_each_continue(&attack_phase->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_attack_phase_set_additional_data:
 * @ptr: pointer to a #iodefv2_attack_phase_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_attack_phase_set_additional_data(iodefv2_attack_phase_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_attack_phase_new_additional_data:
 *  @ptr: pointer to a #iodefv2_attack_phase_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_attack_phase_new_additional_data(iodefv2_attack_phase_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_attack_phase_get_description:
 * @ptr: pointer to a #iodefv2_attack_phase_t object.
 *
 * Get description children of the #iodefv2_attack_phase_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_attack_phase_get_description(iodefv2_attack_phase_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_attack_phase_set_description:
 * @ptr: pointer to a #iodefv2_attack_phase_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_attack_phase_set_description(iodefv2_attack_phase_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_attack_phase_new_description:
 * @ptr: pointer to a #iodefv2_attack_phase_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_attack_phase_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_attack_phase_new_description(iodefv2_attack_phase_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}




/**
 * iodefv2_attack_phase_get_attack_phase_id:
 * @ptr: pointer to a #iodefv2_attack_phase_t object.
 *
 * Get attack_phase_id children of the #iodefv2_attack_phase_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_attack_phase_get_attack_phase_id(iodefv2_attack_phase_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->attack_phase_id;

}


/**
 * iodefv2_attack_phase_set_attack_phase_id:
 * @ptr: pointer to a #iodefv2_attack_phase_t object.
 * @attack_phase_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @attack_phase_id object as a children of @ptr.
 * if @ptr already contain an @attack_phase_id object, then it is destroyed,
 * and updated to point to the provided @attack_phase_id object.
 */

void iodefv2_attack_phase_set_attack_phase_id(iodefv2_attack_phase_t *ptr, libiodefv2_string_t *attack_phase_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->attack_phase_id )
                libiodefv2_string_destroy(ptr->attack_phase_id);

        ptr->attack_phase_id = attack_phase_id;
}
/**
 * iodefv2_attack_phase_new_attack_phase_id:
 * @ptr: pointer to a #iodefv2_attack_phase_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new attack_phase_id object, children of #iodefv2_attack_phase_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_attack_phase_new_attack_phase_id(iodefv2_attack_phase_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->attack_phase_id ) {
                retval = libiodefv2_string_new(&ptr->attack_phase_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->attack_phase_id;
        return 0;
}



/**
 * iodefv2_attack_phase_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_attack_phase_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_attack_phase_copy(const iodefv2_attack_phase_t *src, iodefv2_attack_phase_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->url ) {
                libiodefv2_string_destroy(dst->url);
                dst->url = NULL;
        }

        if ( src->url ) {
                ret = libiodefv2_string_clone(src->url, &dst->url);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->attack_phase_id ) {
                libiodefv2_string_destroy(dst->attack_phase_id);
                dst->attack_phase_id = NULL;
        }

        if ( src->attack_phase_id ) {
                ret = libiodefv2_string_clone(src->attack_phase_id, &dst->attack_phase_id);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_attack_phase_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_attack_phase_clone(iodefv2_attack_phase_t *src, iodefv2_attack_phase_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_attack_phase_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_attack_phase_copy(src, *dst);
}


/**
 * iodefv2_attack_phase_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_attack_phase_compare(const iodefv2_attack_phase_t *obj1, const iodefv2_attack_phase_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->url, obj2->url);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->attack_phase_id, obj2->attack_phase_id);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_contact_new:
 * @ret: Pointer where to store the created #iodefv2_contact_t object.
 *
 * Create a new #iodefv2_contact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_contact_new(iodefv2_contact_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_CONTACT;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);


        libiodefv2_list_init(&(*ret)->telephone_list);


        libiodefv2_list_init(&(*ret)->email_list);


        libiodefv2_list_init(&(*ret)->postal_address_list);


        libiodefv2_list_init(&(*ret)->registry_handle_list);
























            return 0;
}


/**
 * iodefv2_contact_ref:
 * @contact: pointer to a #iodefv2_contact_t object.
 *
 * Increase @contact reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @contact.
 */
iodefv2_contact_t *iodefv2_contact_ref(iodefv2_contact_t *contact)
{
        libiodefv2_return_val_if_fail(contact, NULL);
        contact->refcount++;

        return contact;
}



int _iodefv2_contact_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_contact_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_CONTACT_RESTRICTION , ptr->restriction);

            case 1:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_CONTACT_ROLE , ptr->role);


            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_type, TRUE);



            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_role, TRUE);



            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);


            case 5:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_CONTACT_TYPE , ptr->type);

            case 6:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 7:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->contact_title, TRUE);



            case 8:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            case 9:
                *childptr = &ptr->telephone_list;
                return 0;

            case 10:
                *childptr = &ptr->email_list;
                return 0;


            case 11:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->contact_name, TRUE);



            case 12:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->timezone, TRUE);


            case 13:
                *childptr = &ptr->postal_address_list;
                return 0;

            case 14:
                *childptr = &ptr->registry_handle_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_contact_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_contact_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_contact_new_restriction(ptr, (iodefv2_contact_restriction_t **) ret);

                case 1:
                    return iodefv2_contact_new_role(ptr, (iodefv2_contact_role_t **) ret);

                case 2:
                    return iodefv2_contact_new_ext_type(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_contact_new_ext_role(ptr, (libiodefv2_string_t **) ret);

                case 4:
                    return iodefv2_contact_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 5:
                    return iodefv2_contact_new_type(ptr, (iodefv2_contact_type_t **) ret);

                case 6: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_contact_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_contact_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 7:
                    return iodefv2_contact_new_contact_title(ptr, (libiodefv2_string_t **) ret);

                case 8:
                    return iodefv2_contact_new_description(ptr, (libiodefv2_string_t **) ret);

                case 9: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_contact_new_telephone(ptr, (iodefv2_telephone_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->telephone_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->telephone_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_contact_new_telephone(ptr, (iodefv2_telephone_t **) ret, n);
                }

                case 10: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_contact_new_email(ptr, (iodefv2_email_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->email_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->email_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_contact_new_email(ptr, (iodefv2_email_t **) ret, n);
                }

                case 11:
                    return iodefv2_contact_new_contact_name(ptr, (libiodefv2_string_t **) ret);

                case 12:
                    return iodefv2_contact_new_timezone(ptr, (libiodefv2_string_t **) ret);

                case 13: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_contact_new_postal_address(ptr, (iodefv2_postal_address_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->postal_address_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->postal_address_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_contact_new_postal_address(ptr, (iodefv2_postal_address_t **) ret, n);
                }

                case 14: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_contact_new_registry_handle(ptr, (iodefv2_registry_handle_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->registry_handle_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->registry_handle_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_contact_new_registry_handle(ptr, (iodefv2_registry_handle_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_contact_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_contact_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                    ptr->role = 0;
                    return 0;




                case 2:
                        if ( ptr->ext_type ) {
                                libiodefv2_string_destroy(ptr->ext_type);
                                ptr->ext_type = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->ext_role ) {
                                libiodefv2_string_destroy(ptr->ext_role);
                                ptr->ext_role = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 5:
                    ptr->type = 0;
                    return 0;

    
                case 6: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 7:
                        if ( ptr->contact_title ) {
                                libiodefv2_string_destroy(ptr->contact_title);
                                ptr->contact_title = NULL;
                        }

                        return 0;




                case 8:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

    
                case 9: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->telephone_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_telephone_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->telephone_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_telephone_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 10: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->email_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_email_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->email_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_email_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 11:
                        if ( ptr->contact_name ) {
                                libiodefv2_string_destroy(ptr->contact_name);
                                ptr->contact_name = NULL;
                        }

                        return 0;




                case 12:
                        if ( ptr->timezone ) {
                                libiodefv2_string_destroy(ptr->timezone);
                                ptr->timezone = NULL;
                        }

                        return 0;

    
                case 13: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->postal_address_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_postal_address_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->postal_address_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_postal_address_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 14: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->registry_handle_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_registry_handle_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->registry_handle_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_registry_handle_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_contact_destroy_internal(iodefv2_contact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);





        if ( ptr->ext_type ) {
                libiodefv2_string_destroy(ptr->ext_type);
                ptr->ext_type = NULL;
        }



        if ( ptr->ext_role ) {
                libiodefv2_string_destroy(ptr->ext_role);
                ptr->ext_role = NULL;
        }



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }






        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }

        if ( ptr->contact_title ) {
                libiodefv2_string_destroy(ptr->contact_title);
                ptr->contact_title = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_telephone_t *entry;

                libiodefv2_list_for_each_safe(&ptr->telephone_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_telephone_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_email_t *entry;

                libiodefv2_list_for_each_safe(&ptr->email_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_email_destroy(entry);
                }
        }

        if ( ptr->contact_name ) {
                libiodefv2_string_destroy(ptr->contact_name);
                ptr->contact_name = NULL;
        }



        if ( ptr->timezone ) {
                libiodefv2_string_destroy(ptr->timezone);
                ptr->timezone = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_postal_address_t *entry;

                libiodefv2_list_for_each_safe(&ptr->postal_address_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_postal_address_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_registry_handle_t *entry;

                libiodefv2_list_for_each_safe(&ptr->registry_handle_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_registry_handle_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_contact_destroy:
 * @ptr: pointer to a #iodefv2_contact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_contact_destroy(iodefv2_contact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_contact_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_contact_get_restriction:
 * @ptr: pointer to a #iodefv2_contact_t object.
 *
 * Get restriction children of the #iodefv2_contact_t object.
 *
 * Returns: a pointer to a iodefv2_contact_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_contact_restriction_t *iodefv2_contact_get_restriction(iodefv2_contact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_contact_set_restriction:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @restriction: pointer to a #iodefv2_contact_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_contact_set_restriction(iodefv2_contact_t *ptr, iodefv2_contact_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_contact_unset_restriction(iodefv2_contact_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_contact_new_restriction:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @ret: pointer to an address where to store the created #iodefv2_contact_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_contact_t.
 * If @ptr already contain a #iodefv2_contact_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_contact_new_restriction(iodefv2_contact_t *ptr, iodefv2_contact_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}



/**
 * iodefv2_contact_get_role:
 * @ptr: pointer to a #iodefv2_contact_t object.
 *
 * Get role children of the #iodefv2_contact_t object.
 *
 * Returns: a pointer to a iodefv2_contact_role_t object, or NULL if the children object is not set.
 */
iodefv2_contact_role_t iodefv2_contact_get_role(iodefv2_contact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->role;

}


/**
 * iodefv2_contact_set_role:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @role: pointer to a #iodefv2_contact_role_t object.
 *
 * Set @role object as a children of @ptr.
 * if @ptr already contain an @role object, then it is destroyed,
 * and updated to point to the provided @role object.
 */
void iodefv2_contact_set_role(iodefv2_contact_t *ptr, iodefv2_contact_role_t role)
{
        libiodefv2_return_if_fail(ptr);
        ptr->role = role;
}
/**
 * iodefv2_contact_new_role:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @ret: pointer to an address where to store the created #iodefv2_contact_role_t object.
 *
 * Create a new role object, children of #iodefv2_contact_t.
 * If @ptr already contain a #iodefv2_contact_role_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_contact_new_role(iodefv2_contact_t *ptr, iodefv2_contact_role_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->role;
        return 0;
}




/**
 * iodefv2_contact_get_ext_type:
 * @ptr: pointer to a #iodefv2_contact_t object.
 *
 * Get ext_type children of the #iodefv2_contact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_contact_get_ext_type(iodefv2_contact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_type;

}


/**
 * iodefv2_contact_set_ext_type:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @ext_type: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_type object as a children of @ptr.
 * if @ptr already contain an @ext_type object, then it is destroyed,
 * and updated to point to the provided @ext_type object.
 */

void iodefv2_contact_set_ext_type(iodefv2_contact_t *ptr, libiodefv2_string_t *ext_type)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_type )
                libiodefv2_string_destroy(ptr->ext_type);

        ptr->ext_type = ext_type;
}
/**
 * iodefv2_contact_new_ext_type:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_type object, children of #iodefv2_contact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_contact_new_ext_type(iodefv2_contact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_type ) {
                retval = libiodefv2_string_new(&ptr->ext_type);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_type;
        return 0;
}




/**
 * iodefv2_contact_get_ext_role:
 * @ptr: pointer to a #iodefv2_contact_t object.
 *
 * Get ext_role children of the #iodefv2_contact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_contact_get_ext_role(iodefv2_contact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_role;

}


/**
 * iodefv2_contact_set_ext_role:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @ext_role: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_role object as a children of @ptr.
 * if @ptr already contain an @ext_role object, then it is destroyed,
 * and updated to point to the provided @ext_role object.
 */

void iodefv2_contact_set_ext_role(iodefv2_contact_t *ptr, libiodefv2_string_t *ext_role)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_role )
                libiodefv2_string_destroy(ptr->ext_role);

        ptr->ext_role = ext_role;
}
/**
 * iodefv2_contact_new_ext_role:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_role object, children of #iodefv2_contact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_contact_new_ext_role(iodefv2_contact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_role ) {
                retval = libiodefv2_string_new(&ptr->ext_role);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_role;
        return 0;
}




/**
 * iodefv2_contact_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_contact_t object.
 *
 * Get ext_restriction children of the #iodefv2_contact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_contact_get_ext_restriction(iodefv2_contact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_contact_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_contact_set_ext_restriction(iodefv2_contact_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_contact_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_contact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_contact_new_ext_restriction(iodefv2_contact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}



/**
 * iodefv2_contact_get_type:
 * @ptr: pointer to a #iodefv2_contact_t object.
 *
 * Get type children of the #iodefv2_contact_t object.
 *
 * Returns: a pointer to a iodefv2_contact_type_t object, or NULL if the children object is not set.
 */
iodefv2_contact_type_t iodefv2_contact_get_type(iodefv2_contact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type;

}


/**
 * iodefv2_contact_set_type:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @type: pointer to a #iodefv2_contact_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */
void iodefv2_contact_set_type(iodefv2_contact_t *ptr, iodefv2_contact_type_t type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type = type;
}
/**
 * iodefv2_contact_new_type:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @ret: pointer to an address where to store the created #iodefv2_contact_type_t object.
 *
 * Create a new type object, children of #iodefv2_contact_t.
 * If @ptr already contain a #iodefv2_contact_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_contact_new_type(iodefv2_contact_t *ptr, iodefv2_contact_type_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->type;
        return 0;
}





/**
 * iodefv2_contact_get_next_additional_data:
 * @contact: pointer to a #iodefv2_contact_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_contact_get_next_additional_data(iodefv2_contact_t *contact, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(contact, NULL);

        libiodefv2_list_for_each_continue(&contact->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_contact_set_additional_data:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_contact_set_additional_data(iodefv2_contact_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_contact_new_additional_data:
 *  @ptr: pointer to a #iodefv2_contact_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_contact_new_additional_data(iodefv2_contact_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_contact_get_contact_title:
 * @ptr: pointer to a #iodefv2_contact_t object.
 *
 * Get contact_title children of the #iodefv2_contact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_contact_get_contact_title(iodefv2_contact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->contact_title;

}


/**
 * iodefv2_contact_set_contact_title:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @contact_title: pointer to a #libiodefv2_string_t object.
 *
 * Set @contact_title object as a children of @ptr.
 * if @ptr already contain an @contact_title object, then it is destroyed,
 * and updated to point to the provided @contact_title object.
 */

void iodefv2_contact_set_contact_title(iodefv2_contact_t *ptr, libiodefv2_string_t *contact_title)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->contact_title )
                libiodefv2_string_destroy(ptr->contact_title);

        ptr->contact_title = contact_title;
}
/**
 * iodefv2_contact_new_contact_title:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new contact_title object, children of #iodefv2_contact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_contact_new_contact_title(iodefv2_contact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->contact_title ) {
                retval = libiodefv2_string_new(&ptr->contact_title);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->contact_title;
        return 0;
}




/**
 * iodefv2_contact_get_description:
 * @ptr: pointer to a #iodefv2_contact_t object.
 *
 * Get description children of the #iodefv2_contact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_contact_get_description(iodefv2_contact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_contact_set_description:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_contact_set_description(iodefv2_contact_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_contact_new_description:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_contact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_contact_new_description(iodefv2_contact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}





/**
 * iodefv2_contact_get_next_telephone:
 * @contact: pointer to a #iodefv2_contact_t object.
 * @telephone_cur: pointer to a #iodefv2_telephone_t object.
 *
 * Get the next #iodefv2_telephone_t object listed in @ptr.
 * When iterating over the iodefv2_telephone_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_telephone_t object.
 *
 * Returns: the next #iodefv2_telephone_t in the list.
 */
iodefv2_telephone_t *iodefv2_contact_get_next_telephone(iodefv2_contact_t *contact, iodefv2_telephone_t *telephone_cur)
{
        libiodefv2_list_t *tmp = (telephone_cur) ? &((libiodefv2_linked_object_t *) telephone_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(contact, NULL);

        libiodefv2_list_for_each_continue(&contact->telephone_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_contact_set_telephone:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @object: pointer to a #iodefv2_telephone_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_telephone_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_contact_set_telephone(iodefv2_contact_t *ptr, iodefv2_telephone_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->telephone_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_contact_new_telephone:
 *  @ptr: pointer to a #iodefv2_contact_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_telephone_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_telephone_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_telephone_t object. The created #iodefv2_telephone_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_contact_new_telephone(iodefv2_contact_t *ptr, iodefv2_telephone_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_telephone_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->telephone_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_contact_get_next_email:
 * @contact: pointer to a #iodefv2_contact_t object.
 * @email_cur: pointer to a #iodefv2_email_t object.
 *
 * Get the next #iodefv2_email_t object listed in @ptr.
 * When iterating over the iodefv2_email_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_email_t object.
 *
 * Returns: the next #iodefv2_email_t in the list.
 */
iodefv2_email_t *iodefv2_contact_get_next_email(iodefv2_contact_t *contact, iodefv2_email_t *email_cur)
{
        libiodefv2_list_t *tmp = (email_cur) ? &((libiodefv2_linked_object_t *) email_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(contact, NULL);

        libiodefv2_list_for_each_continue(&contact->email_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_contact_set_email:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @object: pointer to a #iodefv2_email_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_email_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_contact_set_email(iodefv2_contact_t *ptr, iodefv2_email_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->email_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_contact_new_email:
 *  @ptr: pointer to a #iodefv2_contact_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_email_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_email_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_email_t object. The created #iodefv2_email_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_contact_new_email(iodefv2_contact_t *ptr, iodefv2_email_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_email_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->email_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_contact_get_contact_name:
 * @ptr: pointer to a #iodefv2_contact_t object.
 *
 * Get contact_name children of the #iodefv2_contact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_contact_get_contact_name(iodefv2_contact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->contact_name;

}


/**
 * iodefv2_contact_set_contact_name:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @contact_name: pointer to a #libiodefv2_string_t object.
 *
 * Set @contact_name object as a children of @ptr.
 * if @ptr already contain an @contact_name object, then it is destroyed,
 * and updated to point to the provided @contact_name object.
 */

void iodefv2_contact_set_contact_name(iodefv2_contact_t *ptr, libiodefv2_string_t *contact_name)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->contact_name )
                libiodefv2_string_destroy(ptr->contact_name);

        ptr->contact_name = contact_name;
}
/**
 * iodefv2_contact_new_contact_name:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new contact_name object, children of #iodefv2_contact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_contact_new_contact_name(iodefv2_contact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->contact_name ) {
                retval = libiodefv2_string_new(&ptr->contact_name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->contact_name;
        return 0;
}




/**
 * iodefv2_contact_get_timezone:
 * @ptr: pointer to a #iodefv2_contact_t object.
 *
 * Get timezone children of the #iodefv2_contact_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_contact_get_timezone(iodefv2_contact_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->timezone;

}


/**
 * iodefv2_contact_set_timezone:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @timezone: pointer to a #libiodefv2_string_t object.
 *
 * Set @timezone object as a children of @ptr.
 * if @ptr already contain an @timezone object, then it is destroyed,
 * and updated to point to the provided @timezone object.
 */

void iodefv2_contact_set_timezone(iodefv2_contact_t *ptr, libiodefv2_string_t *timezone)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->timezone )
                libiodefv2_string_destroy(ptr->timezone);

        ptr->timezone = timezone;
}
/**
 * iodefv2_contact_new_timezone:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new timezone object, children of #iodefv2_contact_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_contact_new_timezone(iodefv2_contact_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->timezone ) {
                retval = libiodefv2_string_new(&ptr->timezone);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->timezone;
        return 0;
}





/**
 * iodefv2_contact_get_next_postal_address:
 * @contact: pointer to a #iodefv2_contact_t object.
 * @postal_address_cur: pointer to a #iodefv2_postal_address_t object.
 *
 * Get the next #iodefv2_postal_address_t object listed in @ptr.
 * When iterating over the iodefv2_postal_address_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_postal_address_t object.
 *
 * Returns: the next #iodefv2_postal_address_t in the list.
 */
iodefv2_postal_address_t *iodefv2_contact_get_next_postal_address(iodefv2_contact_t *contact, iodefv2_postal_address_t *postal_address_cur)
{
        libiodefv2_list_t *tmp = (postal_address_cur) ? &((libiodefv2_linked_object_t *) postal_address_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(contact, NULL);

        libiodefv2_list_for_each_continue(&contact->postal_address_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_contact_set_postal_address:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @object: pointer to a #iodefv2_postal_address_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_postal_address_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_contact_set_postal_address(iodefv2_contact_t *ptr, iodefv2_postal_address_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->postal_address_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_contact_new_postal_address:
 *  @ptr: pointer to a #iodefv2_contact_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_postal_address_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_postal_address_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_postal_address_t object. The created #iodefv2_postal_address_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_contact_new_postal_address(iodefv2_contact_t *ptr, iodefv2_postal_address_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_postal_address_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->postal_address_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_contact_get_next_registry_handle:
 * @contact: pointer to a #iodefv2_contact_t object.
 * @registry_handle_cur: pointer to a #iodefv2_registry_handle_t object.
 *
 * Get the next #iodefv2_registry_handle_t object listed in @ptr.
 * When iterating over the iodefv2_registry_handle_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_registry_handle_t object.
 *
 * Returns: the next #iodefv2_registry_handle_t in the list.
 */
iodefv2_registry_handle_t *iodefv2_contact_get_next_registry_handle(iodefv2_contact_t *contact, iodefv2_registry_handle_t *registry_handle_cur)
{
        libiodefv2_list_t *tmp = (registry_handle_cur) ? &((libiodefv2_linked_object_t *) registry_handle_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(contact, NULL);

        libiodefv2_list_for_each_continue(&contact->registry_handle_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_contact_set_registry_handle:
 * @ptr: pointer to a #iodefv2_contact_t object.
 * @object: pointer to a #iodefv2_registry_handle_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_registry_handle_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_contact_set_registry_handle(iodefv2_contact_t *ptr, iodefv2_registry_handle_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->registry_handle_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_contact_new_registry_handle:
 *  @ptr: pointer to a #iodefv2_contact_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_registry_handle_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_registry_handle_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_registry_handle_t object. The created #iodefv2_registry_handle_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_contact_new_registry_handle(iodefv2_contact_t *ptr, iodefv2_registry_handle_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_registry_handle_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->registry_handle_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_contact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_contact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_contact_copy(const iodefv2_contact_t *src, iodefv2_contact_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        dst->role = src->role;



        if ( dst->ext_type ) {
                libiodefv2_string_destroy(dst->ext_type);
                dst->ext_type = NULL;
        }

        if ( src->ext_type ) {
                ret = libiodefv2_string_clone(src->ext_type, &dst->ext_type);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->ext_role ) {
                libiodefv2_string_destroy(dst->ext_role);
                dst->ext_role = NULL;
        }

        if ( src->ext_role ) {
                ret = libiodefv2_string_clone(src->ext_role, &dst->ext_role);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




        dst->type = src->type;



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->contact_title ) {
                libiodefv2_string_destroy(dst->contact_title);
                dst->contact_title = NULL;
        }

        if ( src->contact_title ) {
                ret = libiodefv2_string_clone(src->contact_title, &dst->contact_title);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_telephone_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->telephone_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_telephone_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->telephone_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_telephone_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->telephone_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_email_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->email_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_email_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->email_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_email_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->email_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->contact_name ) {
                libiodefv2_string_destroy(dst->contact_name);
                dst->contact_name = NULL;
        }

        if ( src->contact_name ) {
                ret = libiodefv2_string_clone(src->contact_name, &dst->contact_name);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->timezone ) {
                libiodefv2_string_destroy(dst->timezone);
                dst->timezone = NULL;
        }

        if ( src->timezone ) {
                ret = libiodefv2_string_clone(src->timezone, &dst->timezone);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_postal_address_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->postal_address_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_postal_address_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->postal_address_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_postal_address_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->postal_address_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_registry_handle_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->registry_handle_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_registry_handle_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->registry_handle_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_registry_handle_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->registry_handle_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_contact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_contact_clone(iodefv2_contact_t *src, iodefv2_contact_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_contact_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_contact_copy(src, *dst);
}


/**
 * iodefv2_contact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_contact_compare(const iodefv2_contact_t *obj1, const iodefv2_contact_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;



        if ( obj1->role != obj2->role )
                return -1;

        ret = libiodefv2_string_compare(obj1->ext_type, obj2->ext_type);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->ext_role, obj2->ext_role);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;


        if ( obj1->type != obj2->type )
                return -1;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->contact_title, obj2->contact_title);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_telephone_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->telephone_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->telephone_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_telephone_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_email_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->email_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->email_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_email_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->contact_name, obj2->contact_name);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->timezone, obj2->timezone);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_postal_address_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->postal_address_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->postal_address_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_postal_address_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_registry_handle_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->registry_handle_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->registry_handle_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_registry_handle_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_related_activity_new:
 * @ret: Pointer where to store the created #iodefv2_related_activity_t object.
 *
 * Create a new #iodefv2_related_activity_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_related_activity_new(iodefv2_related_activity_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_RELATED_ACTIVITY;


        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);


        libiodefv2_list_init(&(*ret)->campaign_list);


        libiodefv2_list_init(&(*ret)->threat_actor_list);


        libiodefv2_list_init(&(*ret)->indicator_id_list);


        libiodefv2_list_init(&(*ret)->incident_id_list);


















            return 0;
}


/**
 * iodefv2_related_activity_ref:
 * @related_activity: pointer to a #iodefv2_related_activity_t object.
 *
 * Increase @related_activity reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @related_activity.
 */
iodefv2_related_activity_t *iodefv2_related_activity_ref(iodefv2_related_activity_t *related_activity)
{
        libiodefv2_return_val_if_fail(related_activity, NULL);
        related_activity->refcount++;

        return related_activity;
}



int _iodefv2_related_activity_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_related_activity_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_RELATED_ACTIVITY_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);


            case 2:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 3:
                *childptr = ptr->confidence;
                return 0;


            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            case 5:
                *childptr = &ptr->campaign_list;
                return 0;


            case 6:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->url, TRUE);


            case 7:
                *childptr = &ptr->threat_actor_list;
                return 0;

            case 8:
                *childptr = &ptr->indicator_id_list;
                return 0;

            case 9:
                *childptr = &ptr->incident_id_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_related_activity_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_related_activity_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_related_activity_new_restriction(ptr, (iodefv2_related_activity_restriction_t **) ret);

                case 1:
                    return iodefv2_related_activity_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_related_activity_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_related_activity_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 3:
                    return iodefv2_related_activity_new_confidence(ptr, (iodefv2_confidence_t **) ret);

                case 4:
                    return iodefv2_related_activity_new_description(ptr, (libiodefv2_string_t **) ret);

                case 5: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_related_activity_new_campaign(ptr, (iodefv2_campaign_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->campaign_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->campaign_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_related_activity_new_campaign(ptr, (iodefv2_campaign_t **) ret, n);
                }

                case 6:
                    return iodefv2_related_activity_new_url(ptr, (libiodefv2_string_t **) ret);

                case 7: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_related_activity_new_threat_actor(ptr, (iodefv2_threat_actor_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->threat_actor_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->threat_actor_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_related_activity_new_threat_actor(ptr, (iodefv2_threat_actor_t **) ret, n);
                }

                case 8: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_related_activity_new_indicator_id(ptr, (iodefv2_indicator_id_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->indicator_id_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->indicator_id_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_related_activity_new_indicator_id(ptr, (iodefv2_indicator_id_t **) ret, n);
                }

                case 9: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_related_activity_new_incident_id(ptr, (iodefv2_incident_id_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->incident_id_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->incident_id_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_related_activity_new_incident_id(ptr, (iodefv2_incident_id_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_related_activity_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_related_activity_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;

    
                case 2: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 3:
                        if ( ptr->confidence ) {
                                iodefv2_confidence_destroy(ptr->confidence);
                                ptr->confidence = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

    
                case 5: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->campaign_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_campaign_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->campaign_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_campaign_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 6:
                        if ( ptr->url ) {
                                libiodefv2_string_destroy(ptr->url);
                                ptr->url = NULL;
                        }

                        return 0;

    
                case 7: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->threat_actor_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_threat_actor_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->threat_actor_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_threat_actor_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 8: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->indicator_id_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_indicator_id_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->indicator_id_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_indicator_id_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 9: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->incident_id_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_incident_id_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->incident_id_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_incident_id_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_related_activity_destroy_internal(iodefv2_related_activity_t *ptr)
{
        libiodefv2_return_if_fail(ptr);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }


        if ( ptr->confidence ) {
                iodefv2_confidence_destroy(ptr->confidence);
                ptr->confidence = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_campaign_t *entry;

                libiodefv2_list_for_each_safe(&ptr->campaign_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_campaign_destroy(entry);
                }
        }

        if ( ptr->url ) {
                libiodefv2_string_destroy(ptr->url);
                ptr->url = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_threat_actor_t *entry;

                libiodefv2_list_for_each_safe(&ptr->threat_actor_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_threat_actor_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_indicator_id_t *entry;

                libiodefv2_list_for_each_safe(&ptr->indicator_id_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_indicator_id_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_incident_id_t *entry;

                libiodefv2_list_for_each_safe(&ptr->incident_id_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_incident_id_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_related_activity_destroy:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_related_activity_destroy(iodefv2_related_activity_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_related_activity_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_related_activity_get_restriction:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 *
 * Get restriction children of the #iodefv2_related_activity_t object.
 *
 * Returns: a pointer to a iodefv2_related_activity_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_related_activity_restriction_t *iodefv2_related_activity_get_restriction(iodefv2_related_activity_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_related_activity_set_restriction:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 * @restriction: pointer to a #iodefv2_related_activity_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_related_activity_set_restriction(iodefv2_related_activity_t *ptr, iodefv2_related_activity_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_related_activity_unset_restriction(iodefv2_related_activity_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_related_activity_new_restriction:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 * @ret: pointer to an address where to store the created #iodefv2_related_activity_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_related_activity_t.
 * If @ptr already contain a #iodefv2_related_activity_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_related_activity_new_restriction(iodefv2_related_activity_t *ptr, iodefv2_related_activity_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_related_activity_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 *
 * Get ext_restriction children of the #iodefv2_related_activity_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_related_activity_get_ext_restriction(iodefv2_related_activity_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_related_activity_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_related_activity_set_ext_restriction(iodefv2_related_activity_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_related_activity_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_related_activity_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_related_activity_new_ext_restriction(iodefv2_related_activity_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}





/**
 * iodefv2_related_activity_get_next_additional_data:
 * @related_activity: pointer to a #iodefv2_related_activity_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_related_activity_get_next_additional_data(iodefv2_related_activity_t *related_activity, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(related_activity, NULL);

        libiodefv2_list_for_each_continue(&related_activity->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_related_activity_set_additional_data:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_related_activity_set_additional_data(iodefv2_related_activity_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_related_activity_new_additional_data:
 *  @ptr: pointer to a #iodefv2_related_activity_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_related_activity_new_additional_data(iodefv2_related_activity_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_related_activity_get_confidence:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 *
 * Get confidence children of the #iodefv2_related_activity_t object.
 *
 * Returns: a pointer to a iodefv2_confidence_t object, or NULL if the children object is not set.
 */
iodefv2_confidence_t *iodefv2_related_activity_get_confidence(iodefv2_related_activity_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->confidence;

}


/**
 * iodefv2_related_activity_set_confidence:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 * @confidence: pointer to a #iodefv2_confidence_t object.
 *
 * Set @confidence object as a children of @ptr.
 * if @ptr already contain an @confidence object, then it is destroyed,
 * and updated to point to the provided @confidence object.
 */

void iodefv2_related_activity_set_confidence(iodefv2_related_activity_t *ptr, iodefv2_confidence_t *confidence)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->confidence )
                iodefv2_confidence_destroy(ptr->confidence);

        ptr->confidence = confidence;
}
/**
 * iodefv2_related_activity_new_confidence:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 * @ret: pointer to an address where to store the created #iodefv2_confidence_t object.
 *
 * Create a new confidence object, children of #iodefv2_related_activity_t.
 * If @ptr already contain a #iodefv2_confidence_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_related_activity_new_confidence(iodefv2_related_activity_t *ptr, iodefv2_confidence_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->confidence ) {
                retval = iodefv2_confidence_new(&ptr->confidence);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->confidence;
        return 0;
}




/**
 * iodefv2_related_activity_get_description:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 *
 * Get description children of the #iodefv2_related_activity_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_related_activity_get_description(iodefv2_related_activity_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_related_activity_set_description:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_related_activity_set_description(iodefv2_related_activity_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_related_activity_new_description:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_related_activity_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_related_activity_new_description(iodefv2_related_activity_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}





/**
 * iodefv2_related_activity_get_next_campaign:
 * @related_activity: pointer to a #iodefv2_related_activity_t object.
 * @campaign_cur: pointer to a #iodefv2_campaign_t object.
 *
 * Get the next #iodefv2_campaign_t object listed in @ptr.
 * When iterating over the iodefv2_campaign_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_campaign_t object.
 *
 * Returns: the next #iodefv2_campaign_t in the list.
 */
iodefv2_campaign_t *iodefv2_related_activity_get_next_campaign(iodefv2_related_activity_t *related_activity, iodefv2_campaign_t *campaign_cur)
{
        libiodefv2_list_t *tmp = (campaign_cur) ? &((libiodefv2_linked_object_t *) campaign_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(related_activity, NULL);

        libiodefv2_list_for_each_continue(&related_activity->campaign_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_related_activity_set_campaign:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 * @object: pointer to a #iodefv2_campaign_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_campaign_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_related_activity_set_campaign(iodefv2_related_activity_t *ptr, iodefv2_campaign_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->campaign_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_related_activity_new_campaign:
 *  @ptr: pointer to a #iodefv2_related_activity_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_campaign_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_campaign_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_campaign_t object. The created #iodefv2_campaign_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_related_activity_new_campaign(iodefv2_related_activity_t *ptr, iodefv2_campaign_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_campaign_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->campaign_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_related_activity_get_url:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 *
 * Get url children of the #iodefv2_related_activity_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_related_activity_get_url(iodefv2_related_activity_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->url;

}


/**
 * iodefv2_related_activity_set_url:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 * @url: pointer to a #libiodefv2_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void iodefv2_related_activity_set_url(iodefv2_related_activity_t *ptr, libiodefv2_string_t *url)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->url )
                libiodefv2_string_destroy(ptr->url);

        ptr->url = url;
}
/**
 * iodefv2_related_activity_new_url:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new url object, children of #iodefv2_related_activity_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_related_activity_new_url(iodefv2_related_activity_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->url ) {
                retval = libiodefv2_string_new(&ptr->url);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->url;
        return 0;
}





/**
 * iodefv2_related_activity_get_next_threat_actor:
 * @related_activity: pointer to a #iodefv2_related_activity_t object.
 * @threat_actor_cur: pointer to a #iodefv2_threat_actor_t object.
 *
 * Get the next #iodefv2_threat_actor_t object listed in @ptr.
 * When iterating over the iodefv2_threat_actor_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_threat_actor_t object.
 *
 * Returns: the next #iodefv2_threat_actor_t in the list.
 */
iodefv2_threat_actor_t *iodefv2_related_activity_get_next_threat_actor(iodefv2_related_activity_t *related_activity, iodefv2_threat_actor_t *threat_actor_cur)
{
        libiodefv2_list_t *tmp = (threat_actor_cur) ? &((libiodefv2_linked_object_t *) threat_actor_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(related_activity, NULL);

        libiodefv2_list_for_each_continue(&related_activity->threat_actor_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_related_activity_set_threat_actor:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 * @object: pointer to a #iodefv2_threat_actor_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_threat_actor_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_related_activity_set_threat_actor(iodefv2_related_activity_t *ptr, iodefv2_threat_actor_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->threat_actor_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_related_activity_new_threat_actor:
 *  @ptr: pointer to a #iodefv2_related_activity_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_threat_actor_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_threat_actor_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_threat_actor_t object. The created #iodefv2_threat_actor_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_related_activity_new_threat_actor(iodefv2_related_activity_t *ptr, iodefv2_threat_actor_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_threat_actor_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->threat_actor_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_related_activity_get_next_indicator_id:
 * @related_activity: pointer to a #iodefv2_related_activity_t object.
 * @indicator_id_cur: pointer to a #iodefv2_indicator_id_t object.
 *
 * Get the next #iodefv2_indicator_id_t object listed in @ptr.
 * When iterating over the iodefv2_indicator_id_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_indicator_id_t object.
 *
 * Returns: the next #iodefv2_indicator_id_t in the list.
 */
iodefv2_indicator_id_t *iodefv2_related_activity_get_next_indicator_id(iodefv2_related_activity_t *related_activity, iodefv2_indicator_id_t *indicator_id_cur)
{
        libiodefv2_list_t *tmp = (indicator_id_cur) ? &((libiodefv2_linked_object_t *) indicator_id_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(related_activity, NULL);

        libiodefv2_list_for_each_continue(&related_activity->indicator_id_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_related_activity_set_indicator_id:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 * @object: pointer to a #iodefv2_indicator_id_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_indicator_id_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_related_activity_set_indicator_id(iodefv2_related_activity_t *ptr, iodefv2_indicator_id_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->indicator_id_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_related_activity_new_indicator_id:
 *  @ptr: pointer to a #iodefv2_related_activity_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_indicator_id_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_indicator_id_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_indicator_id_t object. The created #iodefv2_indicator_id_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_related_activity_new_indicator_id(iodefv2_related_activity_t *ptr, iodefv2_indicator_id_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_indicator_id_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->indicator_id_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_related_activity_get_next_incident_id:
 * @related_activity: pointer to a #iodefv2_related_activity_t object.
 * @incident_id_cur: pointer to a #iodefv2_incident_id_t object.
 *
 * Get the next #iodefv2_incident_id_t object listed in @ptr.
 * When iterating over the iodefv2_incident_id_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_incident_id_t object.
 *
 * Returns: the next #iodefv2_incident_id_t in the list.
 */
iodefv2_incident_id_t *iodefv2_related_activity_get_next_incident_id(iodefv2_related_activity_t *related_activity, iodefv2_incident_id_t *incident_id_cur)
{
        libiodefv2_list_t *tmp = (incident_id_cur) ? &((libiodefv2_linked_object_t *) incident_id_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(related_activity, NULL);

        libiodefv2_list_for_each_continue(&related_activity->incident_id_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_related_activity_set_incident_id:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 * @object: pointer to a #iodefv2_incident_id_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_incident_id_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_related_activity_set_incident_id(iodefv2_related_activity_t *ptr, iodefv2_incident_id_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->incident_id_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_related_activity_new_incident_id:
 *  @ptr: pointer to a #iodefv2_related_activity_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_incident_id_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_incident_id_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_incident_id_t object. The created #iodefv2_incident_id_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_related_activity_new_incident_id(iodefv2_related_activity_t *ptr, iodefv2_incident_id_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_incident_id_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->incident_id_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_related_activity_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_related_activity_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_related_activity_copy(const iodefv2_related_activity_t *src, iodefv2_related_activity_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->confidence ) {
                iodefv2_confidence_destroy(dst->confidence);
                dst->confidence = NULL;
        }

        if ( src->confidence ) {
                ret = iodefv2_confidence_clone(src->confidence, &dst->confidence);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_campaign_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->campaign_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_campaign_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->campaign_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_campaign_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->campaign_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->url ) {
                libiodefv2_string_destroy(dst->url);
                dst->url = NULL;
        }

        if ( src->url ) {
                ret = libiodefv2_string_clone(src->url, &dst->url);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_threat_actor_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->threat_actor_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_threat_actor_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->threat_actor_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_threat_actor_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->threat_actor_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_indicator_id_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->indicator_id_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_indicator_id_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->indicator_id_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_indicator_id_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->indicator_id_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_incident_id_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->incident_id_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_incident_id_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->incident_id_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_incident_id_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->incident_id_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_related_activity_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_related_activity_clone(iodefv2_related_activity_t *src, iodefv2_related_activity_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_related_activity_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_related_activity_copy(src, *dst);
}


/**
 * iodefv2_related_activity_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_related_activity_compare(const iodefv2_related_activity_t *obj1, const iodefv2_related_activity_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_confidence_compare(obj1->confidence, obj2->confidence);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_campaign_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->campaign_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->campaign_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_campaign_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->url, obj2->url);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_threat_actor_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->threat_actor_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->threat_actor_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_threat_actor_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_indicator_id_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->indicator_id_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->indicator_id_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_indicator_id_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_incident_id_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->incident_id_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->incident_id_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_incident_id_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_domain_contacts_new:
 * @ret: Pointer where to store the created #iodefv2_domain_contacts_t object.
 *
 * Create a new #iodefv2_domain_contacts_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_domain_contacts_new(iodefv2_domain_contacts_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_DOMAIN_CONTACTS;


        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->contact_list);




            return 0;
}


/**
 * iodefv2_domain_contacts_ref:
 * @domain_contacts: pointer to a #iodefv2_domain_contacts_t object.
 *
 * Increase @domain_contacts reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @domain_contacts.
 */
iodefv2_domain_contacts_t *iodefv2_domain_contacts_ref(iodefv2_domain_contacts_t *domain_contacts)
{
        libiodefv2_return_val_if_fail(domain_contacts, NULL);
        domain_contacts->refcount++;

        return domain_contacts;
}



int _iodefv2_domain_contacts_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_domain_contacts_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:
                *childptr = &ptr->contact_list;
                return 0;


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->same_domain_contact, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_domain_contacts_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_domain_contacts_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_domain_contacts_new_contact(ptr, (iodefv2_contact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->contact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->contact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_domain_contacts_new_contact(ptr, (iodefv2_contact_t **) ret, n);
                }

                case 1:
                    return iodefv2_domain_contacts_new_same_domain_contact(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_domain_contacts_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_domain_contacts_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
    
                case 0: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->contact_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_contact_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->contact_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_contact_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 1:
                        if ( ptr->same_domain_contact ) {
                                libiodefv2_string_destroy(ptr->same_domain_contact);
                                ptr->same_domain_contact = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_domain_contacts_destroy_internal(iodefv2_domain_contacts_t *ptr)
{
        libiodefv2_return_if_fail(ptr);


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_contact_t *entry;

                libiodefv2_list_for_each_safe(&ptr->contact_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_contact_destroy(entry);
                }
        }

        if ( ptr->same_domain_contact ) {
                libiodefv2_string_destroy(ptr->same_domain_contact);
                ptr->same_domain_contact = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_domain_contacts_destroy:
 * @ptr: pointer to a #iodefv2_domain_contacts_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_domain_contacts_destroy(iodefv2_domain_contacts_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_domain_contacts_destroy_internal(ptr);
        free(ptr);
}






/**
 * iodefv2_domain_contacts_get_next_contact:
 * @domain_contacts: pointer to a #iodefv2_domain_contacts_t object.
 * @contact_cur: pointer to a #iodefv2_contact_t object.
 *
 * Get the next #iodefv2_contact_t object listed in @ptr.
 * When iterating over the iodefv2_contact_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_contact_t object.
 *
 * Returns: the next #iodefv2_contact_t in the list.
 */
iodefv2_contact_t *iodefv2_domain_contacts_get_next_contact(iodefv2_domain_contacts_t *domain_contacts, iodefv2_contact_t *contact_cur)
{
        libiodefv2_list_t *tmp = (contact_cur) ? &((libiodefv2_linked_object_t *) contact_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(domain_contacts, NULL);

        libiodefv2_list_for_each_continue(&domain_contacts->contact_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_domain_contacts_set_contact:
 * @ptr: pointer to a #iodefv2_domain_contacts_t object.
 * @object: pointer to a #iodefv2_contact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_contact_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_domain_contacts_set_contact(iodefv2_domain_contacts_t *ptr, iodefv2_contact_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->contact_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_domain_contacts_new_contact:
 *  @ptr: pointer to a #iodefv2_domain_contacts_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_contact_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_contact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_contact_t object. The created #iodefv2_contact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_domain_contacts_new_contact(iodefv2_domain_contacts_t *ptr, iodefv2_contact_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_contact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->contact_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_domain_contacts_get_same_domain_contact:
 * @ptr: pointer to a #iodefv2_domain_contacts_t object.
 *
 * Get same_domain_contact children of the #iodefv2_domain_contacts_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_domain_contacts_get_same_domain_contact(iodefv2_domain_contacts_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->same_domain_contact;

}


/**
 * iodefv2_domain_contacts_set_same_domain_contact:
 * @ptr: pointer to a #iodefv2_domain_contacts_t object.
 * @same_domain_contact: pointer to a #libiodefv2_string_t object.
 *
 * Set @same_domain_contact object as a children of @ptr.
 * if @ptr already contain an @same_domain_contact object, then it is destroyed,
 * and updated to point to the provided @same_domain_contact object.
 */

void iodefv2_domain_contacts_set_same_domain_contact(iodefv2_domain_contacts_t *ptr, libiodefv2_string_t *same_domain_contact)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->same_domain_contact )
                libiodefv2_string_destroy(ptr->same_domain_contact);

        ptr->same_domain_contact = same_domain_contact;
}
/**
 * iodefv2_domain_contacts_new_same_domain_contact:
 * @ptr: pointer to a #iodefv2_domain_contacts_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new same_domain_contact object, children of #iodefv2_domain_contacts_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_domain_contacts_new_same_domain_contact(iodefv2_domain_contacts_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->same_domain_contact ) {
                retval = libiodefv2_string_new(&ptr->same_domain_contact);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->same_domain_contact;
        return 0;
}



/**
 * iodefv2_domain_contacts_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_domain_contacts_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_domain_contacts_copy(const iodefv2_domain_contacts_t *src, iodefv2_domain_contacts_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_contact_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->contact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_contact_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->contact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_contact_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->contact_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->same_domain_contact ) {
                libiodefv2_string_destroy(dst->same_domain_contact);
                dst->same_domain_contact = NULL;
        }

        if ( src->same_domain_contact ) {
                ret = libiodefv2_string_clone(src->same_domain_contact, &dst->same_domain_contact);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_domain_contacts_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_domain_contacts_clone(iodefv2_domain_contacts_t *src, iodefv2_domain_contacts_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_domain_contacts_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_domain_contacts_copy(src, *dst);
}


/**
 * iodefv2_domain_contacts_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_domain_contacts_compare(const iodefv2_domain_contacts_t *obj1, const iodefv2_domain_contacts_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_contact_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->contact_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->contact_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_contact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->same_domain_contact, obj2->same_domain_contact);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_history_item_new:
 * @ret: Pointer where to store the created #iodefv2_history_item_t object.
 *
 * Create a new #iodefv2_history_item_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_history_item_new(iodefv2_history_item_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_HISTORY_ITEM;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);

















        {
            int retval = iodefv2_time_new(&(*ret)->date_time);

            if ( retval < 0 ) {
                    iodefv2_history_item_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }
            return 0;
}


/**
 * iodefv2_history_item_ref:
 * @history_item: pointer to a #iodefv2_history_item_t object.
 *
 * Increase @history_item reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @history_item.
 */
iodefv2_history_item_t *iodefv2_history_item_ref(iodefv2_history_item_t *history_item)
{
        libiodefv2_return_val_if_fail(history_item, NULL);
        history_item->refcount++;

        return history_item;
}



int _iodefv2_history_item_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_history_item_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_HISTORY_ITEM_ACTION , ptr->action);

            case 1:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_HISTORY_ITEM_RESTRICTION , ptr->restriction);


            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_action, TRUE);



            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);



            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);


            case 5:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 6:
                *childptr = ptr->contact;
                return 0;


            case 7:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->defined_coa, TRUE);



            case 8:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);



            case 9:
                *childptr = ptr->incident_id;
                return 0;


            case 10:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->date_time, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_history_item_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_history_item_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_history_item_new_action(ptr, (iodefv2_history_item_action_t **) ret);

                case 1:
                    return iodefv2_history_item_new_restriction(ptr, (iodefv2_history_item_restriction_t **) ret);

                case 2:
                    return iodefv2_history_item_new_ext_action(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_history_item_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 4:
                    return iodefv2_history_item_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 5: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_history_item_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_history_item_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 6:
                    return iodefv2_history_item_new_contact(ptr, (iodefv2_contact_t **) ret);

                case 7:
                    return iodefv2_history_item_new_defined_coa(ptr, (libiodefv2_string_t **) ret);

                case 8:
                    return iodefv2_history_item_new_description(ptr, (libiodefv2_string_t **) ret);

                case 9:
                    return iodefv2_history_item_new_incident_id(ptr, (iodefv2_incident_id_t **) ret);

                case 10:
                    return iodefv2_history_item_new_date_time(ptr, (iodefv2_time_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_history_item_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_history_item_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->action = 0;
                    return 0;

                case 1:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 2:
                        if ( ptr->ext_action ) {
                                libiodefv2_string_destroy(ptr->ext_action);
                                ptr->ext_action = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;

    
                case 5: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 6:
                        if ( ptr->contact ) {
                                iodefv2_contact_destroy(ptr->contact);
                                ptr->contact = NULL;
                        }

                        return 0;




                case 7:
                        if ( ptr->defined_coa ) {
                                libiodefv2_string_destroy(ptr->defined_coa);
                                ptr->defined_coa = NULL;
                        }

                        return 0;




                case 8:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;




                case 9:
                        if ( ptr->incident_id ) {
                                iodefv2_incident_id_destroy(ptr->incident_id);
                                ptr->incident_id = NULL;
                        }

                        return 0;




                case 10:
                        if ( ptr->date_time ) {
                                iodefv2_time_destroy(ptr->date_time);
                                ptr->date_time = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_history_item_destroy_internal(iodefv2_history_item_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);





        if ( ptr->ext_action ) {
                libiodefv2_string_destroy(ptr->ext_action);
                ptr->ext_action = NULL;
        }



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }



        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }


        if ( ptr->contact ) {
                iodefv2_contact_destroy(ptr->contact);
                ptr->contact = NULL;
        }



        if ( ptr->defined_coa ) {
                libiodefv2_string_destroy(ptr->defined_coa);
                ptr->defined_coa = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }




        if ( ptr->incident_id ) {
                iodefv2_incident_id_destroy(ptr->incident_id);
                ptr->incident_id = NULL;
        }



        if ( ptr->date_time ) {
                iodefv2_time_destroy(ptr->date_time);
                ptr->date_time = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_history_item_destroy:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_history_item_destroy(iodefv2_history_item_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_history_item_destroy_internal(ptr);
        free(ptr);
}




/**
 * iodefv2_history_item_get_action:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 *
 * Get action children of the #iodefv2_history_item_t object.
 *
 * Returns: a pointer to a iodefv2_history_item_action_t object, or NULL if the children object is not set.
 */
iodefv2_history_item_action_t iodefv2_history_item_get_action(iodefv2_history_item_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->action;

}


/**
 * iodefv2_history_item_set_action:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @action: pointer to a #iodefv2_history_item_action_t object.
 *
 * Set @action object as a children of @ptr.
 * if @ptr already contain an @action object, then it is destroyed,
 * and updated to point to the provided @action object.
 */
void iodefv2_history_item_set_action(iodefv2_history_item_t *ptr, iodefv2_history_item_action_t action)
{
        libiodefv2_return_if_fail(ptr);
        ptr->action = action;
}
/**
 * iodefv2_history_item_new_action:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @ret: pointer to an address where to store the created #iodefv2_history_item_action_t object.
 *
 * Create a new action object, children of #iodefv2_history_item_t.
 * If @ptr already contain a #iodefv2_history_item_action_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_history_item_new_action(iodefv2_history_item_t *ptr, iodefv2_history_item_action_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->action;
        return 0;
}




/**
 * iodefv2_history_item_get_restriction:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 *
 * Get restriction children of the #iodefv2_history_item_t object.
 *
 * Returns: a pointer to a iodefv2_history_item_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_history_item_restriction_t *iodefv2_history_item_get_restriction(iodefv2_history_item_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_history_item_set_restriction:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @restriction: pointer to a #iodefv2_history_item_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_history_item_set_restriction(iodefv2_history_item_t *ptr, iodefv2_history_item_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_history_item_unset_restriction(iodefv2_history_item_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_history_item_new_restriction:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @ret: pointer to an address where to store the created #iodefv2_history_item_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_history_item_t.
 * If @ptr already contain a #iodefv2_history_item_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_history_item_new_restriction(iodefv2_history_item_t *ptr, iodefv2_history_item_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_history_item_get_ext_action:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 *
 * Get ext_action children of the #iodefv2_history_item_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_history_item_get_ext_action(iodefv2_history_item_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_action;

}


/**
 * iodefv2_history_item_set_ext_action:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @ext_action: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_action object as a children of @ptr.
 * if @ptr already contain an @ext_action object, then it is destroyed,
 * and updated to point to the provided @ext_action object.
 */

void iodefv2_history_item_set_ext_action(iodefv2_history_item_t *ptr, libiodefv2_string_t *ext_action)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_action )
                libiodefv2_string_destroy(ptr->ext_action);

        ptr->ext_action = ext_action;
}
/**
 * iodefv2_history_item_new_ext_action:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_action object, children of #iodefv2_history_item_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_history_item_new_ext_action(iodefv2_history_item_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_action ) {
                retval = libiodefv2_string_new(&ptr->ext_action);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_action;
        return 0;
}




/**
 * iodefv2_history_item_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 *
 * Get ext_restriction children of the #iodefv2_history_item_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_history_item_get_ext_restriction(iodefv2_history_item_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_history_item_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_history_item_set_ext_restriction(iodefv2_history_item_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_history_item_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_history_item_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_history_item_new_ext_restriction(iodefv2_history_item_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_history_item_get_observable_id:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 *
 * Get observable_id children of the #iodefv2_history_item_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_history_item_get_observable_id(iodefv2_history_item_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_history_item_set_observable_id:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_history_item_set_observable_id(iodefv2_history_item_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_history_item_new_observable_id:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_history_item_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_history_item_new_observable_id(iodefv2_history_item_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}





/**
 * iodefv2_history_item_get_next_additional_data:
 * @history_item: pointer to a #iodefv2_history_item_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_history_item_get_next_additional_data(iodefv2_history_item_t *history_item, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(history_item, NULL);

        libiodefv2_list_for_each_continue(&history_item->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_history_item_set_additional_data:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_history_item_set_additional_data(iodefv2_history_item_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_history_item_new_additional_data:
 *  @ptr: pointer to a #iodefv2_history_item_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_history_item_new_additional_data(iodefv2_history_item_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_history_item_get_contact:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 *
 * Get contact children of the #iodefv2_history_item_t object.
 *
 * Returns: a pointer to a iodefv2_contact_t object, or NULL if the children object is not set.
 */
iodefv2_contact_t *iodefv2_history_item_get_contact(iodefv2_history_item_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->contact;

}


/**
 * iodefv2_history_item_set_contact:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @contact: pointer to a #iodefv2_contact_t object.
 *
 * Set @contact object as a children of @ptr.
 * if @ptr already contain an @contact object, then it is destroyed,
 * and updated to point to the provided @contact object.
 */

void iodefv2_history_item_set_contact(iodefv2_history_item_t *ptr, iodefv2_contact_t *contact)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->contact )
                iodefv2_contact_destroy(ptr->contact);

        ptr->contact = contact;
}
/**
 * iodefv2_history_item_new_contact:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @ret: pointer to an address where to store the created #iodefv2_contact_t object.
 *
 * Create a new contact object, children of #iodefv2_history_item_t.
 * If @ptr already contain a #iodefv2_contact_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_history_item_new_contact(iodefv2_history_item_t *ptr, iodefv2_contact_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->contact ) {
                retval = iodefv2_contact_new(&ptr->contact);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->contact;
        return 0;
}




/**
 * iodefv2_history_item_get_defined_coa:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 *
 * Get defined_coa children of the #iodefv2_history_item_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_history_item_get_defined_coa(iodefv2_history_item_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->defined_coa;

}


/**
 * iodefv2_history_item_set_defined_coa:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @defined_coa: pointer to a #libiodefv2_string_t object.
 *
 * Set @defined_coa object as a children of @ptr.
 * if @ptr already contain an @defined_coa object, then it is destroyed,
 * and updated to point to the provided @defined_coa object.
 */

void iodefv2_history_item_set_defined_coa(iodefv2_history_item_t *ptr, libiodefv2_string_t *defined_coa)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->defined_coa )
                libiodefv2_string_destroy(ptr->defined_coa);

        ptr->defined_coa = defined_coa;
}
/**
 * iodefv2_history_item_new_defined_coa:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new defined_coa object, children of #iodefv2_history_item_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_history_item_new_defined_coa(iodefv2_history_item_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->defined_coa ) {
                retval = libiodefv2_string_new(&ptr->defined_coa);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->defined_coa;
        return 0;
}




/**
 * iodefv2_history_item_get_description:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 *
 * Get description children of the #iodefv2_history_item_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_history_item_get_description(iodefv2_history_item_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_history_item_set_description:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_history_item_set_description(iodefv2_history_item_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_history_item_new_description:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_history_item_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_history_item_new_description(iodefv2_history_item_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}




/**
 * iodefv2_history_item_get_incident_id:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 *
 * Get incident_id children of the #iodefv2_history_item_t object.
 *
 * Returns: a pointer to a iodefv2_incident_id_t object, or NULL if the children object is not set.
 */
iodefv2_incident_id_t *iodefv2_history_item_get_incident_id(iodefv2_history_item_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->incident_id;

}


/**
 * iodefv2_history_item_set_incident_id:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @incident_id: pointer to a #iodefv2_incident_id_t object.
 *
 * Set @incident_id object as a children of @ptr.
 * if @ptr already contain an @incident_id object, then it is destroyed,
 * and updated to point to the provided @incident_id object.
 */

void iodefv2_history_item_set_incident_id(iodefv2_history_item_t *ptr, iodefv2_incident_id_t *incident_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->incident_id )
                iodefv2_incident_id_destroy(ptr->incident_id);

        ptr->incident_id = incident_id;
}
/**
 * iodefv2_history_item_new_incident_id:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @ret: pointer to an address where to store the created #iodefv2_incident_id_t object.
 *
 * Create a new incident_id object, children of #iodefv2_history_item_t.
 * If @ptr already contain a #iodefv2_incident_id_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_history_item_new_incident_id(iodefv2_history_item_t *ptr, iodefv2_incident_id_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->incident_id ) {
                retval = iodefv2_incident_id_new(&ptr->incident_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->incident_id;
        return 0;
}




/**
 * iodefv2_history_item_get_date_time:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 *
 * Get date_time children of the #iodefv2_history_item_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_history_item_get_date_time(iodefv2_history_item_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->date_time;

}


/**
 * iodefv2_history_item_set_date_time:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @date_time: pointer to a #iodefv2_time_t object.
 *
 * Set @date_time object as a children of @ptr.
 * if @ptr already contain an @date_time object, then it is destroyed,
 * and updated to point to the provided @date_time object.
 */

void iodefv2_history_item_set_date_time(iodefv2_history_item_t *ptr, iodefv2_time_t *date_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->date_time )
                iodefv2_time_destroy(ptr->date_time);

        ptr->date_time = date_time;
}
/**
 * iodefv2_history_item_new_date_time:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new date_time object, children of #iodefv2_history_item_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_history_item_new_date_time(iodefv2_history_item_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->date_time ) {
                retval = iodefv2_time_new(&ptr->date_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->date_time;
        return 0;
}



/**
 * iodefv2_history_item_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_history_item_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_history_item_copy(const iodefv2_history_item_t *src, iodefv2_history_item_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->action = src->action;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_action ) {
                libiodefv2_string_destroy(dst->ext_action);
                dst->ext_action = NULL;
        }

        if ( src->ext_action ) {
                ret = libiodefv2_string_clone(src->ext_action, &dst->ext_action);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->contact ) {
                iodefv2_contact_destroy(dst->contact);
                dst->contact = NULL;
        }

        if ( src->contact ) {
                ret = iodefv2_contact_clone(src->contact, &dst->contact);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->defined_coa ) {
                libiodefv2_string_destroy(dst->defined_coa);
                dst->defined_coa = NULL;
        }

        if ( src->defined_coa ) {
                ret = libiodefv2_string_clone(src->defined_coa, &dst->defined_coa);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->incident_id ) {
                iodefv2_incident_id_destroy(dst->incident_id);
                dst->incident_id = NULL;
        }

        if ( src->incident_id ) {
                ret = iodefv2_incident_id_clone(src->incident_id, &dst->incident_id);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->date_time ) {
                ret = iodefv2_time_copy(src->date_time, dst->date_time);
                if ( ret < 0 )
                        return ret;
        }
    return 0 ;
}


/**
 * iodefv2_history_item_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_history_item_clone(iodefv2_history_item_t *src, iodefv2_history_item_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_history_item_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_history_item_copy(src, *dst);
}


/**
 * iodefv2_history_item_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_history_item_compare(const iodefv2_history_item_t *obj1, const iodefv2_history_item_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->action != obj2->action )
                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_action, obj2->ext_action);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_contact_compare(obj1->contact, obj2->contact);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->defined_coa, obj2->defined_coa);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_incident_id_compare(obj1->incident_id, obj2->incident_id);
        if ( ret != 0 )
                return ret;

        ret = iodefv2_time_compare(obj1->date_time, obj2->date_time);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_fuzzy_hash_new:
 * @ret: Pointer where to store the created #iodefv2_fuzzy_hash_t object.
 *
 * Create a new #iodefv2_fuzzy_hash_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_fuzzy_hash_new(iodefv2_fuzzy_hash_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_FUZZY_HASH;


        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);





            return 0;
}


/**
 * iodefv2_fuzzy_hash_ref:
 * @fuzzy_hash: pointer to a #iodefv2_fuzzy_hash_t object.
 *
 * Increase @fuzzy_hash reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @fuzzy_hash.
 */
iodefv2_fuzzy_hash_t *iodefv2_fuzzy_hash_ref(iodefv2_fuzzy_hash_t *fuzzy_hash)
{
        libiodefv2_return_val_if_fail(fuzzy_hash, NULL);
        fuzzy_hash->refcount++;

        return fuzzy_hash;
}



int _iodefv2_fuzzy_hash_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_fuzzy_hash_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 1:
                *childptr = ptr->software;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_fuzzy_hash_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_fuzzy_hash_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_fuzzy_hash_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_fuzzy_hash_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 1:
                    return iodefv2_fuzzy_hash_new_software(ptr, (iodefv2_software_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_fuzzy_hash_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_fuzzy_hash_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
    
                case 0: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 1:
                        if ( ptr->software ) {
                                iodefv2_software_destroy(ptr->software);
                                ptr->software = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_fuzzy_hash_destroy_internal(iodefv2_fuzzy_hash_t *ptr)
{
        libiodefv2_return_if_fail(ptr);


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }


        if ( ptr->software ) {
                iodefv2_software_destroy(ptr->software);
                ptr->software = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_fuzzy_hash_destroy:
 * @ptr: pointer to a #iodefv2_fuzzy_hash_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_fuzzy_hash_destroy(iodefv2_fuzzy_hash_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_fuzzy_hash_destroy_internal(ptr);
        free(ptr);
}






/**
 * iodefv2_fuzzy_hash_get_next_additional_data:
 * @fuzzy_hash: pointer to a #iodefv2_fuzzy_hash_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_fuzzy_hash_get_next_additional_data(iodefv2_fuzzy_hash_t *fuzzy_hash, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(fuzzy_hash, NULL);

        libiodefv2_list_for_each_continue(&fuzzy_hash->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_fuzzy_hash_set_additional_data:
 * @ptr: pointer to a #iodefv2_fuzzy_hash_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_fuzzy_hash_set_additional_data(iodefv2_fuzzy_hash_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_fuzzy_hash_new_additional_data:
 *  @ptr: pointer to a #iodefv2_fuzzy_hash_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_fuzzy_hash_new_additional_data(iodefv2_fuzzy_hash_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_fuzzy_hash_get_software:
 * @ptr: pointer to a #iodefv2_fuzzy_hash_t object.
 *
 * Get software children of the #iodefv2_fuzzy_hash_t object.
 *
 * Returns: a pointer to a iodefv2_software_t object, or NULL if the children object is not set.
 */
iodefv2_software_t *iodefv2_fuzzy_hash_get_software(iodefv2_fuzzy_hash_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->software;

}


/**
 * iodefv2_fuzzy_hash_set_software:
 * @ptr: pointer to a #iodefv2_fuzzy_hash_t object.
 * @software: pointer to a #iodefv2_software_t object.
 *
 * Set @software object as a children of @ptr.
 * if @ptr already contain an @software object, then it is destroyed,
 * and updated to point to the provided @software object.
 */

void iodefv2_fuzzy_hash_set_software(iodefv2_fuzzy_hash_t *ptr, iodefv2_software_t *software)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->software )
                iodefv2_software_destroy(ptr->software);

        ptr->software = software;
}
/**
 * iodefv2_fuzzy_hash_new_software:
 * @ptr: pointer to a #iodefv2_fuzzy_hash_t object.
 * @ret: pointer to an address where to store the created #iodefv2_software_t object.
 *
 * Create a new software object, children of #iodefv2_fuzzy_hash_t.
 * If @ptr already contain a #iodefv2_software_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_fuzzy_hash_new_software(iodefv2_fuzzy_hash_t *ptr, iodefv2_software_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->software ) {
                retval = iodefv2_software_new(&ptr->software);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->software;
        return 0;
}



/**
 * iodefv2_fuzzy_hash_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_fuzzy_hash_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_fuzzy_hash_copy(const iodefv2_fuzzy_hash_t *src, iodefv2_fuzzy_hash_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->software ) {
                iodefv2_software_destroy(dst->software);
                dst->software = NULL;
        }

        if ( src->software ) {
                ret = iodefv2_software_clone(src->software, &dst->software);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_fuzzy_hash_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_fuzzy_hash_clone(iodefv2_fuzzy_hash_t *src, iodefv2_fuzzy_hash_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_fuzzy_hash_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_fuzzy_hash_copy(src, *dst);
}


/**
 * iodefv2_fuzzy_hash_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_fuzzy_hash_compare(const iodefv2_fuzzy_hash_t *obj1, const iodefv2_fuzzy_hash_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_software_compare(obj1->software, obj2->software);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_hash_new:
 * @ret: Pointer where to store the created #iodefv2_hash_t object.
 *
 * Create a new #iodefv2_hash_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_hash_new(iodefv2_hash_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_HASH;


        (*ret)->refcount = 1;

        {
            int retval = libiodefv2_string_new(&(*ret)->digest_value);

            if ( retval < 0 ) {
                    iodefv2_hash_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }

        {
            int retval = libiodefv2_string_new(&(*ret)->digest_method);

            if ( retval < 0 ) {
                    iodefv2_hash_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }



            return 0;
}


/**
 * iodefv2_hash_ref:
 * @hash: pointer to a #iodefv2_hash_t object.
 *
 * Increase @hash reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @hash.
 */
iodefv2_hash_t *iodefv2_hash_ref(iodefv2_hash_t *hash)
{
        libiodefv2_return_val_if_fail(hash, NULL);
        hash->refcount++;

        return hash;
}



int _iodefv2_hash_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_hash_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->digest_value, TRUE);



            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->digest_method, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->canonicalization_method, TRUE);



            case 3:
                *childptr = ptr->software;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_hash_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_hash_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_hash_new_digest_value(ptr, (libiodefv2_string_t **) ret);

                case 1:
                    return iodefv2_hash_new_digest_method(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_hash_new_canonicalization_method(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_hash_new_software(ptr, (iodefv2_software_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_hash_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_hash_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->digest_value ) {
                                libiodefv2_string_destroy(ptr->digest_value);
                                ptr->digest_value = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->digest_method ) {
                                libiodefv2_string_destroy(ptr->digest_method);
                                ptr->digest_method = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->canonicalization_method ) {
                                libiodefv2_string_destroy(ptr->canonicalization_method);
                                ptr->canonicalization_method = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->software ) {
                                iodefv2_software_destroy(ptr->software);
                                ptr->software = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_hash_destroy_internal(iodefv2_hash_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( ptr->digest_value ) {
                libiodefv2_string_destroy(ptr->digest_value);
                ptr->digest_value = NULL;
        }



        if ( ptr->digest_method ) {
                libiodefv2_string_destroy(ptr->digest_method);
                ptr->digest_method = NULL;
        }



        if ( ptr->canonicalization_method ) {
                libiodefv2_string_destroy(ptr->canonicalization_method);
                ptr->canonicalization_method = NULL;
        }




        if ( ptr->software ) {
                iodefv2_software_destroy(ptr->software);
                ptr->software = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_hash_destroy:
 * @ptr: pointer to a #iodefv2_hash_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_hash_destroy(iodefv2_hash_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_hash_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_hash_get_digest_value:
 * @ptr: pointer to a #iodefv2_hash_t object.
 *
 * Get digest_value children of the #iodefv2_hash_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_hash_get_digest_value(iodefv2_hash_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->digest_value;

}


/**
 * iodefv2_hash_set_digest_value:
 * @ptr: pointer to a #iodefv2_hash_t object.
 * @digest_value: pointer to a #libiodefv2_string_t object.
 *
 * Set @digest_value object as a children of @ptr.
 * if @ptr already contain an @digest_value object, then it is destroyed,
 * and updated to point to the provided @digest_value object.
 */

void iodefv2_hash_set_digest_value(iodefv2_hash_t *ptr, libiodefv2_string_t *digest_value)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->digest_value )
                libiodefv2_string_destroy(ptr->digest_value);

        ptr->digest_value = digest_value;
}
/**
 * iodefv2_hash_new_digest_value:
 * @ptr: pointer to a #iodefv2_hash_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new digest_value object, children of #iodefv2_hash_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_hash_new_digest_value(iodefv2_hash_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->digest_value ) {
                retval = libiodefv2_string_new(&ptr->digest_value);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->digest_value;
        return 0;
}




/**
 * iodefv2_hash_get_digest_method:
 * @ptr: pointer to a #iodefv2_hash_t object.
 *
 * Get digest_method children of the #iodefv2_hash_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_hash_get_digest_method(iodefv2_hash_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->digest_method;

}


/**
 * iodefv2_hash_set_digest_method:
 * @ptr: pointer to a #iodefv2_hash_t object.
 * @digest_method: pointer to a #libiodefv2_string_t object.
 *
 * Set @digest_method object as a children of @ptr.
 * if @ptr already contain an @digest_method object, then it is destroyed,
 * and updated to point to the provided @digest_method object.
 */

void iodefv2_hash_set_digest_method(iodefv2_hash_t *ptr, libiodefv2_string_t *digest_method)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->digest_method )
                libiodefv2_string_destroy(ptr->digest_method);

        ptr->digest_method = digest_method;
}
/**
 * iodefv2_hash_new_digest_method:
 * @ptr: pointer to a #iodefv2_hash_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new digest_method object, children of #iodefv2_hash_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_hash_new_digest_method(iodefv2_hash_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->digest_method ) {
                retval = libiodefv2_string_new(&ptr->digest_method);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->digest_method;
        return 0;
}




/**
 * iodefv2_hash_get_canonicalization_method:
 * @ptr: pointer to a #iodefv2_hash_t object.
 *
 * Get canonicalization_method children of the #iodefv2_hash_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_hash_get_canonicalization_method(iodefv2_hash_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->canonicalization_method;

}


/**
 * iodefv2_hash_set_canonicalization_method:
 * @ptr: pointer to a #iodefv2_hash_t object.
 * @canonicalization_method: pointer to a #libiodefv2_string_t object.
 *
 * Set @canonicalization_method object as a children of @ptr.
 * if @ptr already contain an @canonicalization_method object, then it is destroyed,
 * and updated to point to the provided @canonicalization_method object.
 */

void iodefv2_hash_set_canonicalization_method(iodefv2_hash_t *ptr, libiodefv2_string_t *canonicalization_method)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->canonicalization_method )
                libiodefv2_string_destroy(ptr->canonicalization_method);

        ptr->canonicalization_method = canonicalization_method;
}
/**
 * iodefv2_hash_new_canonicalization_method:
 * @ptr: pointer to a #iodefv2_hash_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new canonicalization_method object, children of #iodefv2_hash_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_hash_new_canonicalization_method(iodefv2_hash_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->canonicalization_method ) {
                retval = libiodefv2_string_new(&ptr->canonicalization_method);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->canonicalization_method;
        return 0;
}




/**
 * iodefv2_hash_get_software:
 * @ptr: pointer to a #iodefv2_hash_t object.
 *
 * Get software children of the #iodefv2_hash_t object.
 *
 * Returns: a pointer to a iodefv2_software_t object, or NULL if the children object is not set.
 */
iodefv2_software_t *iodefv2_hash_get_software(iodefv2_hash_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->software;

}


/**
 * iodefv2_hash_set_software:
 * @ptr: pointer to a #iodefv2_hash_t object.
 * @software: pointer to a #iodefv2_software_t object.
 *
 * Set @software object as a children of @ptr.
 * if @ptr already contain an @software object, then it is destroyed,
 * and updated to point to the provided @software object.
 */

void iodefv2_hash_set_software(iodefv2_hash_t *ptr, iodefv2_software_t *software)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->software )
                iodefv2_software_destroy(ptr->software);

        ptr->software = software;
}
/**
 * iodefv2_hash_new_software:
 * @ptr: pointer to a #iodefv2_hash_t object.
 * @ret: pointer to an address where to store the created #iodefv2_software_t object.
 *
 * Create a new software object, children of #iodefv2_hash_t.
 * If @ptr already contain a #iodefv2_software_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_hash_new_software(iodefv2_hash_t *ptr, iodefv2_software_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->software ) {
                retval = iodefv2_software_new(&ptr->software);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->software;
        return 0;
}



/**
 * iodefv2_hash_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_hash_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_hash_copy(const iodefv2_hash_t *src, iodefv2_hash_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;


        if ( src->digest_value ) {
                ret = libiodefv2_string_copy(src->digest_value, dst->digest_value);
                if ( ret < 0 )
                        return ret;
        }


        if ( src->digest_method ) {
                ret = libiodefv2_string_copy(src->digest_method, dst->digest_method);
                if ( ret < 0 )
                        return ret;
        }



        if ( dst->canonicalization_method ) {
                libiodefv2_string_destroy(dst->canonicalization_method);
                dst->canonicalization_method = NULL;
        }

        if ( src->canonicalization_method ) {
                ret = libiodefv2_string_clone(src->canonicalization_method, &dst->canonicalization_method);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->software ) {
                iodefv2_software_destroy(dst->software);
                dst->software = NULL;
        }

        if ( src->software ) {
                ret = iodefv2_software_clone(src->software, &dst->software);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_hash_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_hash_clone(iodefv2_hash_t *src, iodefv2_hash_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_hash_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_hash_copy(src, *dst);
}


/**
 * iodefv2_hash_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_hash_compare(const iodefv2_hash_t *obj1, const iodefv2_hash_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->digest_value, obj2->digest_value);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->digest_method, obj2->digest_method);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->canonicalization_method, obj2->canonicalization_method);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_software_compare(obj1->software, obj2->software);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_detection_pattern_new:
 * @ret: Pointer where to store the created #iodefv2_detection_pattern_t object.
 *
 * Create a new #iodefv2_detection_pattern_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_detection_pattern_new(iodefv2_detection_pattern_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_DETECTION_PATTERN;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;








        {
            int retval = iodefv2_software_new(&(*ret)->software);

            if ( retval < 0 ) {
                    iodefv2_detection_pattern_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }
            return 0;
}


/**
 * iodefv2_detection_pattern_ref:
 * @detection_pattern: pointer to a #iodefv2_detection_pattern_t object.
 *
 * Increase @detection_pattern reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @detection_pattern.
 */
iodefv2_detection_pattern_t *iodefv2_detection_pattern_ref(iodefv2_detection_pattern_t *detection_pattern)
{
        libiodefv2_return_val_if_fail(detection_pattern, NULL);
        detection_pattern->refcount++;

        return detection_pattern;
}



int _iodefv2_detection_pattern_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_detection_pattern_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_DETECTION_PATTERN_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);



            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->detection_configuration, TRUE);



            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);



            case 5:
                *childptr = ptr->software;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_detection_pattern_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_detection_pattern_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_detection_pattern_new_restriction(ptr, (iodefv2_detection_pattern_restriction_t **) ret);

                case 1:
                    return iodefv2_detection_pattern_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_detection_pattern_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_detection_pattern_new_detection_configuration(ptr, (libiodefv2_string_t **) ret);

                case 4:
                    return iodefv2_detection_pattern_new_description(ptr, (libiodefv2_string_t **) ret);

                case 5:
                    return iodefv2_detection_pattern_new_software(ptr, (iodefv2_software_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_detection_pattern_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_detection_pattern_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->detection_configuration ) {
                                libiodefv2_string_destroy(ptr->detection_configuration);
                                ptr->detection_configuration = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;




                case 5:
                        if ( ptr->software ) {
                                iodefv2_software_destroy(ptr->software);
                                ptr->software = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_detection_pattern_destroy_internal(iodefv2_detection_pattern_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }



        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }



        if ( ptr->detection_configuration ) {
                libiodefv2_string_destroy(ptr->detection_configuration);
                ptr->detection_configuration = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }




        if ( ptr->software ) {
                iodefv2_software_destroy(ptr->software);
                ptr->software = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_detection_pattern_destroy:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_detection_pattern_destroy(iodefv2_detection_pattern_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_detection_pattern_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_detection_pattern_get_restriction:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 *
 * Get restriction children of the #iodefv2_detection_pattern_t object.
 *
 * Returns: a pointer to a iodefv2_detection_pattern_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_detection_pattern_restriction_t *iodefv2_detection_pattern_get_restriction(iodefv2_detection_pattern_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_detection_pattern_set_restriction:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 * @restriction: pointer to a #iodefv2_detection_pattern_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_detection_pattern_set_restriction(iodefv2_detection_pattern_t *ptr, iodefv2_detection_pattern_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_detection_pattern_unset_restriction(iodefv2_detection_pattern_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_detection_pattern_new_restriction:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 * @ret: pointer to an address where to store the created #iodefv2_detection_pattern_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_detection_pattern_t.
 * If @ptr already contain a #iodefv2_detection_pattern_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_detection_pattern_new_restriction(iodefv2_detection_pattern_t *ptr, iodefv2_detection_pattern_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_detection_pattern_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 *
 * Get ext_restriction children of the #iodefv2_detection_pattern_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_detection_pattern_get_ext_restriction(iodefv2_detection_pattern_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_detection_pattern_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_detection_pattern_set_ext_restriction(iodefv2_detection_pattern_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_detection_pattern_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_detection_pattern_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_detection_pattern_new_ext_restriction(iodefv2_detection_pattern_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_detection_pattern_get_observable_id:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 *
 * Get observable_id children of the #iodefv2_detection_pattern_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_detection_pattern_get_observable_id(iodefv2_detection_pattern_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_detection_pattern_set_observable_id:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_detection_pattern_set_observable_id(iodefv2_detection_pattern_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_detection_pattern_new_observable_id:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_detection_pattern_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_detection_pattern_new_observable_id(iodefv2_detection_pattern_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}




/**
 * iodefv2_detection_pattern_get_detection_configuration:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 *
 * Get detection_configuration children of the #iodefv2_detection_pattern_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_detection_pattern_get_detection_configuration(iodefv2_detection_pattern_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->detection_configuration;

}


/**
 * iodefv2_detection_pattern_set_detection_configuration:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 * @detection_configuration: pointer to a #libiodefv2_string_t object.
 *
 * Set @detection_configuration object as a children of @ptr.
 * if @ptr already contain an @detection_configuration object, then it is destroyed,
 * and updated to point to the provided @detection_configuration object.
 */

void iodefv2_detection_pattern_set_detection_configuration(iodefv2_detection_pattern_t *ptr, libiodefv2_string_t *detection_configuration)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->detection_configuration )
                libiodefv2_string_destroy(ptr->detection_configuration);

        ptr->detection_configuration = detection_configuration;
}
/**
 * iodefv2_detection_pattern_new_detection_configuration:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new detection_configuration object, children of #iodefv2_detection_pattern_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_detection_pattern_new_detection_configuration(iodefv2_detection_pattern_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->detection_configuration ) {
                retval = libiodefv2_string_new(&ptr->detection_configuration);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->detection_configuration;
        return 0;
}




/**
 * iodefv2_detection_pattern_get_description:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 *
 * Get description children of the #iodefv2_detection_pattern_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_detection_pattern_get_description(iodefv2_detection_pattern_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_detection_pattern_set_description:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_detection_pattern_set_description(iodefv2_detection_pattern_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_detection_pattern_new_description:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_detection_pattern_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_detection_pattern_new_description(iodefv2_detection_pattern_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}




/**
 * iodefv2_detection_pattern_get_software:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 *
 * Get software children of the #iodefv2_detection_pattern_t object.
 *
 * Returns: a pointer to a iodefv2_software_t object, or NULL if the children object is not set.
 */
iodefv2_software_t *iodefv2_detection_pattern_get_software(iodefv2_detection_pattern_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->software;

}


/**
 * iodefv2_detection_pattern_set_software:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 * @software: pointer to a #iodefv2_software_t object.
 *
 * Set @software object as a children of @ptr.
 * if @ptr already contain an @software object, then it is destroyed,
 * and updated to point to the provided @software object.
 */

void iodefv2_detection_pattern_set_software(iodefv2_detection_pattern_t *ptr, iodefv2_software_t *software)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->software )
                iodefv2_software_destroy(ptr->software);

        ptr->software = software;
}
/**
 * iodefv2_detection_pattern_new_software:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 * @ret: pointer to an address where to store the created #iodefv2_software_t object.
 *
 * Create a new software object, children of #iodefv2_detection_pattern_t.
 * If @ptr already contain a #iodefv2_software_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_detection_pattern_new_software(iodefv2_detection_pattern_t *ptr, iodefv2_software_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->software ) {
                retval = iodefv2_software_new(&ptr->software);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->software;
        return 0;
}



/**
 * iodefv2_detection_pattern_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_detection_pattern_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_detection_pattern_copy(const iodefv2_detection_pattern_t *src, iodefv2_detection_pattern_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->detection_configuration ) {
                libiodefv2_string_destroy(dst->detection_configuration);
                dst->detection_configuration = NULL;
        }

        if ( src->detection_configuration ) {
                ret = libiodefv2_string_clone(src->detection_configuration, &dst->detection_configuration);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }




        if ( src->software ) {
                ret = iodefv2_software_copy(src->software, dst->software);
                if ( ret < 0 )
                        return ret;
        }
    return 0 ;
}


/**
 * iodefv2_detection_pattern_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_detection_pattern_clone(iodefv2_detection_pattern_t *src, iodefv2_detection_pattern_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_detection_pattern_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_detection_pattern_copy(src, *dst);
}


/**
 * iodefv2_detection_pattern_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_detection_pattern_compare(const iodefv2_detection_pattern_t *obj1, const iodefv2_detection_pattern_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->detection_configuration, obj2->detection_configuration);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_software_compare(obj1->software, obj2->software);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_expectation_new:
 * @ret: Pointer where to store the created #iodefv2_expectation_t object.
 *
 * Create a new #iodefv2_expectation_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_expectation_new(iodefv2_expectation_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_EXPECTATION;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;















            return 0;
}


/**
 * iodefv2_expectation_ref:
 * @expectation: pointer to a #iodefv2_expectation_t object.
 *
 * Increase @expectation reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @expectation.
 */
iodefv2_expectation_t *iodefv2_expectation_ref(iodefv2_expectation_t *expectation)
{
        libiodefv2_return_val_if_fail(expectation, NULL);
        expectation->refcount++;

        return expectation;
}



int _iodefv2_expectation_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_expectation_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_EXPECTATION_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_action, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_severity, TRUE);


            case 3:

                    if ( ! ptr->severity_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_EXPECTATION_SEVERITY , ptr->severity);

            case 4:

                    if ( ! ptr->action_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_EXPECTATION_ACTION , ptr->action);


            case 5:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);



            case 6:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->end_time, TRUE);



            case 7:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->defined_coa, TRUE);



            case 8:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);



            case 9:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->start_time, TRUE);



            case 10:
                *childptr = ptr->contact;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_expectation_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_expectation_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_expectation_new_restriction(ptr, (iodefv2_expectation_restriction_t **) ret);

                case 1:
                    return iodefv2_expectation_new_ext_action(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_expectation_new_ext_severity(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_expectation_new_severity(ptr, (iodefv2_expectation_severity_t **) ret);

                case 4:
                    return iodefv2_expectation_new_action(ptr, (iodefv2_expectation_action_t **) ret);

                case 5:
                    return iodefv2_expectation_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 6:
                    return iodefv2_expectation_new_end_time(ptr, (iodefv2_time_t **) ret);

                case 7:
                    return iodefv2_expectation_new_defined_coa(ptr, (libiodefv2_string_t **) ret);

                case 8:
                    return iodefv2_expectation_new_description(ptr, (libiodefv2_string_t **) ret);

                case 9:
                    return iodefv2_expectation_new_start_time(ptr, (iodefv2_time_t **) ret);

                case 10:
                    return iodefv2_expectation_new_contact(ptr, (iodefv2_contact_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_expectation_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_expectation_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_action ) {
                                libiodefv2_string_destroy(ptr->ext_action);
                                ptr->ext_action = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->ext_severity ) {
                                libiodefv2_string_destroy(ptr->ext_severity);
                                ptr->ext_severity = NULL;
                        }

                        return 0;

                case 3:
                        ptr->severity_is_set = 0;
                        return 0;

                case 4:
                        ptr->action_is_set = 0;
                        return 0;




                case 5:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 6:
                        if ( ptr->end_time ) {
                                iodefv2_time_destroy(ptr->end_time);
                                ptr->end_time = NULL;
                        }

                        return 0;




                case 7:
                        if ( ptr->defined_coa ) {
                                libiodefv2_string_destroy(ptr->defined_coa);
                                ptr->defined_coa = NULL;
                        }

                        return 0;




                case 8:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;




                case 9:
                        if ( ptr->start_time ) {
                                iodefv2_time_destroy(ptr->start_time);
                                ptr->start_time = NULL;
                        }

                        return 0;




                case 10:
                        if ( ptr->contact ) {
                                iodefv2_contact_destroy(ptr->contact);
                                ptr->contact = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_expectation_destroy_internal(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_action ) {
                libiodefv2_string_destroy(ptr->ext_action);
                ptr->ext_action = NULL;
        }



        if ( ptr->ext_severity ) {
                libiodefv2_string_destroy(ptr->ext_severity);
                ptr->ext_severity = NULL;
        }







        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }



        if ( ptr->end_time ) {
                iodefv2_time_destroy(ptr->end_time);
                ptr->end_time = NULL;
        }



        if ( ptr->defined_coa ) {
                libiodefv2_string_destroy(ptr->defined_coa);
                ptr->defined_coa = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }



        if ( ptr->start_time ) {
                iodefv2_time_destroy(ptr->start_time);
                ptr->start_time = NULL;
        }




        if ( ptr->contact ) {
                iodefv2_contact_destroy(ptr->contact);
                ptr->contact = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_expectation_destroy:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_expectation_destroy(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_expectation_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_expectation_get_restriction:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 *
 * Get restriction children of the #iodefv2_expectation_t object.
 *
 * Returns: a pointer to a iodefv2_expectation_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_expectation_restriction_t *iodefv2_expectation_get_restriction(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_expectation_set_restriction:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @restriction: pointer to a #iodefv2_expectation_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_expectation_set_restriction(iodefv2_expectation_t *ptr, iodefv2_expectation_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_expectation_unset_restriction(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_expectation_new_restriction:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @ret: pointer to an address where to store the created #iodefv2_expectation_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_expectation_t.
 * If @ptr already contain a #iodefv2_expectation_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_expectation_new_restriction(iodefv2_expectation_t *ptr, iodefv2_expectation_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_expectation_get_ext_action:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 *
 * Get ext_action children of the #iodefv2_expectation_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_expectation_get_ext_action(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_action;

}


/**
 * iodefv2_expectation_set_ext_action:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @ext_action: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_action object as a children of @ptr.
 * if @ptr already contain an @ext_action object, then it is destroyed,
 * and updated to point to the provided @ext_action object.
 */

void iodefv2_expectation_set_ext_action(iodefv2_expectation_t *ptr, libiodefv2_string_t *ext_action)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_action )
                libiodefv2_string_destroy(ptr->ext_action);

        ptr->ext_action = ext_action;
}
/**
 * iodefv2_expectation_new_ext_action:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_action object, children of #iodefv2_expectation_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_expectation_new_ext_action(iodefv2_expectation_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_action ) {
                retval = libiodefv2_string_new(&ptr->ext_action);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_action;
        return 0;
}




/**
 * iodefv2_expectation_get_ext_severity:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 *
 * Get ext_severity children of the #iodefv2_expectation_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_expectation_get_ext_severity(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_severity;

}


/**
 * iodefv2_expectation_set_ext_severity:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @ext_severity: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_severity object as a children of @ptr.
 * if @ptr already contain an @ext_severity object, then it is destroyed,
 * and updated to point to the provided @ext_severity object.
 */

void iodefv2_expectation_set_ext_severity(iodefv2_expectation_t *ptr, libiodefv2_string_t *ext_severity)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_severity )
                libiodefv2_string_destroy(ptr->ext_severity);

        ptr->ext_severity = ext_severity;
}
/**
 * iodefv2_expectation_new_ext_severity:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_severity object, children of #iodefv2_expectation_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_expectation_new_ext_severity(iodefv2_expectation_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_severity ) {
                retval = libiodefv2_string_new(&ptr->ext_severity);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_severity;
        return 0;
}




/**
 * iodefv2_expectation_get_severity:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 *
 * Get severity children of the #iodefv2_expectation_t object.
 *
 * Returns: a pointer to a iodefv2_expectation_severity_t object, or NULL if the children object is not set.
 */
iodefv2_expectation_severity_t *iodefv2_expectation_get_severity(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->severity_is_set ? &ptr->severity : NULL;


}


/**
 * iodefv2_expectation_set_severity:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @severity: pointer to a #iodefv2_expectation_severity_t object.
 *
 * Set @severity object as a children of @ptr.
 * if @ptr already contain an @severity object, then it is destroyed,
 * and updated to point to the provided @severity object.
 */
void iodefv2_expectation_set_severity(iodefv2_expectation_t *ptr, iodefv2_expectation_severity_t severity)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity = severity;
        ptr->severity_is_set = 1;
}

void iodefv2_expectation_unset_severity(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity_is_set = 0;
}
/**
 * iodefv2_expectation_new_severity:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @ret: pointer to an address where to store the created #iodefv2_expectation_severity_t object.
 *
 * Create a new severity object, children of #iodefv2_expectation_t.
 * If @ptr already contain a #iodefv2_expectation_severity_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_expectation_new_severity(iodefv2_expectation_t *ptr, iodefv2_expectation_severity_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->severity_is_set = 1;



        *ret = &ptr->severity;
        return 0;
}




/**
 * iodefv2_expectation_get_action:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 *
 * Get action children of the #iodefv2_expectation_t object.
 *
 * Returns: a pointer to a iodefv2_expectation_action_t object, or NULL if the children object is not set.
 */
iodefv2_expectation_action_t *iodefv2_expectation_get_action(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->action_is_set ? &ptr->action : NULL;


}


/**
 * iodefv2_expectation_set_action:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @action: pointer to a #iodefv2_expectation_action_t object.
 *
 * Set @action object as a children of @ptr.
 * if @ptr already contain an @action object, then it is destroyed,
 * and updated to point to the provided @action object.
 */
void iodefv2_expectation_set_action(iodefv2_expectation_t *ptr, iodefv2_expectation_action_t action)
{
        libiodefv2_return_if_fail(ptr);
        ptr->action = action;
        ptr->action_is_set = 1;
}

void iodefv2_expectation_unset_action(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->action_is_set = 0;
}
/**
 * iodefv2_expectation_new_action:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @ret: pointer to an address where to store the created #iodefv2_expectation_action_t object.
 *
 * Create a new action object, children of #iodefv2_expectation_t.
 * If @ptr already contain a #iodefv2_expectation_action_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_expectation_new_action(iodefv2_expectation_t *ptr, iodefv2_expectation_action_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->action_is_set = 1;



        *ret = &ptr->action;
        return 0;
}




/**
 * iodefv2_expectation_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 *
 * Get ext_restriction children of the #iodefv2_expectation_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_expectation_get_ext_restriction(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_expectation_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_expectation_set_ext_restriction(iodefv2_expectation_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_expectation_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_expectation_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_expectation_new_ext_restriction(iodefv2_expectation_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_expectation_get_end_time:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 *
 * Get end_time children of the #iodefv2_expectation_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_expectation_get_end_time(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->end_time;

}


/**
 * iodefv2_expectation_set_end_time:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @end_time: pointer to a #iodefv2_time_t object.
 *
 * Set @end_time object as a children of @ptr.
 * if @ptr already contain an @end_time object, then it is destroyed,
 * and updated to point to the provided @end_time object.
 */

void iodefv2_expectation_set_end_time(iodefv2_expectation_t *ptr, iodefv2_time_t *end_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->end_time )
                iodefv2_time_destroy(ptr->end_time);

        ptr->end_time = end_time;
}
/**
 * iodefv2_expectation_new_end_time:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new end_time object, children of #iodefv2_expectation_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_expectation_new_end_time(iodefv2_expectation_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->end_time ) {
                retval = iodefv2_time_new(&ptr->end_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->end_time;
        return 0;
}




/**
 * iodefv2_expectation_get_defined_coa:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 *
 * Get defined_coa children of the #iodefv2_expectation_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_expectation_get_defined_coa(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->defined_coa;

}


/**
 * iodefv2_expectation_set_defined_coa:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @defined_coa: pointer to a #libiodefv2_string_t object.
 *
 * Set @defined_coa object as a children of @ptr.
 * if @ptr already contain an @defined_coa object, then it is destroyed,
 * and updated to point to the provided @defined_coa object.
 */

void iodefv2_expectation_set_defined_coa(iodefv2_expectation_t *ptr, libiodefv2_string_t *defined_coa)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->defined_coa )
                libiodefv2_string_destroy(ptr->defined_coa);

        ptr->defined_coa = defined_coa;
}
/**
 * iodefv2_expectation_new_defined_coa:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new defined_coa object, children of #iodefv2_expectation_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_expectation_new_defined_coa(iodefv2_expectation_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->defined_coa ) {
                retval = libiodefv2_string_new(&ptr->defined_coa);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->defined_coa;
        return 0;
}




/**
 * iodefv2_expectation_get_description:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 *
 * Get description children of the #iodefv2_expectation_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_expectation_get_description(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_expectation_set_description:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_expectation_set_description(iodefv2_expectation_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_expectation_new_description:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_expectation_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_expectation_new_description(iodefv2_expectation_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}




/**
 * iodefv2_expectation_get_start_time:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 *
 * Get start_time children of the #iodefv2_expectation_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_expectation_get_start_time(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->start_time;

}


/**
 * iodefv2_expectation_set_start_time:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @start_time: pointer to a #iodefv2_time_t object.
 *
 * Set @start_time object as a children of @ptr.
 * if @ptr already contain an @start_time object, then it is destroyed,
 * and updated to point to the provided @start_time object.
 */

void iodefv2_expectation_set_start_time(iodefv2_expectation_t *ptr, iodefv2_time_t *start_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->start_time )
                iodefv2_time_destroy(ptr->start_time);

        ptr->start_time = start_time;
}
/**
 * iodefv2_expectation_new_start_time:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new start_time object, children of #iodefv2_expectation_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_expectation_new_start_time(iodefv2_expectation_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->start_time ) {
                retval = iodefv2_time_new(&ptr->start_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->start_time;
        return 0;
}




/**
 * iodefv2_expectation_get_contact:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 *
 * Get contact children of the #iodefv2_expectation_t object.
 *
 * Returns: a pointer to a iodefv2_contact_t object, or NULL if the children object is not set.
 */
iodefv2_contact_t *iodefv2_expectation_get_contact(iodefv2_expectation_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->contact;

}


/**
 * iodefv2_expectation_set_contact:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @contact: pointer to a #iodefv2_contact_t object.
 *
 * Set @contact object as a children of @ptr.
 * if @ptr already contain an @contact object, then it is destroyed,
 * and updated to point to the provided @contact object.
 */

void iodefv2_expectation_set_contact(iodefv2_expectation_t *ptr, iodefv2_contact_t *contact)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->contact )
                iodefv2_contact_destroy(ptr->contact);

        ptr->contact = contact;
}
/**
 * iodefv2_expectation_new_contact:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 * @ret: pointer to an address where to store the created #iodefv2_contact_t object.
 *
 * Create a new contact object, children of #iodefv2_expectation_t.
 * If @ptr already contain a #iodefv2_contact_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_expectation_new_contact(iodefv2_expectation_t *ptr, iodefv2_contact_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->contact ) {
                retval = iodefv2_contact_new(&ptr->contact);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->contact;
        return 0;
}



/**
 * iodefv2_expectation_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_expectation_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_expectation_copy(const iodefv2_expectation_t *src, iodefv2_expectation_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_action ) {
                libiodefv2_string_destroy(dst->ext_action);
                dst->ext_action = NULL;
        }

        if ( src->ext_action ) {
                ret = libiodefv2_string_clone(src->ext_action, &dst->ext_action);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->ext_severity ) {
                libiodefv2_string_destroy(dst->ext_severity);
                dst->ext_severity = NULL;
        }

        if ( src->ext_severity ) {
                ret = libiodefv2_string_clone(src->ext_severity, &dst->ext_severity);
                if ( ret < 0 )
                        return ret;
        }




        dst->severity_is_set = src->severity_is_set;
        dst->severity = src->severity;



        dst->action_is_set = src->action_is_set;
        dst->action = src->action;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->end_time ) {
                iodefv2_time_destroy(dst->end_time);
                dst->end_time = NULL;
        }

        if ( src->end_time ) {
                ret = iodefv2_time_clone(src->end_time, &dst->end_time);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->defined_coa ) {
                libiodefv2_string_destroy(dst->defined_coa);
                dst->defined_coa = NULL;
        }

        if ( src->defined_coa ) {
                ret = libiodefv2_string_clone(src->defined_coa, &dst->defined_coa);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->start_time ) {
                iodefv2_time_destroy(dst->start_time);
                dst->start_time = NULL;
        }

        if ( src->start_time ) {
                ret = iodefv2_time_clone(src->start_time, &dst->start_time);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->contact ) {
                iodefv2_contact_destroy(dst->contact);
                dst->contact = NULL;
        }

        if ( src->contact ) {
                ret = iodefv2_contact_clone(src->contact, &dst->contact);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_expectation_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_expectation_clone(iodefv2_expectation_t *src, iodefv2_expectation_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_expectation_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_expectation_copy(src, *dst);
}


/**
 * iodefv2_expectation_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_expectation_compare(const iodefv2_expectation_t *obj1, const iodefv2_expectation_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_action, obj2->ext_action);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->ext_severity, obj2->ext_severity);
        if ( ret != 0 )
                return ret;


        if ( obj1->severity_is_set != obj2->severity_is_set )
                return -1;

        if ( obj1->severity_is_set && obj1->severity != obj2->severity )
                return -1;



        if ( obj1->action_is_set != obj2->action_is_set )
                return -1;

        if ( obj1->action_is_set && obj1->action != obj2->action )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;

        ret = iodefv2_time_compare(obj1->end_time, obj2->end_time);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->defined_coa, obj2->defined_coa);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;

        ret = iodefv2_time_compare(obj1->start_time, obj2->start_time);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_contact_compare(obj1->contact, obj2->contact);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_domain_data_new:
 * @ret: Pointer where to store the created #iodefv2_domain_data_t object.
 *
 * Create a new #iodefv2_domain_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_domain_data_new(iodefv2_domain_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_DOMAIN_DATA;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);


        libiodefv2_list_init(&(*ret)->nameservers_list);











        {
            int retval = libiodefv2_string_new(&(*ret)->name);

            if ( retval < 0 ) {
                    iodefv2_domain_data_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }







            return 0;
}


/**
 * iodefv2_domain_data_ref:
 * @domain_data: pointer to a #iodefv2_domain_data_t object.
 *
 * Increase @domain_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @domain_data.
 */
iodefv2_domain_data_t *iodefv2_domain_data_ref(iodefv2_domain_data_t *domain_data)
{
        libiodefv2_return_val_if_fail(domain_data, NULL);
        domain_data->refcount++;

        return domain_data;
}



int _iodefv2_domain_data_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_domain_data_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_domain_status, TRUE);


            case 1:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_DOMAIN_DATA_DOMAIN_STATUS , ptr->domain_status);


            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_system_status, TRUE);



            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);


            case 4:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_DOMAIN_DATA_SYSTEM_STATUS , ptr->system_status);

            case 5:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 6:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->name, TRUE);


            case 7:
                *childptr = &ptr->nameservers_list;
                return 0;


            case 8:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->registration_date, TRUE);



            case 9:
                *childptr = ptr->domain_contacts;
                return 0;


            case 10:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->date_domain_was_checked, TRUE);



            case 11:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->expiration_date, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_domain_data_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_domain_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_domain_data_new_ext_domain_status(ptr, (libiodefv2_string_t **) ret);

                case 1:
                    return iodefv2_domain_data_new_domain_status(ptr, (iodefv2_domain_data_domain_status_t **) ret);

                case 2:
                    return iodefv2_domain_data_new_ext_system_status(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_domain_data_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 4:
                    return iodefv2_domain_data_new_system_status(ptr, (iodefv2_domain_data_system_status_t **) ret);

                case 5: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_domain_data_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_domain_data_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 6:
                    return iodefv2_domain_data_new_name(ptr, (libiodefv2_string_t **) ret);

                case 7: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_domain_data_new_nameservers(ptr, (iodefv2_nameservers_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->nameservers_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->nameservers_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_domain_data_new_nameservers(ptr, (iodefv2_nameservers_t **) ret, n);
                }

                case 8:
                    return iodefv2_domain_data_new_registration_date(ptr, (iodefv2_time_t **) ret);

                case 9:
                    return iodefv2_domain_data_new_domain_contacts(ptr, (iodefv2_domain_contacts_t **) ret);

                case 10:
                    return iodefv2_domain_data_new_date_domain_was_checked(ptr, (iodefv2_time_t **) ret);

                case 11:
                    return iodefv2_domain_data_new_expiration_date(ptr, (iodefv2_time_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_domain_data_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_domain_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->ext_domain_status ) {
                                libiodefv2_string_destroy(ptr->ext_domain_status);
                                ptr->ext_domain_status = NULL;
                        }

                        return 0;




                case 1:
                    ptr->domain_status = 0;
                    return 0;




                case 2:
                        if ( ptr->ext_system_status ) {
                                libiodefv2_string_destroy(ptr->ext_system_status);
                                ptr->ext_system_status = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;




                case 4:
                    ptr->system_status = 0;
                    return 0;

    
                case 5: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 6:
                        if ( ptr->name ) {
                                libiodefv2_string_destroy(ptr->name);
                                ptr->name = NULL;
                        }

                        return 0;

    
                case 7: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->nameservers_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_nameservers_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->nameservers_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_nameservers_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 8:
                        if ( ptr->registration_date ) {
                                iodefv2_time_destroy(ptr->registration_date);
                                ptr->registration_date = NULL;
                        }

                        return 0;




                case 9:
                        if ( ptr->domain_contacts ) {
                                iodefv2_domain_contacts_destroy(ptr->domain_contacts);
                                ptr->domain_contacts = NULL;
                        }

                        return 0;




                case 10:
                        if ( ptr->date_domain_was_checked ) {
                                iodefv2_time_destroy(ptr->date_domain_was_checked);
                                ptr->date_domain_was_checked = NULL;
                        }

                        return 0;




                case 11:
                        if ( ptr->expiration_date ) {
                                iodefv2_time_destroy(ptr->expiration_date);
                                ptr->expiration_date = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_domain_data_destroy_internal(iodefv2_domain_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->ext_domain_status ) {
                libiodefv2_string_destroy(ptr->ext_domain_status);
                ptr->ext_domain_status = NULL;
        }





        if ( ptr->ext_system_status ) {
                libiodefv2_string_destroy(ptr->ext_system_status);
                ptr->ext_system_status = NULL;
        }



        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }






        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }

        if ( ptr->name ) {
                libiodefv2_string_destroy(ptr->name);
                ptr->name = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_nameservers_t *entry;

                libiodefv2_list_for_each_safe(&ptr->nameservers_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_nameservers_destroy(entry);
                }
        }

        if ( ptr->registration_date ) {
                iodefv2_time_destroy(ptr->registration_date);
                ptr->registration_date = NULL;
        }




        if ( ptr->domain_contacts ) {
                iodefv2_domain_contacts_destroy(ptr->domain_contacts);
                ptr->domain_contacts = NULL;
        }



        if ( ptr->date_domain_was_checked ) {
                iodefv2_time_destroy(ptr->date_domain_was_checked);
                ptr->date_domain_was_checked = NULL;
        }



        if ( ptr->expiration_date ) {
                iodefv2_time_destroy(ptr->expiration_date);
                ptr->expiration_date = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_domain_data_destroy:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_domain_data_destroy(iodefv2_domain_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_domain_data_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_domain_data_get_ext_domain_status:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 *
 * Get ext_domain_status children of the #iodefv2_domain_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_domain_data_get_ext_domain_status(iodefv2_domain_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_domain_status;

}


/**
 * iodefv2_domain_data_set_ext_domain_status:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @ext_domain_status: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_domain_status object as a children of @ptr.
 * if @ptr already contain an @ext_domain_status object, then it is destroyed,
 * and updated to point to the provided @ext_domain_status object.
 */

void iodefv2_domain_data_set_ext_domain_status(iodefv2_domain_data_t *ptr, libiodefv2_string_t *ext_domain_status)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_domain_status )
                libiodefv2_string_destroy(ptr->ext_domain_status);

        ptr->ext_domain_status = ext_domain_status;
}
/**
 * iodefv2_domain_data_new_ext_domain_status:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_domain_status object, children of #iodefv2_domain_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_domain_data_new_ext_domain_status(iodefv2_domain_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_domain_status ) {
                retval = libiodefv2_string_new(&ptr->ext_domain_status);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_domain_status;
        return 0;
}



/**
 * iodefv2_domain_data_get_domain_status:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 *
 * Get domain_status children of the #iodefv2_domain_data_t object.
 *
 * Returns: a pointer to a iodefv2_domain_data_domain_status_t object, or NULL if the children object is not set.
 */
iodefv2_domain_data_domain_status_t iodefv2_domain_data_get_domain_status(iodefv2_domain_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->domain_status;

}


/**
 * iodefv2_domain_data_set_domain_status:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @domain_status: pointer to a #iodefv2_domain_data_domain_status_t object.
 *
 * Set @domain_status object as a children of @ptr.
 * if @ptr already contain an @domain_status object, then it is destroyed,
 * and updated to point to the provided @domain_status object.
 */
void iodefv2_domain_data_set_domain_status(iodefv2_domain_data_t *ptr, iodefv2_domain_data_domain_status_t domain_status)
{
        libiodefv2_return_if_fail(ptr);
        ptr->domain_status = domain_status;
}
/**
 * iodefv2_domain_data_new_domain_status:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_domain_data_domain_status_t object.
 *
 * Create a new domain_status object, children of #iodefv2_domain_data_t.
 * If @ptr already contain a #iodefv2_domain_data_domain_status_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_domain_data_new_domain_status(iodefv2_domain_data_t *ptr, iodefv2_domain_data_domain_status_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->domain_status;
        return 0;
}




/**
 * iodefv2_domain_data_get_ext_system_status:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 *
 * Get ext_system_status children of the #iodefv2_domain_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_domain_data_get_ext_system_status(iodefv2_domain_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_system_status;

}


/**
 * iodefv2_domain_data_set_ext_system_status:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @ext_system_status: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_system_status object as a children of @ptr.
 * if @ptr already contain an @ext_system_status object, then it is destroyed,
 * and updated to point to the provided @ext_system_status object.
 */

void iodefv2_domain_data_set_ext_system_status(iodefv2_domain_data_t *ptr, libiodefv2_string_t *ext_system_status)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_system_status )
                libiodefv2_string_destroy(ptr->ext_system_status);

        ptr->ext_system_status = ext_system_status;
}
/**
 * iodefv2_domain_data_new_ext_system_status:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_system_status object, children of #iodefv2_domain_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_domain_data_new_ext_system_status(iodefv2_domain_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_system_status ) {
                retval = libiodefv2_string_new(&ptr->ext_system_status);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_system_status;
        return 0;
}




/**
 * iodefv2_domain_data_get_observable_id:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 *
 * Get observable_id children of the #iodefv2_domain_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_domain_data_get_observable_id(iodefv2_domain_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_domain_data_set_observable_id:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_domain_data_set_observable_id(iodefv2_domain_data_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_domain_data_new_observable_id:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_domain_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_domain_data_new_observable_id(iodefv2_domain_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}



/**
 * iodefv2_domain_data_get_system_status:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 *
 * Get system_status children of the #iodefv2_domain_data_t object.
 *
 * Returns: a pointer to a iodefv2_domain_data_system_status_t object, or NULL if the children object is not set.
 */
iodefv2_domain_data_system_status_t iodefv2_domain_data_get_system_status(iodefv2_domain_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->system_status;

}


/**
 * iodefv2_domain_data_set_system_status:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @system_status: pointer to a #iodefv2_domain_data_system_status_t object.
 *
 * Set @system_status object as a children of @ptr.
 * if @ptr already contain an @system_status object, then it is destroyed,
 * and updated to point to the provided @system_status object.
 */
void iodefv2_domain_data_set_system_status(iodefv2_domain_data_t *ptr, iodefv2_domain_data_system_status_t system_status)
{
        libiodefv2_return_if_fail(ptr);
        ptr->system_status = system_status;
}
/**
 * iodefv2_domain_data_new_system_status:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_domain_data_system_status_t object.
 *
 * Create a new system_status object, children of #iodefv2_domain_data_t.
 * If @ptr already contain a #iodefv2_domain_data_system_status_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_domain_data_new_system_status(iodefv2_domain_data_t *ptr, iodefv2_domain_data_system_status_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->system_status;
        return 0;
}





/**
 * iodefv2_domain_data_get_next_additional_data:
 * @domain_data: pointer to a #iodefv2_domain_data_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_domain_data_get_next_additional_data(iodefv2_domain_data_t *domain_data, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(domain_data, NULL);

        libiodefv2_list_for_each_continue(&domain_data->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_domain_data_set_additional_data:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_domain_data_set_additional_data(iodefv2_domain_data_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_domain_data_new_additional_data:
 *  @ptr: pointer to a #iodefv2_domain_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_domain_data_new_additional_data(iodefv2_domain_data_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_domain_data_get_name:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 *
 * Get name children of the #iodefv2_domain_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_domain_data_get_name(iodefv2_domain_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->name;

}


/**
 * iodefv2_domain_data_set_name:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @name: pointer to a #libiodefv2_string_t object.
 *
 * Set @name object as a children of @ptr.
 * if @ptr already contain an @name object, then it is destroyed,
 * and updated to point to the provided @name object.
 */

void iodefv2_domain_data_set_name(iodefv2_domain_data_t *ptr, libiodefv2_string_t *name)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->name )
                libiodefv2_string_destroy(ptr->name);

        ptr->name = name;
}
/**
 * iodefv2_domain_data_new_name:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new name object, children of #iodefv2_domain_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_domain_data_new_name(iodefv2_domain_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->name ) {
                retval = libiodefv2_string_new(&ptr->name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->name;
        return 0;
}





/**
 * iodefv2_domain_data_get_next_nameservers:
 * @domain_data: pointer to a #iodefv2_domain_data_t object.
 * @nameservers_cur: pointer to a #iodefv2_nameservers_t object.
 *
 * Get the next #iodefv2_nameservers_t object listed in @ptr.
 * When iterating over the iodefv2_nameservers_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_nameservers_t object.
 *
 * Returns: the next #iodefv2_nameservers_t in the list.
 */
iodefv2_nameservers_t *iodefv2_domain_data_get_next_nameservers(iodefv2_domain_data_t *domain_data, iodefv2_nameservers_t *nameservers_cur)
{
        libiodefv2_list_t *tmp = (nameservers_cur) ? &((libiodefv2_linked_object_t *) nameservers_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(domain_data, NULL);

        libiodefv2_list_for_each_continue(&domain_data->nameservers_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_domain_data_set_nameservers:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @object: pointer to a #iodefv2_nameservers_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_nameservers_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_domain_data_set_nameservers(iodefv2_domain_data_t *ptr, iodefv2_nameservers_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->nameservers_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_domain_data_new_nameservers:
 *  @ptr: pointer to a #iodefv2_domain_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_nameservers_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_nameservers_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_nameservers_t object. The created #iodefv2_nameservers_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_domain_data_new_nameservers(iodefv2_domain_data_t *ptr, iodefv2_nameservers_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_nameservers_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->nameservers_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_domain_data_get_registration_date:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 *
 * Get registration_date children of the #iodefv2_domain_data_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_domain_data_get_registration_date(iodefv2_domain_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->registration_date;

}


/**
 * iodefv2_domain_data_set_registration_date:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @registration_date: pointer to a #iodefv2_time_t object.
 *
 * Set @registration_date object as a children of @ptr.
 * if @ptr already contain an @registration_date object, then it is destroyed,
 * and updated to point to the provided @registration_date object.
 */

void iodefv2_domain_data_set_registration_date(iodefv2_domain_data_t *ptr, iodefv2_time_t *registration_date)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->registration_date )
                iodefv2_time_destroy(ptr->registration_date);

        ptr->registration_date = registration_date;
}
/**
 * iodefv2_domain_data_new_registration_date:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new registration_date object, children of #iodefv2_domain_data_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_domain_data_new_registration_date(iodefv2_domain_data_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->registration_date ) {
                retval = iodefv2_time_new(&ptr->registration_date);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->registration_date;
        return 0;
}




/**
 * iodefv2_domain_data_get_domain_contacts:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 *
 * Get domain_contacts children of the #iodefv2_domain_data_t object.
 *
 * Returns: a pointer to a iodefv2_domain_contacts_t object, or NULL if the children object is not set.
 */
iodefv2_domain_contacts_t *iodefv2_domain_data_get_domain_contacts(iodefv2_domain_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->domain_contacts;

}


/**
 * iodefv2_domain_data_set_domain_contacts:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @domain_contacts: pointer to a #iodefv2_domain_contacts_t object.
 *
 * Set @domain_contacts object as a children of @ptr.
 * if @ptr already contain an @domain_contacts object, then it is destroyed,
 * and updated to point to the provided @domain_contacts object.
 */

void iodefv2_domain_data_set_domain_contacts(iodefv2_domain_data_t *ptr, iodefv2_domain_contacts_t *domain_contacts)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->domain_contacts )
                iodefv2_domain_contacts_destroy(ptr->domain_contacts);

        ptr->domain_contacts = domain_contacts;
}
/**
 * iodefv2_domain_data_new_domain_contacts:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_domain_contacts_t object.
 *
 * Create a new domain_contacts object, children of #iodefv2_domain_data_t.
 * If @ptr already contain a #iodefv2_domain_contacts_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_domain_data_new_domain_contacts(iodefv2_domain_data_t *ptr, iodefv2_domain_contacts_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->domain_contacts ) {
                retval = iodefv2_domain_contacts_new(&ptr->domain_contacts);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->domain_contacts;
        return 0;
}




/**
 * iodefv2_domain_data_get_date_domain_was_checked:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 *
 * Get date_domain_was_checked children of the #iodefv2_domain_data_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_domain_data_get_date_domain_was_checked(iodefv2_domain_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->date_domain_was_checked;

}


/**
 * iodefv2_domain_data_set_date_domain_was_checked:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @date_domain_was_checked: pointer to a #iodefv2_time_t object.
 *
 * Set @date_domain_was_checked object as a children of @ptr.
 * if @ptr already contain an @date_domain_was_checked object, then it is destroyed,
 * and updated to point to the provided @date_domain_was_checked object.
 */

void iodefv2_domain_data_set_date_domain_was_checked(iodefv2_domain_data_t *ptr, iodefv2_time_t *date_domain_was_checked)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->date_domain_was_checked )
                iodefv2_time_destroy(ptr->date_domain_was_checked);

        ptr->date_domain_was_checked = date_domain_was_checked;
}
/**
 * iodefv2_domain_data_new_date_domain_was_checked:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new date_domain_was_checked object, children of #iodefv2_domain_data_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_domain_data_new_date_domain_was_checked(iodefv2_domain_data_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->date_domain_was_checked ) {
                retval = iodefv2_time_new(&ptr->date_domain_was_checked);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->date_domain_was_checked;
        return 0;
}




/**
 * iodefv2_domain_data_get_expiration_date:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 *
 * Get expiration_date children of the #iodefv2_domain_data_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_domain_data_get_expiration_date(iodefv2_domain_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->expiration_date;

}


/**
 * iodefv2_domain_data_set_expiration_date:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @expiration_date: pointer to a #iodefv2_time_t object.
 *
 * Set @expiration_date object as a children of @ptr.
 * if @ptr already contain an @expiration_date object, then it is destroyed,
 * and updated to point to the provided @expiration_date object.
 */

void iodefv2_domain_data_set_expiration_date(iodefv2_domain_data_t *ptr, iodefv2_time_t *expiration_date)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->expiration_date )
                iodefv2_time_destroy(ptr->expiration_date);

        ptr->expiration_date = expiration_date;
}
/**
 * iodefv2_domain_data_new_expiration_date:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new expiration_date object, children of #iodefv2_domain_data_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_domain_data_new_expiration_date(iodefv2_domain_data_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->expiration_date ) {
                retval = iodefv2_time_new(&ptr->expiration_date);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->expiration_date;
        return 0;
}



/**
 * iodefv2_domain_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_domain_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_domain_data_copy(const iodefv2_domain_data_t *src, iodefv2_domain_data_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->ext_domain_status ) {
                libiodefv2_string_destroy(dst->ext_domain_status);
                dst->ext_domain_status = NULL;
        }

        if ( src->ext_domain_status ) {
                ret = libiodefv2_string_clone(src->ext_domain_status, &dst->ext_domain_status);
                if ( ret < 0 )
                        return ret;
        }




        dst->domain_status = src->domain_status;



        if ( dst->ext_system_status ) {
                libiodefv2_string_destroy(dst->ext_system_status);
                dst->ext_system_status = NULL;
        }

        if ( src->ext_system_status ) {
                ret = libiodefv2_string_clone(src->ext_system_status, &dst->ext_system_status);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }




        dst->system_status = src->system_status;



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }


        if ( src->name ) {
                ret = libiodefv2_string_copy(src->name, dst->name);
                if ( ret < 0 )
                        return ret;
        }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_nameservers_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->nameservers_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_nameservers_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->nameservers_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_nameservers_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->nameservers_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->registration_date ) {
                iodefv2_time_destroy(dst->registration_date);
                dst->registration_date = NULL;
        }

        if ( src->registration_date ) {
                ret = iodefv2_time_clone(src->registration_date, &dst->registration_date);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->domain_contacts ) {
                iodefv2_domain_contacts_destroy(dst->domain_contacts);
                dst->domain_contacts = NULL;
        }

        if ( src->domain_contacts ) {
                ret = iodefv2_domain_contacts_clone(src->domain_contacts, &dst->domain_contacts);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->date_domain_was_checked ) {
                iodefv2_time_destroy(dst->date_domain_was_checked);
                dst->date_domain_was_checked = NULL;
        }

        if ( src->date_domain_was_checked ) {
                ret = iodefv2_time_clone(src->date_domain_was_checked, &dst->date_domain_was_checked);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->expiration_date ) {
                iodefv2_time_destroy(dst->expiration_date);
                dst->expiration_date = NULL;
        }

        if ( src->expiration_date ) {
                ret = iodefv2_time_clone(src->expiration_date, &dst->expiration_date);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_domain_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_domain_data_clone(iodefv2_domain_data_t *src, iodefv2_domain_data_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_domain_data_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_domain_data_copy(src, *dst);
}


/**
 * iodefv2_domain_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_domain_data_compare(const iodefv2_domain_data_t *obj1, const iodefv2_domain_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->ext_domain_status, obj2->ext_domain_status);
        if ( ret != 0 )
                return ret;


        if ( obj1->domain_status != obj2->domain_status )
                return -1;

        ret = libiodefv2_string_compare(obj1->ext_system_status, obj2->ext_system_status);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;


        if ( obj1->system_status != obj2->system_status )
                return -1;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->name, obj2->name);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_nameservers_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->nameservers_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->nameservers_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_nameservers_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = iodefv2_time_compare(obj1->registration_date, obj2->registration_date);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_domain_contacts_compare(obj1->domain_contacts, obj2->domain_contacts);
        if ( ret != 0 )
                return ret;

        ret = iodefv2_time_compare(obj1->date_domain_was_checked, obj2->date_domain_was_checked);
        if ( ret != 0 )
                return ret;

        ret = iodefv2_time_compare(obj1->expiration_date, obj2->expiration_date);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_hash_data_new:
 * @ret: Pointer where to store the created #iodefv2_hash_data_t object.
 *
 * Create a new #iodefv2_hash_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_hash_data_new(iodefv2_hash_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_HASH_DATA;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;








            return 0;
}


/**
 * iodefv2_hash_data_ref:
 * @hash_data: pointer to a #iodefv2_hash_data_t object.
 *
 * Increase @hash_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @hash_data.
 */
iodefv2_hash_data_t *iodefv2_hash_data_ref(iodefv2_hash_data_t *hash_data)
{
        libiodefv2_return_val_if_fail(hash_data, NULL);
        hash_data->refcount++;

        return hash_data;
}



int _iodefv2_hash_data_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_hash_data_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->scope_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_HASH_DATA_SCOPE , ptr->scope);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_scope, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->hash_target_id, TRUE);



            case 3:
                *childptr = ptr->hash;
                return 0;


            case 4:
                *childptr = ptr->fuzzy_hash;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_hash_data_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_hash_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_hash_data_new_scope(ptr, (iodefv2_hash_data_scope_t **) ret);

                case 1:
                    return iodefv2_hash_data_new_ext_scope(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_hash_data_new_hash_target_id(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_hash_data_new_hash(ptr, (iodefv2_hash_t **) ret);

                case 4:
                    return iodefv2_hash_data_new_fuzzy_hash(ptr, (iodefv2_fuzzy_hash_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_hash_data_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_hash_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->scope_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_scope ) {
                                libiodefv2_string_destroy(ptr->ext_scope);
                                ptr->ext_scope = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->hash_target_id ) {
                                libiodefv2_string_destroy(ptr->hash_target_id);
                                ptr->hash_target_id = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->hash ) {
                                iodefv2_hash_destroy(ptr->hash);
                                ptr->hash = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->fuzzy_hash ) {
                                iodefv2_fuzzy_hash_destroy(ptr->fuzzy_hash);
                                ptr->fuzzy_hash = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_hash_data_destroy_internal(iodefv2_hash_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_scope ) {
                libiodefv2_string_destroy(ptr->ext_scope);
                ptr->ext_scope = NULL;
        }



        if ( ptr->hash_target_id ) {
                libiodefv2_string_destroy(ptr->hash_target_id);
                ptr->hash_target_id = NULL;
        }




        if ( ptr->hash ) {
                iodefv2_hash_destroy(ptr->hash);
                ptr->hash = NULL;
        }




        if ( ptr->fuzzy_hash ) {
                iodefv2_fuzzy_hash_destroy(ptr->fuzzy_hash);
                ptr->fuzzy_hash = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_hash_data_destroy:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_hash_data_destroy(iodefv2_hash_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_hash_data_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_hash_data_get_scope:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 *
 * Get scope children of the #iodefv2_hash_data_t object.
 *
 * Returns: a pointer to a iodefv2_hash_data_scope_t object, or NULL if the children object is not set.
 */
iodefv2_hash_data_scope_t *iodefv2_hash_data_get_scope(iodefv2_hash_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->scope_is_set ? &ptr->scope : NULL;


}


/**
 * iodefv2_hash_data_set_scope:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 * @scope: pointer to a #iodefv2_hash_data_scope_t object.
 *
 * Set @scope object as a children of @ptr.
 * if @ptr already contain an @scope object, then it is destroyed,
 * and updated to point to the provided @scope object.
 */
void iodefv2_hash_data_set_scope(iodefv2_hash_data_t *ptr, iodefv2_hash_data_scope_t scope)
{
        libiodefv2_return_if_fail(ptr);
        ptr->scope = scope;
        ptr->scope_is_set = 1;
}

void iodefv2_hash_data_unset_scope(iodefv2_hash_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->scope_is_set = 0;
}
/**
 * iodefv2_hash_data_new_scope:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_hash_data_scope_t object.
 *
 * Create a new scope object, children of #iodefv2_hash_data_t.
 * If @ptr already contain a #iodefv2_hash_data_scope_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_hash_data_new_scope(iodefv2_hash_data_t *ptr, iodefv2_hash_data_scope_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->scope_is_set = 1;



        *ret = &ptr->scope;
        return 0;
}




/**
 * iodefv2_hash_data_get_ext_scope:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 *
 * Get ext_scope children of the #iodefv2_hash_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_hash_data_get_ext_scope(iodefv2_hash_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_scope;

}


/**
 * iodefv2_hash_data_set_ext_scope:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 * @ext_scope: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_scope object as a children of @ptr.
 * if @ptr already contain an @ext_scope object, then it is destroyed,
 * and updated to point to the provided @ext_scope object.
 */

void iodefv2_hash_data_set_ext_scope(iodefv2_hash_data_t *ptr, libiodefv2_string_t *ext_scope)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_scope )
                libiodefv2_string_destroy(ptr->ext_scope);

        ptr->ext_scope = ext_scope;
}
/**
 * iodefv2_hash_data_new_ext_scope:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_scope object, children of #iodefv2_hash_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_hash_data_new_ext_scope(iodefv2_hash_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_scope ) {
                retval = libiodefv2_string_new(&ptr->ext_scope);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_scope;
        return 0;
}




/**
 * iodefv2_hash_data_get_hash_target_id:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 *
 * Get hash_target_id children of the #iodefv2_hash_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_hash_data_get_hash_target_id(iodefv2_hash_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->hash_target_id;

}


/**
 * iodefv2_hash_data_set_hash_target_id:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 * @hash_target_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @hash_target_id object as a children of @ptr.
 * if @ptr already contain an @hash_target_id object, then it is destroyed,
 * and updated to point to the provided @hash_target_id object.
 */

void iodefv2_hash_data_set_hash_target_id(iodefv2_hash_data_t *ptr, libiodefv2_string_t *hash_target_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->hash_target_id )
                libiodefv2_string_destroy(ptr->hash_target_id);

        ptr->hash_target_id = hash_target_id;
}
/**
 * iodefv2_hash_data_new_hash_target_id:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new hash_target_id object, children of #iodefv2_hash_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_hash_data_new_hash_target_id(iodefv2_hash_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->hash_target_id ) {
                retval = libiodefv2_string_new(&ptr->hash_target_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->hash_target_id;
        return 0;
}




/**
 * iodefv2_hash_data_get_hash:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 *
 * Get hash children of the #iodefv2_hash_data_t object.
 *
 * Returns: a pointer to a iodefv2_hash_t object, or NULL if the children object is not set.
 */
iodefv2_hash_t *iodefv2_hash_data_get_hash(iodefv2_hash_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->hash;

}


/**
 * iodefv2_hash_data_set_hash:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 * @hash: pointer to a #iodefv2_hash_t object.
 *
 * Set @hash object as a children of @ptr.
 * if @ptr already contain an @hash object, then it is destroyed,
 * and updated to point to the provided @hash object.
 */

void iodefv2_hash_data_set_hash(iodefv2_hash_data_t *ptr, iodefv2_hash_t *hash)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->hash )
                iodefv2_hash_destroy(ptr->hash);

        ptr->hash = hash;
}
/**
 * iodefv2_hash_data_new_hash:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_hash_t object.
 *
 * Create a new hash object, children of #iodefv2_hash_data_t.
 * If @ptr already contain a #iodefv2_hash_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_hash_data_new_hash(iodefv2_hash_data_t *ptr, iodefv2_hash_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->hash ) {
                retval = iodefv2_hash_new(&ptr->hash);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->hash;
        return 0;
}




/**
 * iodefv2_hash_data_get_fuzzy_hash:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 *
 * Get fuzzy_hash children of the #iodefv2_hash_data_t object.
 *
 * Returns: a pointer to a iodefv2_fuzzy_hash_t object, or NULL if the children object is not set.
 */
iodefv2_fuzzy_hash_t *iodefv2_hash_data_get_fuzzy_hash(iodefv2_hash_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->fuzzy_hash;

}


/**
 * iodefv2_hash_data_set_fuzzy_hash:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 * @fuzzy_hash: pointer to a #iodefv2_fuzzy_hash_t object.
 *
 * Set @fuzzy_hash object as a children of @ptr.
 * if @ptr already contain an @fuzzy_hash object, then it is destroyed,
 * and updated to point to the provided @fuzzy_hash object.
 */

void iodefv2_hash_data_set_fuzzy_hash(iodefv2_hash_data_t *ptr, iodefv2_fuzzy_hash_t *fuzzy_hash)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->fuzzy_hash )
                iodefv2_fuzzy_hash_destroy(ptr->fuzzy_hash);

        ptr->fuzzy_hash = fuzzy_hash;
}
/**
 * iodefv2_hash_data_new_fuzzy_hash:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_fuzzy_hash_t object.
 *
 * Create a new fuzzy_hash object, children of #iodefv2_hash_data_t.
 * If @ptr already contain a #iodefv2_fuzzy_hash_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_hash_data_new_fuzzy_hash(iodefv2_hash_data_t *ptr, iodefv2_fuzzy_hash_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->fuzzy_hash ) {
                retval = iodefv2_fuzzy_hash_new(&ptr->fuzzy_hash);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->fuzzy_hash;
        return 0;
}



/**
 * iodefv2_hash_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_hash_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_hash_data_copy(const iodefv2_hash_data_t *src, iodefv2_hash_data_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->scope_is_set = src->scope_is_set;
        dst->scope = src->scope;



        if ( dst->ext_scope ) {
                libiodefv2_string_destroy(dst->ext_scope);
                dst->ext_scope = NULL;
        }

        if ( src->ext_scope ) {
                ret = libiodefv2_string_clone(src->ext_scope, &dst->ext_scope);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->hash_target_id ) {
                libiodefv2_string_destroy(dst->hash_target_id);
                dst->hash_target_id = NULL;
        }

        if ( src->hash_target_id ) {
                ret = libiodefv2_string_clone(src->hash_target_id, &dst->hash_target_id);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->hash ) {
                iodefv2_hash_destroy(dst->hash);
                dst->hash = NULL;
        }

        if ( src->hash ) {
                ret = iodefv2_hash_clone(src->hash, &dst->hash);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->fuzzy_hash ) {
                iodefv2_fuzzy_hash_destroy(dst->fuzzy_hash);
                dst->fuzzy_hash = NULL;
        }

        if ( src->fuzzy_hash ) {
                ret = iodefv2_fuzzy_hash_clone(src->fuzzy_hash, &dst->fuzzy_hash);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_hash_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_hash_data_clone(iodefv2_hash_data_t *src, iodefv2_hash_data_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_hash_data_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_hash_data_copy(src, *dst);
}


/**
 * iodefv2_hash_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_hash_data_compare(const iodefv2_hash_data_t *obj1, const iodefv2_hash_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->scope_is_set != obj2->scope_is_set )
                return -1;

        if ( obj1->scope_is_set && obj1->scope != obj2->scope )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_scope, obj2->ext_scope);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->hash_target_id, obj2->hash_target_id);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_hash_compare(obj1->hash, obj2->hash);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_fuzzy_hash_compare(obj1->fuzzy_hash, obj2->fuzzy_hash);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_bulk_observable_format_new:
 * @ret: Pointer where to store the created #iodefv2_bulk_observable_format_t object.
 *
 * Create a new #iodefv2_bulk_observable_format_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_bulk_observable_format_new(iodefv2_bulk_observable_format_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_BULK_OBSERVABLE_FORMAT;


        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);





            return 0;
}


/**
 * iodefv2_bulk_observable_format_ref:
 * @bulk_observable_format: pointer to a #iodefv2_bulk_observable_format_t object.
 *
 * Increase @bulk_observable_format reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @bulk_observable_format.
 */
iodefv2_bulk_observable_format_t *iodefv2_bulk_observable_format_ref(iodefv2_bulk_observable_format_t *bulk_observable_format)
{
        libiodefv2_return_val_if_fail(bulk_observable_format, NULL);
        bulk_observable_format->refcount++;

        return bulk_observable_format;
}



int _iodefv2_bulk_observable_format_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_bulk_observable_format_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 1:
                *childptr = ptr->hash;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_bulk_observable_format_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_bulk_observable_format_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_bulk_observable_format_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_bulk_observable_format_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 1:
                    return iodefv2_bulk_observable_format_new_hash(ptr, (iodefv2_hash_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_bulk_observable_format_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_bulk_observable_format_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
    
                case 0: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 1:
                        if ( ptr->hash ) {
                                iodefv2_hash_destroy(ptr->hash);
                                ptr->hash = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_bulk_observable_format_destroy_internal(iodefv2_bulk_observable_format_t *ptr)
{
        libiodefv2_return_if_fail(ptr);


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }


        if ( ptr->hash ) {
                iodefv2_hash_destroy(ptr->hash);
                ptr->hash = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_bulk_observable_format_destroy:
 * @ptr: pointer to a #iodefv2_bulk_observable_format_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_bulk_observable_format_destroy(iodefv2_bulk_observable_format_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_bulk_observable_format_destroy_internal(ptr);
        free(ptr);
}






/**
 * iodefv2_bulk_observable_format_get_next_additional_data:
 * @bulk_observable_format: pointer to a #iodefv2_bulk_observable_format_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_bulk_observable_format_get_next_additional_data(iodefv2_bulk_observable_format_t *bulk_observable_format, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(bulk_observable_format, NULL);

        libiodefv2_list_for_each_continue(&bulk_observable_format->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_bulk_observable_format_set_additional_data:
 * @ptr: pointer to a #iodefv2_bulk_observable_format_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_bulk_observable_format_set_additional_data(iodefv2_bulk_observable_format_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_bulk_observable_format_new_additional_data:
 *  @ptr: pointer to a #iodefv2_bulk_observable_format_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_bulk_observable_format_new_additional_data(iodefv2_bulk_observable_format_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_bulk_observable_format_get_hash:
 * @ptr: pointer to a #iodefv2_bulk_observable_format_t object.
 *
 * Get hash children of the #iodefv2_bulk_observable_format_t object.
 *
 * Returns: a pointer to a iodefv2_hash_t object, or NULL if the children object is not set.
 */
iodefv2_hash_t *iodefv2_bulk_observable_format_get_hash(iodefv2_bulk_observable_format_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->hash;

}


/**
 * iodefv2_bulk_observable_format_set_hash:
 * @ptr: pointer to a #iodefv2_bulk_observable_format_t object.
 * @hash: pointer to a #iodefv2_hash_t object.
 *
 * Set @hash object as a children of @ptr.
 * if @ptr already contain an @hash object, then it is destroyed,
 * and updated to point to the provided @hash object.
 */

void iodefv2_bulk_observable_format_set_hash(iodefv2_bulk_observable_format_t *ptr, iodefv2_hash_t *hash)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->hash )
                iodefv2_hash_destroy(ptr->hash);

        ptr->hash = hash;
}
/**
 * iodefv2_bulk_observable_format_new_hash:
 * @ptr: pointer to a #iodefv2_bulk_observable_format_t object.
 * @ret: pointer to an address where to store the created #iodefv2_hash_t object.
 *
 * Create a new hash object, children of #iodefv2_bulk_observable_format_t.
 * If @ptr already contain a #iodefv2_hash_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_bulk_observable_format_new_hash(iodefv2_bulk_observable_format_t *ptr, iodefv2_hash_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->hash ) {
                retval = iodefv2_hash_new(&ptr->hash);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->hash;
        return 0;
}



/**
 * iodefv2_bulk_observable_format_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_bulk_observable_format_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_bulk_observable_format_copy(const iodefv2_bulk_observable_format_t *src, iodefv2_bulk_observable_format_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->hash ) {
                iodefv2_hash_destroy(dst->hash);
                dst->hash = NULL;
        }

        if ( src->hash ) {
                ret = iodefv2_hash_clone(src->hash, &dst->hash);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_bulk_observable_format_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_bulk_observable_format_clone(iodefv2_bulk_observable_format_t *src, iodefv2_bulk_observable_format_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_bulk_observable_format_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_bulk_observable_format_copy(src, *dst);
}


/**
 * iodefv2_bulk_observable_format_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_bulk_observable_format_compare(const iodefv2_bulk_observable_format_t *obj1, const iodefv2_bulk_observable_format_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_hash_compare(obj1->hash, obj2->hash);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_history_new:
 * @ret: Pointer where to store the created #iodefv2_history_t object.
 *
 * Create a new #iodefv2_history_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_history_new(iodefv2_history_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_HISTORY;


        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->history_item_list);





            return 0;
}


/**
 * iodefv2_history_ref:
 * @history: pointer to a #iodefv2_history_t object.
 *
 * Increase @history reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @history.
 */
iodefv2_history_t *iodefv2_history_ref(iodefv2_history_t *history)
{
        libiodefv2_return_val_if_fail(history, NULL);
        history->refcount++;

        return history;
}



int _iodefv2_history_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_history_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_HISTORY_RESTRICTION , ptr->restriction);

            case 1:
                *childptr = &ptr->history_item_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_history_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_history_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_history_new_restriction(ptr, (iodefv2_history_restriction_t **) ret);

                case 1: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_history_new_history_item(ptr, (iodefv2_history_item_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->history_item_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->history_item_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_history_new_history_item(ptr, (iodefv2_history_item_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_history_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_history_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;

    
                case 1: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->history_item_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_history_item_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->history_item_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_history_item_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_history_destroy_internal(iodefv2_history_t *ptr)
{
        libiodefv2_return_if_fail(ptr);




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_history_item_t *entry;

                libiodefv2_list_for_each_safe(&ptr->history_item_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_history_item_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_history_destroy:
 * @ptr: pointer to a #iodefv2_history_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_history_destroy(iodefv2_history_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_history_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_history_get_restriction:
 * @ptr: pointer to a #iodefv2_history_t object.
 *
 * Get restriction children of the #iodefv2_history_t object.
 *
 * Returns: a pointer to a iodefv2_history_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_history_restriction_t *iodefv2_history_get_restriction(iodefv2_history_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_history_set_restriction:
 * @ptr: pointer to a #iodefv2_history_t object.
 * @restriction: pointer to a #iodefv2_history_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_history_set_restriction(iodefv2_history_t *ptr, iodefv2_history_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_history_unset_restriction(iodefv2_history_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_history_new_restriction:
 * @ptr: pointer to a #iodefv2_history_t object.
 * @ret: pointer to an address where to store the created #iodefv2_history_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_history_t.
 * If @ptr already contain a #iodefv2_history_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_history_new_restriction(iodefv2_history_t *ptr, iodefv2_history_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}





/**
 * iodefv2_history_get_next_history_item:
 * @history: pointer to a #iodefv2_history_t object.
 * @history_item_cur: pointer to a #iodefv2_history_item_t object.
 *
 * Get the next #iodefv2_history_item_t object listed in @ptr.
 * When iterating over the iodefv2_history_item_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_history_item_t object.
 *
 * Returns: the next #iodefv2_history_item_t in the list.
 */
iodefv2_history_item_t *iodefv2_history_get_next_history_item(iodefv2_history_t *history, iodefv2_history_item_t *history_item_cur)
{
        libiodefv2_list_t *tmp = (history_item_cur) ? &((libiodefv2_linked_object_t *) history_item_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(history, NULL);

        libiodefv2_list_for_each_continue(&history->history_item_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_history_set_history_item:
 * @ptr: pointer to a #iodefv2_history_t object.
 * @object: pointer to a #iodefv2_history_item_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_history_item_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_history_set_history_item(iodefv2_history_t *ptr, iodefv2_history_item_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->history_item_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_history_new_history_item:
 *  @ptr: pointer to a #iodefv2_history_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_history_item_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_history_item_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_history_item_t object. The created #iodefv2_history_item_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_history_new_history_item(iodefv2_history_t *ptr, iodefv2_history_item_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_history_item_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->history_item_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_history_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_history_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_history_copy(const iodefv2_history_t *src, iodefv2_history_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_history_item_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->history_item_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_history_item_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->history_item_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_history_item_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->history_item_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_history_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_history_clone(iodefv2_history_t *src, iodefv2_history_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_history_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_history_copy(src, *dst);
}


/**
 * iodefv2_history_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_history_compare(const iodefv2_history_t *obj1, const iodefv2_history_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;



        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_history_item_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->history_item_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->history_item_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_history_item_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_discovery_new:
 * @ret: Pointer where to store the created #iodefv2_discovery_t object.
 *
 * Create a new #iodefv2_discovery_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_discovery_new(iodefv2_discovery_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_DISCOVERY;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->detection_pattern_list);


        libiodefv2_list_init(&(*ret)->contact_list);













            return 0;
}


/**
 * iodefv2_discovery_ref:
 * @discovery: pointer to a #iodefv2_discovery_t object.
 *
 * Increase @discovery reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @discovery.
 */
iodefv2_discovery_t *iodefv2_discovery_ref(iodefv2_discovery_t *discovery)
{
        libiodefv2_return_val_if_fail(discovery, NULL);
        discovery->refcount++;

        return discovery;
}



int _iodefv2_discovery_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_discovery_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->source_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_DISCOVERY_SOURCE , ptr->source);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_source, TRUE);



            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);


            case 4:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_DISCOVERY_RESTRICTION , ptr->restriction);

            case 5:
                *childptr = &ptr->detection_pattern_list;
                return 0;

            case 6:
                *childptr = &ptr->contact_list;
                return 0;


            case 7:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_discovery_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_discovery_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_discovery_new_source(ptr, (iodefv2_discovery_source_t **) ret);

                case 1:
                    return iodefv2_discovery_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_discovery_new_ext_source(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_discovery_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 4:
                    return iodefv2_discovery_new_restriction(ptr, (iodefv2_discovery_restriction_t **) ret);

                case 5: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_discovery_new_detection_pattern(ptr, (iodefv2_detection_pattern_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->detection_pattern_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->detection_pattern_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_discovery_new_detection_pattern(ptr, (iodefv2_detection_pattern_t **) ret, n);
                }

                case 6: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_discovery_new_contact(ptr, (iodefv2_contact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->contact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->contact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_discovery_new_contact(ptr, (iodefv2_contact_t **) ret, n);
                }

                case 7:
                    return iodefv2_discovery_new_description(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_discovery_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_discovery_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->source_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->ext_source ) {
                                libiodefv2_string_destroy(ptr->ext_source);
                                ptr->ext_source = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;

                case 4:
                        ptr->restriction_is_set = 0;
                        return 0;

    
                case 5: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->detection_pattern_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_detection_pattern_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->detection_pattern_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_detection_pattern_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 6: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->contact_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_contact_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->contact_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_contact_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 7:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_discovery_destroy_internal(iodefv2_discovery_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }



        if ( ptr->ext_source ) {
                libiodefv2_string_destroy(ptr->ext_source);
                ptr->ext_source = NULL;
        }



        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }






        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_detection_pattern_t *entry;

                libiodefv2_list_for_each_safe(&ptr->detection_pattern_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_detection_pattern_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_contact_t *entry;

                libiodefv2_list_for_each_safe(&ptr->contact_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_contact_destroy(entry);
                }
        }

        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_discovery_destroy:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_discovery_destroy(iodefv2_discovery_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_discovery_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_discovery_get_source:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 *
 * Get source children of the #iodefv2_discovery_t object.
 *
 * Returns: a pointer to a iodefv2_discovery_source_t object, or NULL if the children object is not set.
 */
iodefv2_discovery_source_t *iodefv2_discovery_get_source(iodefv2_discovery_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->source_is_set ? &ptr->source : NULL;


}


/**
 * iodefv2_discovery_set_source:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 * @source: pointer to a #iodefv2_discovery_source_t object.
 *
 * Set @source object as a children of @ptr.
 * if @ptr already contain an @source object, then it is destroyed,
 * and updated to point to the provided @source object.
 */
void iodefv2_discovery_set_source(iodefv2_discovery_t *ptr, iodefv2_discovery_source_t source)
{
        libiodefv2_return_if_fail(ptr);
        ptr->source = source;
        ptr->source_is_set = 1;
}

void iodefv2_discovery_unset_source(iodefv2_discovery_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->source_is_set = 0;
}
/**
 * iodefv2_discovery_new_source:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 * @ret: pointer to an address where to store the created #iodefv2_discovery_source_t object.
 *
 * Create a new source object, children of #iodefv2_discovery_t.
 * If @ptr already contain a #iodefv2_discovery_source_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_discovery_new_source(iodefv2_discovery_t *ptr, iodefv2_discovery_source_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->source_is_set = 1;



        *ret = &ptr->source;
        return 0;
}




/**
 * iodefv2_discovery_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 *
 * Get ext_restriction children of the #iodefv2_discovery_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_discovery_get_ext_restriction(iodefv2_discovery_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_discovery_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_discovery_set_ext_restriction(iodefv2_discovery_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_discovery_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_discovery_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_discovery_new_ext_restriction(iodefv2_discovery_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_discovery_get_ext_source:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 *
 * Get ext_source children of the #iodefv2_discovery_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_discovery_get_ext_source(iodefv2_discovery_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_source;

}


/**
 * iodefv2_discovery_set_ext_source:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 * @ext_source: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_source object as a children of @ptr.
 * if @ptr already contain an @ext_source object, then it is destroyed,
 * and updated to point to the provided @ext_source object.
 */

void iodefv2_discovery_set_ext_source(iodefv2_discovery_t *ptr, libiodefv2_string_t *ext_source)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_source )
                libiodefv2_string_destroy(ptr->ext_source);

        ptr->ext_source = ext_source;
}
/**
 * iodefv2_discovery_new_ext_source:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_source object, children of #iodefv2_discovery_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_discovery_new_ext_source(iodefv2_discovery_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_source ) {
                retval = libiodefv2_string_new(&ptr->ext_source);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_source;
        return 0;
}




/**
 * iodefv2_discovery_get_observable_id:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 *
 * Get observable_id children of the #iodefv2_discovery_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_discovery_get_observable_id(iodefv2_discovery_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_discovery_set_observable_id:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_discovery_set_observable_id(iodefv2_discovery_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_discovery_new_observable_id:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_discovery_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_discovery_new_observable_id(iodefv2_discovery_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}




/**
 * iodefv2_discovery_get_restriction:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 *
 * Get restriction children of the #iodefv2_discovery_t object.
 *
 * Returns: a pointer to a iodefv2_discovery_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_discovery_restriction_t *iodefv2_discovery_get_restriction(iodefv2_discovery_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_discovery_set_restriction:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 * @restriction: pointer to a #iodefv2_discovery_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_discovery_set_restriction(iodefv2_discovery_t *ptr, iodefv2_discovery_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_discovery_unset_restriction(iodefv2_discovery_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_discovery_new_restriction:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 * @ret: pointer to an address where to store the created #iodefv2_discovery_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_discovery_t.
 * If @ptr already contain a #iodefv2_discovery_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_discovery_new_restriction(iodefv2_discovery_t *ptr, iodefv2_discovery_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}





/**
 * iodefv2_discovery_get_next_detection_pattern:
 * @discovery: pointer to a #iodefv2_discovery_t object.
 * @detection_pattern_cur: pointer to a #iodefv2_detection_pattern_t object.
 *
 * Get the next #iodefv2_detection_pattern_t object listed in @ptr.
 * When iterating over the iodefv2_detection_pattern_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_detection_pattern_t object.
 *
 * Returns: the next #iodefv2_detection_pattern_t in the list.
 */
iodefv2_detection_pattern_t *iodefv2_discovery_get_next_detection_pattern(iodefv2_discovery_t *discovery, iodefv2_detection_pattern_t *detection_pattern_cur)
{
        libiodefv2_list_t *tmp = (detection_pattern_cur) ? &((libiodefv2_linked_object_t *) detection_pattern_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(discovery, NULL);

        libiodefv2_list_for_each_continue(&discovery->detection_pattern_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_discovery_set_detection_pattern:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 * @object: pointer to a #iodefv2_detection_pattern_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_detection_pattern_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_discovery_set_detection_pattern(iodefv2_discovery_t *ptr, iodefv2_detection_pattern_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->detection_pattern_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_discovery_new_detection_pattern:
 *  @ptr: pointer to a #iodefv2_discovery_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_detection_pattern_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_detection_pattern_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_detection_pattern_t object. The created #iodefv2_detection_pattern_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_discovery_new_detection_pattern(iodefv2_discovery_t *ptr, iodefv2_detection_pattern_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_detection_pattern_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->detection_pattern_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_discovery_get_next_contact:
 * @discovery: pointer to a #iodefv2_discovery_t object.
 * @contact_cur: pointer to a #iodefv2_contact_t object.
 *
 * Get the next #iodefv2_contact_t object listed in @ptr.
 * When iterating over the iodefv2_contact_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_contact_t object.
 *
 * Returns: the next #iodefv2_contact_t in the list.
 */
iodefv2_contact_t *iodefv2_discovery_get_next_contact(iodefv2_discovery_t *discovery, iodefv2_contact_t *contact_cur)
{
        libiodefv2_list_t *tmp = (contact_cur) ? &((libiodefv2_linked_object_t *) contact_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(discovery, NULL);

        libiodefv2_list_for_each_continue(&discovery->contact_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_discovery_set_contact:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 * @object: pointer to a #iodefv2_contact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_contact_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_discovery_set_contact(iodefv2_discovery_t *ptr, iodefv2_contact_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->contact_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_discovery_new_contact:
 *  @ptr: pointer to a #iodefv2_discovery_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_contact_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_contact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_contact_t object. The created #iodefv2_contact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_discovery_new_contact(iodefv2_discovery_t *ptr, iodefv2_contact_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_contact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->contact_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_discovery_get_description:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 *
 * Get description children of the #iodefv2_discovery_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_discovery_get_description(iodefv2_discovery_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_discovery_set_description:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_discovery_set_description(iodefv2_discovery_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_discovery_new_description:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_discovery_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_discovery_new_description(iodefv2_discovery_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}



/**
 * iodefv2_discovery_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_discovery_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_discovery_copy(const iodefv2_discovery_t *src, iodefv2_discovery_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->source_is_set = src->source_is_set;
        dst->source = src->source;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->ext_source ) {
                libiodefv2_string_destroy(dst->ext_source);
                dst->ext_source = NULL;
        }

        if ( src->ext_source ) {
                ret = libiodefv2_string_clone(src->ext_source, &dst->ext_source);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }




        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_detection_pattern_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->detection_pattern_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_detection_pattern_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->detection_pattern_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_detection_pattern_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->detection_pattern_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_contact_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->contact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_contact_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->contact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_contact_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->contact_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_discovery_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_discovery_clone(iodefv2_discovery_t *src, iodefv2_discovery_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_discovery_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_discovery_copy(src, *dst);
}


/**
 * iodefv2_discovery_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_discovery_compare(const iodefv2_discovery_t *obj1, const iodefv2_discovery_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->source_is_set != obj2->source_is_set )
                return -1;

        if ( obj1->source_is_set && obj1->source != obj2->source )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->ext_source, obj2->ext_source);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;



        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_detection_pattern_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->detection_pattern_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->detection_pattern_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_detection_pattern_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_contact_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->contact_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->contact_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_contact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_bulk_observable_new:
 * @ret: Pointer where to store the created #iodefv2_bulk_observable_t object.
 *
 * Create a new #iodefv2_bulk_observable_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_bulk_observable_new(iodefv2_bulk_observable_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_BULK_OBSERVABLE;


        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);









            return 0;
}


/**
 * iodefv2_bulk_observable_ref:
 * @bulk_observable: pointer to a #iodefv2_bulk_observable_t object.
 *
 * Increase @bulk_observable reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @bulk_observable.
 */
iodefv2_bulk_observable_t *iodefv2_bulk_observable_ref(iodefv2_bulk_observable_t *bulk_observable)
{
        libiodefv2_return_val_if_fail(bulk_observable, NULL);
        bulk_observable->refcount++;

        return bulk_observable;
}



int _iodefv2_bulk_observable_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_bulk_observable_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->type_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_BULK_OBSERVABLE_TYPE , ptr->type);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_type, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->bulk_observable_list, TRUE);



            case 3:
                *childptr = ptr->bulk_observable_format;
                return 0;

            case 4:
                *childptr = &ptr->additional_data_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_bulk_observable_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_bulk_observable_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_bulk_observable_new_type(ptr, (iodefv2_bulk_observable_type_t **) ret);

                case 1:
                    return iodefv2_bulk_observable_new_ext_type(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_bulk_observable_new_bulk_observable_list(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_bulk_observable_new_bulk_observable_format(ptr, (iodefv2_bulk_observable_format_t **) ret);

                case 4: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_bulk_observable_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_bulk_observable_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_bulk_observable_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_bulk_observable_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->type_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_type ) {
                                libiodefv2_string_destroy(ptr->ext_type);
                                ptr->ext_type = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->bulk_observable_list ) {
                                libiodefv2_string_destroy(ptr->bulk_observable_list);
                                ptr->bulk_observable_list = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->bulk_observable_format ) {
                                iodefv2_bulk_observable_format_destroy(ptr->bulk_observable_format);
                                ptr->bulk_observable_format = NULL;
                        }

                        return 0;

    
                case 4: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_bulk_observable_destroy_internal(iodefv2_bulk_observable_t *ptr)
{
        libiodefv2_return_if_fail(ptr);



        if ( ptr->ext_type ) {
                libiodefv2_string_destroy(ptr->ext_type);
                ptr->ext_type = NULL;
        }



        if ( ptr->bulk_observable_list ) {
                libiodefv2_string_destroy(ptr->bulk_observable_list);
                ptr->bulk_observable_list = NULL;
        }




        if ( ptr->bulk_observable_format ) {
                iodefv2_bulk_observable_format_destroy(ptr->bulk_observable_format);
                ptr->bulk_observable_format = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_bulk_observable_destroy:
 * @ptr: pointer to a #iodefv2_bulk_observable_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_bulk_observable_destroy(iodefv2_bulk_observable_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_bulk_observable_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_bulk_observable_get_type:
 * @ptr: pointer to a #iodefv2_bulk_observable_t object.
 *
 * Get type children of the #iodefv2_bulk_observable_t object.
 *
 * Returns: a pointer to a iodefv2_bulk_observable_type_t object, or NULL if the children object is not set.
 */
iodefv2_bulk_observable_type_t *iodefv2_bulk_observable_get_type(iodefv2_bulk_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->type_is_set ? &ptr->type : NULL;


}


/**
 * iodefv2_bulk_observable_set_type:
 * @ptr: pointer to a #iodefv2_bulk_observable_t object.
 * @type: pointer to a #iodefv2_bulk_observable_type_t object.
 *
 * Set @type object as a children of @ptr.
 * if @ptr already contain an @type object, then it is destroyed,
 * and updated to point to the provided @type object.
 */
void iodefv2_bulk_observable_set_type(iodefv2_bulk_observable_t *ptr, iodefv2_bulk_observable_type_t type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type = type;
        ptr->type_is_set = 1;
}

void iodefv2_bulk_observable_unset_type(iodefv2_bulk_observable_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type_is_set = 0;
}
/**
 * iodefv2_bulk_observable_new_type:
 * @ptr: pointer to a #iodefv2_bulk_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_bulk_observable_type_t object.
 *
 * Create a new type object, children of #iodefv2_bulk_observable_t.
 * If @ptr already contain a #iodefv2_bulk_observable_type_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_bulk_observable_new_type(iodefv2_bulk_observable_t *ptr, iodefv2_bulk_observable_type_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->type_is_set = 1;



        *ret = &ptr->type;
        return 0;
}




/**
 * iodefv2_bulk_observable_get_ext_type:
 * @ptr: pointer to a #iodefv2_bulk_observable_t object.
 *
 * Get ext_type children of the #iodefv2_bulk_observable_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_bulk_observable_get_ext_type(iodefv2_bulk_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_type;

}


/**
 * iodefv2_bulk_observable_set_ext_type:
 * @ptr: pointer to a #iodefv2_bulk_observable_t object.
 * @ext_type: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_type object as a children of @ptr.
 * if @ptr already contain an @ext_type object, then it is destroyed,
 * and updated to point to the provided @ext_type object.
 */

void iodefv2_bulk_observable_set_ext_type(iodefv2_bulk_observable_t *ptr, libiodefv2_string_t *ext_type)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_type )
                libiodefv2_string_destroy(ptr->ext_type);

        ptr->ext_type = ext_type;
}
/**
 * iodefv2_bulk_observable_new_ext_type:
 * @ptr: pointer to a #iodefv2_bulk_observable_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_type object, children of #iodefv2_bulk_observable_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_bulk_observable_new_ext_type(iodefv2_bulk_observable_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_type ) {
                retval = libiodefv2_string_new(&ptr->ext_type);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_type;
        return 0;
}




/**
 * iodefv2_bulk_observable_get_bulk_observable_list:
 * @ptr: pointer to a #iodefv2_bulk_observable_t object.
 *
 * Get bulk_observable_list children of the #iodefv2_bulk_observable_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_bulk_observable_get_bulk_observable_list(iodefv2_bulk_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->bulk_observable_list;

}


/**
 * iodefv2_bulk_observable_set_bulk_observable_list:
 * @ptr: pointer to a #iodefv2_bulk_observable_t object.
 * @bulk_observable_list: pointer to a #libiodefv2_string_t object.
 *
 * Set @bulk_observable_list object as a children of @ptr.
 * if @ptr already contain an @bulk_observable_list object, then it is destroyed,
 * and updated to point to the provided @bulk_observable_list object.
 */

void iodefv2_bulk_observable_set_bulk_observable_list(iodefv2_bulk_observable_t *ptr, libiodefv2_string_t *bulk_observable_list)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->bulk_observable_list )
                libiodefv2_string_destroy(ptr->bulk_observable_list);

        ptr->bulk_observable_list = bulk_observable_list;
}
/**
 * iodefv2_bulk_observable_new_bulk_observable_list:
 * @ptr: pointer to a #iodefv2_bulk_observable_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new bulk_observable_list object, children of #iodefv2_bulk_observable_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_bulk_observable_new_bulk_observable_list(iodefv2_bulk_observable_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->bulk_observable_list ) {
                retval = libiodefv2_string_new(&ptr->bulk_observable_list);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->bulk_observable_list;
        return 0;
}




/**
 * iodefv2_bulk_observable_get_bulk_observable_format:
 * @ptr: pointer to a #iodefv2_bulk_observable_t object.
 *
 * Get bulk_observable_format children of the #iodefv2_bulk_observable_t object.
 *
 * Returns: a pointer to a iodefv2_bulk_observable_format_t object, or NULL if the children object is not set.
 */
iodefv2_bulk_observable_format_t *iodefv2_bulk_observable_get_bulk_observable_format(iodefv2_bulk_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->bulk_observable_format;

}


/**
 * iodefv2_bulk_observable_set_bulk_observable_format:
 * @ptr: pointer to a #iodefv2_bulk_observable_t object.
 * @bulk_observable_format: pointer to a #iodefv2_bulk_observable_format_t object.
 *
 * Set @bulk_observable_format object as a children of @ptr.
 * if @ptr already contain an @bulk_observable_format object, then it is destroyed,
 * and updated to point to the provided @bulk_observable_format object.
 */

void iodefv2_bulk_observable_set_bulk_observable_format(iodefv2_bulk_observable_t *ptr, iodefv2_bulk_observable_format_t *bulk_observable_format)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->bulk_observable_format )
                iodefv2_bulk_observable_format_destroy(ptr->bulk_observable_format);

        ptr->bulk_observable_format = bulk_observable_format;
}
/**
 * iodefv2_bulk_observable_new_bulk_observable_format:
 * @ptr: pointer to a #iodefv2_bulk_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_bulk_observable_format_t object.
 *
 * Create a new bulk_observable_format object, children of #iodefv2_bulk_observable_t.
 * If @ptr already contain a #iodefv2_bulk_observable_format_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_bulk_observable_new_bulk_observable_format(iodefv2_bulk_observable_t *ptr, iodefv2_bulk_observable_format_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->bulk_observable_format ) {
                retval = iodefv2_bulk_observable_format_new(&ptr->bulk_observable_format);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->bulk_observable_format;
        return 0;
}





/**
 * iodefv2_bulk_observable_get_next_additional_data:
 * @bulk_observable: pointer to a #iodefv2_bulk_observable_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_bulk_observable_get_next_additional_data(iodefv2_bulk_observable_t *bulk_observable, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(bulk_observable, NULL);

        libiodefv2_list_for_each_continue(&bulk_observable->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_bulk_observable_set_additional_data:
 * @ptr: pointer to a #iodefv2_bulk_observable_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_bulk_observable_set_additional_data(iodefv2_bulk_observable_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_bulk_observable_new_additional_data:
 *  @ptr: pointer to a #iodefv2_bulk_observable_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_bulk_observable_new_additional_data(iodefv2_bulk_observable_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_bulk_observable_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_bulk_observable_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_bulk_observable_copy(const iodefv2_bulk_observable_t *src, iodefv2_bulk_observable_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->type_is_set = src->type_is_set;
        dst->type = src->type;



        if ( dst->ext_type ) {
                libiodefv2_string_destroy(dst->ext_type);
                dst->ext_type = NULL;
        }

        if ( src->ext_type ) {
                ret = libiodefv2_string_clone(src->ext_type, &dst->ext_type);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->bulk_observable_list ) {
                libiodefv2_string_destroy(dst->bulk_observable_list);
                dst->bulk_observable_list = NULL;
        }

        if ( src->bulk_observable_list ) {
                ret = libiodefv2_string_clone(src->bulk_observable_list, &dst->bulk_observable_list);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->bulk_observable_format ) {
                iodefv2_bulk_observable_format_destroy(dst->bulk_observable_format);
                dst->bulk_observable_format = NULL;
        }

        if ( src->bulk_observable_format ) {
                ret = iodefv2_bulk_observable_format_clone(src->bulk_observable_format, &dst->bulk_observable_format);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_bulk_observable_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_bulk_observable_clone(iodefv2_bulk_observable_t *src, iodefv2_bulk_observable_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_bulk_observable_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_bulk_observable_copy(src, *dst);
}


/**
 * iodefv2_bulk_observable_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_bulk_observable_compare(const iodefv2_bulk_observable_t *obj1, const iodefv2_bulk_observable_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->type_is_set != obj2->type_is_set )
                return -1;

        if ( obj1->type_is_set && obj1->type != obj2->type )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_type, obj2->ext_type);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->bulk_observable_list, obj2->bulk_observable_list);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_bulk_observable_format_compare(obj1->bulk_observable_format, obj2->bulk_observable_format);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_email_data_new:
 * @ret: Pointer where to store the created #iodefv2_email_data_t object.
 *
 * Create a new #iodefv2_email_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_email_data_new(iodefv2_email_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_EMAIL_DATA;


        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);


        libiodefv2_list_init(&(*ret)->signature_data_list);


        libiodefv2_list_init(&(*ret)->hash_data_list);

















            return 0;
}


/**
 * iodefv2_email_data_ref:
 * @email_data: pointer to a #iodefv2_email_data_t object.
 *
 * Increase @email_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @email_data.
 */
iodefv2_email_data_t *iodefv2_email_data_ref(iodefv2_email_data_t *email_data)
{
        libiodefv2_return_val_if_fail(email_data, NULL);
        email_data->refcount++;

        return email_data;
}



int _iodefv2_email_data_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_email_data_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);


            case 1:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->email_headers, TRUE);


            case 3:
                *childptr = &ptr->signature_data_list;
                return 0;


            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->email_subject, TRUE);



            case 5:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->email_x_mailer, TRUE);


            case 6:
                *childptr = &ptr->hash_data_list;
                return 0;


            case 7:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->email_from, TRUE);



            case 8:
                *childptr = ptr->application_header;
                return 0;


            case 9:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->email_body, TRUE);



            case 10:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->email_message, TRUE);



            case 11:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->email_to, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_email_data_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_email_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_email_data_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 1: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_email_data_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_email_data_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 2:
                    return iodefv2_email_data_new_email_headers(ptr, (libiodefv2_string_t **) ret);

                case 3: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_email_data_new_signature_data(ptr, (iodefv2_signature_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->signature_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->signature_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_email_data_new_signature_data(ptr, (iodefv2_signature_data_t **) ret, n);
                }

                case 4:
                    return iodefv2_email_data_new_email_subject(ptr, (libiodefv2_string_t **) ret);

                case 5:
                    return iodefv2_email_data_new_email_x_mailer(ptr, (libiodefv2_string_t **) ret);

                case 6: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_email_data_new_hash_data(ptr, (iodefv2_hash_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->hash_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->hash_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_email_data_new_hash_data(ptr, (iodefv2_hash_data_t **) ret, n);
                }

                case 7:
                    return iodefv2_email_data_new_email_from(ptr, (libiodefv2_string_t **) ret);

                case 8:
                    return iodefv2_email_data_new_application_header(ptr, (iodefv2_application_header_t **) ret);

                case 9:
                    return iodefv2_email_data_new_email_body(ptr, (libiodefv2_string_t **) ret);

                case 10:
                    return iodefv2_email_data_new_email_message(ptr, (libiodefv2_string_t **) ret);

                case 11:
                    return iodefv2_email_data_new_email_to(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_email_data_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_email_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;

    
                case 1: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 2:
                        if ( ptr->email_headers ) {
                                libiodefv2_string_destroy(ptr->email_headers);
                                ptr->email_headers = NULL;
                        }

                        return 0;

    
                case 3: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->signature_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_signature_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->signature_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_signature_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 4:
                        if ( ptr->email_subject ) {
                                libiodefv2_string_destroy(ptr->email_subject);
                                ptr->email_subject = NULL;
                        }

                        return 0;




                case 5:
                        if ( ptr->email_x_mailer ) {
                                libiodefv2_string_destroy(ptr->email_x_mailer);
                                ptr->email_x_mailer = NULL;
                        }

                        return 0;

    
                case 6: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->hash_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_hash_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->hash_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_hash_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 7:
                        if ( ptr->email_from ) {
                                libiodefv2_string_destroy(ptr->email_from);
                                ptr->email_from = NULL;
                        }

                        return 0;




                case 8:
                        if ( ptr->application_header ) {
                                iodefv2_application_header_destroy(ptr->application_header);
                                ptr->application_header = NULL;
                        }

                        return 0;




                case 9:
                        if ( ptr->email_body ) {
                                libiodefv2_string_destroy(ptr->email_body);
                                ptr->email_body = NULL;
                        }

                        return 0;




                case 10:
                        if ( ptr->email_message ) {
                                libiodefv2_string_destroy(ptr->email_message);
                                ptr->email_message = NULL;
                        }

                        return 0;




                case 11:
                        if ( ptr->email_to ) {
                                libiodefv2_string_destroy(ptr->email_to);
                                ptr->email_to = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_email_data_destroy_internal(iodefv2_email_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }

        if ( ptr->email_headers ) {
                libiodefv2_string_destroy(ptr->email_headers);
                ptr->email_headers = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_signature_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->signature_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_signature_data_destroy(entry);
                }
        }

        if ( ptr->email_subject ) {
                libiodefv2_string_destroy(ptr->email_subject);
                ptr->email_subject = NULL;
        }



        if ( ptr->email_x_mailer ) {
                libiodefv2_string_destroy(ptr->email_x_mailer);
                ptr->email_x_mailer = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_hash_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->hash_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_hash_data_destroy(entry);
                }
        }

        if ( ptr->email_from ) {
                libiodefv2_string_destroy(ptr->email_from);
                ptr->email_from = NULL;
        }




        if ( ptr->application_header ) {
                iodefv2_application_header_destroy(ptr->application_header);
                ptr->application_header = NULL;
        }



        if ( ptr->email_body ) {
                libiodefv2_string_destroy(ptr->email_body);
                ptr->email_body = NULL;
        }



        if ( ptr->email_message ) {
                libiodefv2_string_destroy(ptr->email_message);
                ptr->email_message = NULL;
        }



        if ( ptr->email_to ) {
                libiodefv2_string_destroy(ptr->email_to);
                ptr->email_to = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_email_data_destroy:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_email_data_destroy(iodefv2_email_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_email_data_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_email_data_get_observable_id:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 *
 * Get observable_id children of the #iodefv2_email_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_email_data_get_observable_id(iodefv2_email_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_email_data_set_observable_id:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_email_data_set_observable_id(iodefv2_email_data_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_email_data_new_observable_id:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_email_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_data_new_observable_id(iodefv2_email_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}





/**
 * iodefv2_email_data_get_next_additional_data:
 * @email_data: pointer to a #iodefv2_email_data_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_email_data_get_next_additional_data(iodefv2_email_data_t *email_data, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(email_data, NULL);

        libiodefv2_list_for_each_continue(&email_data->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_email_data_set_additional_data:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_email_data_set_additional_data(iodefv2_email_data_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_email_data_new_additional_data:
 *  @ptr: pointer to a #iodefv2_email_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_data_new_additional_data(iodefv2_email_data_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_email_data_get_email_headers:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 *
 * Get email_headers children of the #iodefv2_email_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_email_data_get_email_headers(iodefv2_email_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->email_headers;

}


/**
 * iodefv2_email_data_set_email_headers:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @email_headers: pointer to a #libiodefv2_string_t object.
 *
 * Set @email_headers object as a children of @ptr.
 * if @ptr already contain an @email_headers object, then it is destroyed,
 * and updated to point to the provided @email_headers object.
 */

void iodefv2_email_data_set_email_headers(iodefv2_email_data_t *ptr, libiodefv2_string_t *email_headers)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->email_headers )
                libiodefv2_string_destroy(ptr->email_headers);

        ptr->email_headers = email_headers;
}
/**
 * iodefv2_email_data_new_email_headers:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new email_headers object, children of #iodefv2_email_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_data_new_email_headers(iodefv2_email_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->email_headers ) {
                retval = libiodefv2_string_new(&ptr->email_headers);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->email_headers;
        return 0;
}





/**
 * iodefv2_email_data_get_next_signature_data:
 * @email_data: pointer to a #iodefv2_email_data_t object.
 * @signature_data_cur: pointer to a #iodefv2_signature_data_t object.
 *
 * Get the next #iodefv2_signature_data_t object listed in @ptr.
 * When iterating over the iodefv2_signature_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_signature_data_t object.
 *
 * Returns: the next #iodefv2_signature_data_t in the list.
 */
iodefv2_signature_data_t *iodefv2_email_data_get_next_signature_data(iodefv2_email_data_t *email_data, iodefv2_signature_data_t *signature_data_cur)
{
        libiodefv2_list_t *tmp = (signature_data_cur) ? &((libiodefv2_linked_object_t *) signature_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(email_data, NULL);

        libiodefv2_list_for_each_continue(&email_data->signature_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_email_data_set_signature_data:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @object: pointer to a #iodefv2_signature_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_signature_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_email_data_set_signature_data(iodefv2_email_data_t *ptr, iodefv2_signature_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->signature_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_email_data_new_signature_data:
 *  @ptr: pointer to a #iodefv2_email_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_signature_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_signature_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_signature_data_t object. The created #iodefv2_signature_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_data_new_signature_data(iodefv2_email_data_t *ptr, iodefv2_signature_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_signature_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->signature_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_email_data_get_email_subject:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 *
 * Get email_subject children of the #iodefv2_email_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_email_data_get_email_subject(iodefv2_email_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->email_subject;

}


/**
 * iodefv2_email_data_set_email_subject:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @email_subject: pointer to a #libiodefv2_string_t object.
 *
 * Set @email_subject object as a children of @ptr.
 * if @ptr already contain an @email_subject object, then it is destroyed,
 * and updated to point to the provided @email_subject object.
 */

void iodefv2_email_data_set_email_subject(iodefv2_email_data_t *ptr, libiodefv2_string_t *email_subject)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->email_subject )
                libiodefv2_string_destroy(ptr->email_subject);

        ptr->email_subject = email_subject;
}
/**
 * iodefv2_email_data_new_email_subject:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new email_subject object, children of #iodefv2_email_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_data_new_email_subject(iodefv2_email_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->email_subject ) {
                retval = libiodefv2_string_new(&ptr->email_subject);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->email_subject;
        return 0;
}




/**
 * iodefv2_email_data_get_email_x_mailer:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 *
 * Get email_x_mailer children of the #iodefv2_email_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_email_data_get_email_x_mailer(iodefv2_email_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->email_x_mailer;

}


/**
 * iodefv2_email_data_set_email_x_mailer:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @email_x_mailer: pointer to a #libiodefv2_string_t object.
 *
 * Set @email_x_mailer object as a children of @ptr.
 * if @ptr already contain an @email_x_mailer object, then it is destroyed,
 * and updated to point to the provided @email_x_mailer object.
 */

void iodefv2_email_data_set_email_x_mailer(iodefv2_email_data_t *ptr, libiodefv2_string_t *email_x_mailer)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->email_x_mailer )
                libiodefv2_string_destroy(ptr->email_x_mailer);

        ptr->email_x_mailer = email_x_mailer;
}
/**
 * iodefv2_email_data_new_email_x_mailer:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new email_x_mailer object, children of #iodefv2_email_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_data_new_email_x_mailer(iodefv2_email_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->email_x_mailer ) {
                retval = libiodefv2_string_new(&ptr->email_x_mailer);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->email_x_mailer;
        return 0;
}





/**
 * iodefv2_email_data_get_next_hash_data:
 * @email_data: pointer to a #iodefv2_email_data_t object.
 * @hash_data_cur: pointer to a #iodefv2_hash_data_t object.
 *
 * Get the next #iodefv2_hash_data_t object listed in @ptr.
 * When iterating over the iodefv2_hash_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_hash_data_t object.
 *
 * Returns: the next #iodefv2_hash_data_t in the list.
 */
iodefv2_hash_data_t *iodefv2_email_data_get_next_hash_data(iodefv2_email_data_t *email_data, iodefv2_hash_data_t *hash_data_cur)
{
        libiodefv2_list_t *tmp = (hash_data_cur) ? &((libiodefv2_linked_object_t *) hash_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(email_data, NULL);

        libiodefv2_list_for_each_continue(&email_data->hash_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_email_data_set_hash_data:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @object: pointer to a #iodefv2_hash_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_hash_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_email_data_set_hash_data(iodefv2_email_data_t *ptr, iodefv2_hash_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->hash_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_email_data_new_hash_data:
 *  @ptr: pointer to a #iodefv2_email_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_hash_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_hash_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_hash_data_t object. The created #iodefv2_hash_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_data_new_hash_data(iodefv2_email_data_t *ptr, iodefv2_hash_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_hash_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->hash_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_email_data_get_email_from:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 *
 * Get email_from children of the #iodefv2_email_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_email_data_get_email_from(iodefv2_email_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->email_from;

}


/**
 * iodefv2_email_data_set_email_from:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @email_from: pointer to a #libiodefv2_string_t object.
 *
 * Set @email_from object as a children of @ptr.
 * if @ptr already contain an @email_from object, then it is destroyed,
 * and updated to point to the provided @email_from object.
 */

void iodefv2_email_data_set_email_from(iodefv2_email_data_t *ptr, libiodefv2_string_t *email_from)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->email_from )
                libiodefv2_string_destroy(ptr->email_from);

        ptr->email_from = email_from;
}
/**
 * iodefv2_email_data_new_email_from:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new email_from object, children of #iodefv2_email_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_data_new_email_from(iodefv2_email_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->email_from ) {
                retval = libiodefv2_string_new(&ptr->email_from);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->email_from;
        return 0;
}




/**
 * iodefv2_email_data_get_application_header:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 *
 * Get application_header children of the #iodefv2_email_data_t object.
 *
 * Returns: a pointer to a iodefv2_application_header_t object, or NULL if the children object is not set.
 */
iodefv2_application_header_t *iodefv2_email_data_get_application_header(iodefv2_email_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->application_header;

}


/**
 * iodefv2_email_data_set_application_header:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @application_header: pointer to a #iodefv2_application_header_t object.
 *
 * Set @application_header object as a children of @ptr.
 * if @ptr already contain an @application_header object, then it is destroyed,
 * and updated to point to the provided @application_header object.
 */

void iodefv2_email_data_set_application_header(iodefv2_email_data_t *ptr, iodefv2_application_header_t *application_header)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->application_header )
                iodefv2_application_header_destroy(ptr->application_header);

        ptr->application_header = application_header;
}
/**
 * iodefv2_email_data_new_application_header:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_application_header_t object.
 *
 * Create a new application_header object, children of #iodefv2_email_data_t.
 * If @ptr already contain a #iodefv2_application_header_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_data_new_application_header(iodefv2_email_data_t *ptr, iodefv2_application_header_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->application_header ) {
                retval = iodefv2_application_header_new(&ptr->application_header);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->application_header;
        return 0;
}




/**
 * iodefv2_email_data_get_email_body:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 *
 * Get email_body children of the #iodefv2_email_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_email_data_get_email_body(iodefv2_email_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->email_body;

}


/**
 * iodefv2_email_data_set_email_body:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @email_body: pointer to a #libiodefv2_string_t object.
 *
 * Set @email_body object as a children of @ptr.
 * if @ptr already contain an @email_body object, then it is destroyed,
 * and updated to point to the provided @email_body object.
 */

void iodefv2_email_data_set_email_body(iodefv2_email_data_t *ptr, libiodefv2_string_t *email_body)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->email_body )
                libiodefv2_string_destroy(ptr->email_body);

        ptr->email_body = email_body;
}
/**
 * iodefv2_email_data_new_email_body:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new email_body object, children of #iodefv2_email_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_data_new_email_body(iodefv2_email_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->email_body ) {
                retval = libiodefv2_string_new(&ptr->email_body);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->email_body;
        return 0;
}




/**
 * iodefv2_email_data_get_email_message:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 *
 * Get email_message children of the #iodefv2_email_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_email_data_get_email_message(iodefv2_email_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->email_message;

}


/**
 * iodefv2_email_data_set_email_message:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @email_message: pointer to a #libiodefv2_string_t object.
 *
 * Set @email_message object as a children of @ptr.
 * if @ptr already contain an @email_message object, then it is destroyed,
 * and updated to point to the provided @email_message object.
 */

void iodefv2_email_data_set_email_message(iodefv2_email_data_t *ptr, libiodefv2_string_t *email_message)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->email_message )
                libiodefv2_string_destroy(ptr->email_message);

        ptr->email_message = email_message;
}
/**
 * iodefv2_email_data_new_email_message:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new email_message object, children of #iodefv2_email_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_data_new_email_message(iodefv2_email_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->email_message ) {
                retval = libiodefv2_string_new(&ptr->email_message);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->email_message;
        return 0;
}




/**
 * iodefv2_email_data_get_email_to:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 *
 * Get email_to children of the #iodefv2_email_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_email_data_get_email_to(iodefv2_email_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->email_to;

}


/**
 * iodefv2_email_data_set_email_to:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @email_to: pointer to a #libiodefv2_string_t object.
 *
 * Set @email_to object as a children of @ptr.
 * if @ptr already contain an @email_to object, then it is destroyed,
 * and updated to point to the provided @email_to object.
 */

void iodefv2_email_data_set_email_to(iodefv2_email_data_t *ptr, libiodefv2_string_t *email_to)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->email_to )
                libiodefv2_string_destroy(ptr->email_to);

        ptr->email_to = email_to;
}
/**
 * iodefv2_email_data_new_email_to:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new email_to object, children of #iodefv2_email_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_email_data_new_email_to(iodefv2_email_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->email_to ) {
                retval = libiodefv2_string_new(&ptr->email_to);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->email_to;
        return 0;
}



/**
 * iodefv2_email_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_email_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_email_data_copy(const iodefv2_email_data_t *src, iodefv2_email_data_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->email_headers ) {
                libiodefv2_string_destroy(dst->email_headers);
                dst->email_headers = NULL;
        }

        if ( src->email_headers ) {
                ret = libiodefv2_string_clone(src->email_headers, &dst->email_headers);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_signature_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->signature_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_signature_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->signature_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_signature_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->signature_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->email_subject ) {
                libiodefv2_string_destroy(dst->email_subject);
                dst->email_subject = NULL;
        }

        if ( src->email_subject ) {
                ret = libiodefv2_string_clone(src->email_subject, &dst->email_subject);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->email_x_mailer ) {
                libiodefv2_string_destroy(dst->email_x_mailer);
                dst->email_x_mailer = NULL;
        }

        if ( src->email_x_mailer ) {
                ret = libiodefv2_string_clone(src->email_x_mailer, &dst->email_x_mailer);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_hash_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->hash_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_hash_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->hash_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_hash_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->hash_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->email_from ) {
                libiodefv2_string_destroy(dst->email_from);
                dst->email_from = NULL;
        }

        if ( src->email_from ) {
                ret = libiodefv2_string_clone(src->email_from, &dst->email_from);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->application_header ) {
                iodefv2_application_header_destroy(dst->application_header);
                dst->application_header = NULL;
        }

        if ( src->application_header ) {
                ret = iodefv2_application_header_clone(src->application_header, &dst->application_header);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->email_body ) {
                libiodefv2_string_destroy(dst->email_body);
                dst->email_body = NULL;
        }

        if ( src->email_body ) {
                ret = libiodefv2_string_clone(src->email_body, &dst->email_body);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->email_message ) {
                libiodefv2_string_destroy(dst->email_message);
                dst->email_message = NULL;
        }

        if ( src->email_message ) {
                ret = libiodefv2_string_clone(src->email_message, &dst->email_message);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->email_to ) {
                libiodefv2_string_destroy(dst->email_to);
                dst->email_to = NULL;
        }

        if ( src->email_to ) {
                ret = libiodefv2_string_clone(src->email_to, &dst->email_to);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_email_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_email_data_clone(iodefv2_email_data_t *src, iodefv2_email_data_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_email_data_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_email_data_copy(src, *dst);
}


/**
 * iodefv2_email_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_email_data_compare(const iodefv2_email_data_t *obj1, const iodefv2_email_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->email_headers, obj2->email_headers);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_signature_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->signature_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->signature_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_signature_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->email_subject, obj2->email_subject);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->email_x_mailer, obj2->email_x_mailer);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_hash_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->hash_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->hash_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_hash_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->email_from, obj2->email_from);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_application_header_compare(obj1->application_header, obj2->application_header);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->email_body, obj2->email_body);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->email_message, obj2->email_message);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->email_to, obj2->email_to);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_file_new:
 * @ret: Pointer where to store the created #iodefv2_file_t object.
 *
 * Create a new #iodefv2_file_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_file_new(iodefv2_file_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_FILE;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);












            return 0;
}


/**
 * iodefv2_file_ref:
 * @file: pointer to a #iodefv2_file_t object.
 *
 * Increase @file reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @file.
 */
iodefv2_file_t *iodefv2_file_ref(iodefv2_file_t *file)
{
        libiodefv2_return_val_if_fail(file, NULL);
        file->refcount++;

        return file;
}



int _iodefv2_file_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_file_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);



            case 1:
                *childptr = ptr->hash_data;
                return 0;

            case 2:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 3:
                *childptr = ptr->signature_data;
                return 0;


            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->url, TRUE);



            case 5:
                *childptr = ptr->software;
                return 0;


            case 6:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->file_name, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_file_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_file_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_file_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 1:
                    return iodefv2_file_new_hash_data(ptr, (iodefv2_hash_data_t **) ret);

                case 2: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_file_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_file_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 3:
                    return iodefv2_file_new_signature_data(ptr, (iodefv2_signature_data_t **) ret);

                case 4:
                    return iodefv2_file_new_url(ptr, (libiodefv2_string_t **) ret);

                case 5:
                    return iodefv2_file_new_software(ptr, (iodefv2_software_t **) ret);

                case 6:
                    return iodefv2_file_new_file_name(ptr, (libiodefv2_string_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_file_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_file_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;




                case 1:
                        if ( ptr->hash_data ) {
                                iodefv2_hash_data_destroy(ptr->hash_data);
                                ptr->hash_data = NULL;
                        }

                        return 0;

    
                case 2: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 3:
                        if ( ptr->signature_data ) {
                                iodefv2_signature_data_destroy(ptr->signature_data);
                                ptr->signature_data = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->url ) {
                                libiodefv2_string_destroy(ptr->url);
                                ptr->url = NULL;
                        }

                        return 0;




                case 5:
                        if ( ptr->software ) {
                                iodefv2_software_destroy(ptr->software);
                                ptr->software = NULL;
                        }

                        return 0;




                case 6:
                        if ( ptr->file_name ) {
                                libiodefv2_string_destroy(ptr->file_name);
                                ptr->file_name = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_file_destroy_internal(iodefv2_file_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);

        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }




        if ( ptr->hash_data ) {
                iodefv2_hash_data_destroy(ptr->hash_data);
                ptr->hash_data = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }


        if ( ptr->signature_data ) {
                iodefv2_signature_data_destroy(ptr->signature_data);
                ptr->signature_data = NULL;
        }



        if ( ptr->url ) {
                libiodefv2_string_destroy(ptr->url);
                ptr->url = NULL;
        }




        if ( ptr->software ) {
                iodefv2_software_destroy(ptr->software);
                ptr->software = NULL;
        }



        if ( ptr->file_name ) {
                libiodefv2_string_destroy(ptr->file_name);
                ptr->file_name = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_file_destroy:
 * @ptr: pointer to a #iodefv2_file_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_file_destroy(iodefv2_file_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_file_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_file_get_observable_id:
 * @ptr: pointer to a #iodefv2_file_t object.
 *
 * Get observable_id children of the #iodefv2_file_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_file_get_observable_id(iodefv2_file_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_file_set_observable_id:
 * @ptr: pointer to a #iodefv2_file_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_file_set_observable_id(iodefv2_file_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_file_new_observable_id:
 * @ptr: pointer to a #iodefv2_file_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_file_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_file_new_observable_id(iodefv2_file_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}




/**
 * iodefv2_file_get_hash_data:
 * @ptr: pointer to a #iodefv2_file_t object.
 *
 * Get hash_data children of the #iodefv2_file_t object.
 *
 * Returns: a pointer to a iodefv2_hash_data_t object, or NULL if the children object is not set.
 */
iodefv2_hash_data_t *iodefv2_file_get_hash_data(iodefv2_file_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->hash_data;

}


/**
 * iodefv2_file_set_hash_data:
 * @ptr: pointer to a #iodefv2_file_t object.
 * @hash_data: pointer to a #iodefv2_hash_data_t object.
 *
 * Set @hash_data object as a children of @ptr.
 * if @ptr already contain an @hash_data object, then it is destroyed,
 * and updated to point to the provided @hash_data object.
 */

void iodefv2_file_set_hash_data(iodefv2_file_t *ptr, iodefv2_hash_data_t *hash_data)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->hash_data )
                iodefv2_hash_data_destroy(ptr->hash_data);

        ptr->hash_data = hash_data;
}
/**
 * iodefv2_file_new_hash_data:
 * @ptr: pointer to a #iodefv2_file_t object.
 * @ret: pointer to an address where to store the created #iodefv2_hash_data_t object.
 *
 * Create a new hash_data object, children of #iodefv2_file_t.
 * If @ptr already contain a #iodefv2_hash_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_file_new_hash_data(iodefv2_file_t *ptr, iodefv2_hash_data_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->hash_data ) {
                retval = iodefv2_hash_data_new(&ptr->hash_data);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->hash_data;
        return 0;
}





/**
 * iodefv2_file_get_next_additional_data:
 * @file: pointer to a #iodefv2_file_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_file_get_next_additional_data(iodefv2_file_t *file, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(file, NULL);

        libiodefv2_list_for_each_continue(&file->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_file_set_additional_data:
 * @ptr: pointer to a #iodefv2_file_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_file_set_additional_data(iodefv2_file_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_file_new_additional_data:
 *  @ptr: pointer to a #iodefv2_file_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_file_new_additional_data(iodefv2_file_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_file_get_signature_data:
 * @ptr: pointer to a #iodefv2_file_t object.
 *
 * Get signature_data children of the #iodefv2_file_t object.
 *
 * Returns: a pointer to a iodefv2_signature_data_t object, or NULL if the children object is not set.
 */
iodefv2_signature_data_t *iodefv2_file_get_signature_data(iodefv2_file_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->signature_data;

}


/**
 * iodefv2_file_set_signature_data:
 * @ptr: pointer to a #iodefv2_file_t object.
 * @signature_data: pointer to a #iodefv2_signature_data_t object.
 *
 * Set @signature_data object as a children of @ptr.
 * if @ptr already contain an @signature_data object, then it is destroyed,
 * and updated to point to the provided @signature_data object.
 */

void iodefv2_file_set_signature_data(iodefv2_file_t *ptr, iodefv2_signature_data_t *signature_data)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->signature_data )
                iodefv2_signature_data_destroy(ptr->signature_data);

        ptr->signature_data = signature_data;
}
/**
 * iodefv2_file_new_signature_data:
 * @ptr: pointer to a #iodefv2_file_t object.
 * @ret: pointer to an address where to store the created #iodefv2_signature_data_t object.
 *
 * Create a new signature_data object, children of #iodefv2_file_t.
 * If @ptr already contain a #iodefv2_signature_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_file_new_signature_data(iodefv2_file_t *ptr, iodefv2_signature_data_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->signature_data ) {
                retval = iodefv2_signature_data_new(&ptr->signature_data);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->signature_data;
        return 0;
}




/**
 * iodefv2_file_get_url:
 * @ptr: pointer to a #iodefv2_file_t object.
 *
 * Get url children of the #iodefv2_file_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_file_get_url(iodefv2_file_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->url;

}


/**
 * iodefv2_file_set_url:
 * @ptr: pointer to a #iodefv2_file_t object.
 * @url: pointer to a #libiodefv2_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void iodefv2_file_set_url(iodefv2_file_t *ptr, libiodefv2_string_t *url)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->url )
                libiodefv2_string_destroy(ptr->url);

        ptr->url = url;
}
/**
 * iodefv2_file_new_url:
 * @ptr: pointer to a #iodefv2_file_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new url object, children of #iodefv2_file_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_file_new_url(iodefv2_file_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->url ) {
                retval = libiodefv2_string_new(&ptr->url);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->url;
        return 0;
}




/**
 * iodefv2_file_get_software:
 * @ptr: pointer to a #iodefv2_file_t object.
 *
 * Get software children of the #iodefv2_file_t object.
 *
 * Returns: a pointer to a iodefv2_software_t object, or NULL if the children object is not set.
 */
iodefv2_software_t *iodefv2_file_get_software(iodefv2_file_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->software;

}


/**
 * iodefv2_file_set_software:
 * @ptr: pointer to a #iodefv2_file_t object.
 * @software: pointer to a #iodefv2_software_t object.
 *
 * Set @software object as a children of @ptr.
 * if @ptr already contain an @software object, then it is destroyed,
 * and updated to point to the provided @software object.
 */

void iodefv2_file_set_software(iodefv2_file_t *ptr, iodefv2_software_t *software)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->software )
                iodefv2_software_destroy(ptr->software);

        ptr->software = software;
}
/**
 * iodefv2_file_new_software:
 * @ptr: pointer to a #iodefv2_file_t object.
 * @ret: pointer to an address where to store the created #iodefv2_software_t object.
 *
 * Create a new software object, children of #iodefv2_file_t.
 * If @ptr already contain a #iodefv2_software_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_file_new_software(iodefv2_file_t *ptr, iodefv2_software_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->software ) {
                retval = iodefv2_software_new(&ptr->software);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->software;
        return 0;
}




/**
 * iodefv2_file_get_file_name:
 * @ptr: pointer to a #iodefv2_file_t object.
 *
 * Get file_name children of the #iodefv2_file_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_file_get_file_name(iodefv2_file_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->file_name;

}


/**
 * iodefv2_file_set_file_name:
 * @ptr: pointer to a #iodefv2_file_t object.
 * @file_name: pointer to a #libiodefv2_string_t object.
 *
 * Set @file_name object as a children of @ptr.
 * if @ptr already contain an @file_name object, then it is destroyed,
 * and updated to point to the provided @file_name object.
 */

void iodefv2_file_set_file_name(iodefv2_file_t *ptr, libiodefv2_string_t *file_name)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->file_name )
                libiodefv2_string_destroy(ptr->file_name);

        ptr->file_name = file_name;
}
/**
 * iodefv2_file_new_file_name:
 * @ptr: pointer to a #iodefv2_file_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new file_name object, children of #iodefv2_file_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_file_new_file_name(iodefv2_file_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->file_name ) {
                retval = libiodefv2_string_new(&ptr->file_name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->file_name;
        return 0;
}



/**
 * iodefv2_file_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_file_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_file_copy(const iodefv2_file_t *src, iodefv2_file_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->hash_data ) {
                iodefv2_hash_data_destroy(dst->hash_data);
                dst->hash_data = NULL;
        }

        if ( src->hash_data ) {
                ret = iodefv2_hash_data_clone(src->hash_data, &dst->hash_data);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->signature_data ) {
                iodefv2_signature_data_destroy(dst->signature_data);
                dst->signature_data = NULL;
        }

        if ( src->signature_data ) {
                ret = iodefv2_signature_data_clone(src->signature_data, &dst->signature_data);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->url ) {
                libiodefv2_string_destroy(dst->url);
                dst->url = NULL;
        }

        if ( src->url ) {
                ret = libiodefv2_string_clone(src->url, &dst->url);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->software ) {
                iodefv2_software_destroy(dst->software);
                dst->software = NULL;
        }

        if ( src->software ) {
                ret = iodefv2_software_clone(src->software, &dst->software);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->file_name ) {
                libiodefv2_string_destroy(dst->file_name);
                dst->file_name = NULL;
        }

        if ( src->file_name ) {
                ret = libiodefv2_string_clone(src->file_name, &dst->file_name);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_file_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_file_clone(iodefv2_file_t *src, iodefv2_file_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_file_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_file_copy(src, *dst);
}


/**
 * iodefv2_file_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_file_compare(const iodefv2_file_t *obj1, const iodefv2_file_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_hash_data_compare(obj1->hash_data, obj2->hash_data);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_signature_data_compare(obj1->signature_data, obj2->signature_data);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->url, obj2->url);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_software_compare(obj1->software, obj2->software);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->file_name, obj2->file_name);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_node_new:
 * @ret: Pointer where to store the created #iodefv2_node_t object.
 *
 * Create a new #iodefv2_node_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_node_new(iodefv2_node_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_NODE;


        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->counter_list);


        libiodefv2_list_init(&(*ret)->domain_data_list);


        libiodefv2_list_init(&(*ret)->address_list);









            return 0;
}


/**
 * iodefv2_node_ref:
 * @node: pointer to a #iodefv2_node_t object.
 *
 * Increase @node reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @node.
 */
iodefv2_node_t *iodefv2_node_ref(iodefv2_node_t *node)
{
        libiodefv2_return_val_if_fail(node, NULL);
        node->refcount++;

        return node;
}



int _iodefv2_node_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_node_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->postal_address, TRUE);


            case 1:
                *childptr = &ptr->counter_list;
                return 0;


            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->location, TRUE);


            case 3:
                *childptr = &ptr->domain_data_list;
                return 0;

            case 4:
                *childptr = &ptr->address_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_node_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_node_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_node_new_postal_address(ptr, (libiodefv2_string_t **) ret);

                case 1: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_node_new_counter(ptr, (iodefv2_counter_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->counter_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->counter_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_node_new_counter(ptr, (iodefv2_counter_t **) ret, n);
                }

                case 2:
                    return iodefv2_node_new_location(ptr, (libiodefv2_string_t **) ret);

                case 3: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_node_new_domain_data(ptr, (iodefv2_domain_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->domain_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->domain_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_node_new_domain_data(ptr, (iodefv2_domain_data_t **) ret, n);
                }

                case 4: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_node_new_address(ptr, (iodefv2_address_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->address_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->address_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_node_new_address(ptr, (iodefv2_address_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_node_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_node_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                        if ( ptr->postal_address ) {
                                libiodefv2_string_destroy(ptr->postal_address);
                                ptr->postal_address = NULL;
                        }

                        return 0;

    
                case 1: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->counter_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_counter_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->counter_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_counter_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 2:
                        if ( ptr->location ) {
                                libiodefv2_string_destroy(ptr->location);
                                ptr->location = NULL;
                        }

                        return 0;

    
                case 3: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->domain_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_domain_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->domain_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_domain_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 4: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->address_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_address_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->address_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_address_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_node_destroy_internal(iodefv2_node_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( ptr->postal_address ) {
                libiodefv2_string_destroy(ptr->postal_address);
                ptr->postal_address = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_counter_t *entry;

                libiodefv2_list_for_each_safe(&ptr->counter_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_counter_destroy(entry);
                }
        }

        if ( ptr->location ) {
                libiodefv2_string_destroy(ptr->location);
                ptr->location = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_domain_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->domain_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_domain_data_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_address_t *entry;

                libiodefv2_list_for_each_safe(&ptr->address_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_address_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_node_destroy:
 * @ptr: pointer to a #iodefv2_node_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_node_destroy(iodefv2_node_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_node_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_node_get_postal_address:
 * @ptr: pointer to a #iodefv2_node_t object.
 *
 * Get postal_address children of the #iodefv2_node_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_node_get_postal_address(iodefv2_node_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->postal_address;

}


/**
 * iodefv2_node_set_postal_address:
 * @ptr: pointer to a #iodefv2_node_t object.
 * @postal_address: pointer to a #libiodefv2_string_t object.
 *
 * Set @postal_address object as a children of @ptr.
 * if @ptr already contain an @postal_address object, then it is destroyed,
 * and updated to point to the provided @postal_address object.
 */

void iodefv2_node_set_postal_address(iodefv2_node_t *ptr, libiodefv2_string_t *postal_address)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->postal_address )
                libiodefv2_string_destroy(ptr->postal_address);

        ptr->postal_address = postal_address;
}
/**
 * iodefv2_node_new_postal_address:
 * @ptr: pointer to a #iodefv2_node_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new postal_address object, children of #iodefv2_node_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_node_new_postal_address(iodefv2_node_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->postal_address ) {
                retval = libiodefv2_string_new(&ptr->postal_address);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->postal_address;
        return 0;
}





/**
 * iodefv2_node_get_next_counter:
 * @node: pointer to a #iodefv2_node_t object.
 * @counter_cur: pointer to a #iodefv2_counter_t object.
 *
 * Get the next #iodefv2_counter_t object listed in @ptr.
 * When iterating over the iodefv2_counter_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_counter_t object.
 *
 * Returns: the next #iodefv2_counter_t in the list.
 */
iodefv2_counter_t *iodefv2_node_get_next_counter(iodefv2_node_t *node, iodefv2_counter_t *counter_cur)
{
        libiodefv2_list_t *tmp = (counter_cur) ? &((libiodefv2_linked_object_t *) counter_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(node, NULL);

        libiodefv2_list_for_each_continue(&node->counter_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_node_set_counter:
 * @ptr: pointer to a #iodefv2_node_t object.
 * @object: pointer to a #iodefv2_counter_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_counter_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_node_set_counter(iodefv2_node_t *ptr, iodefv2_counter_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->counter_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_node_new_counter:
 *  @ptr: pointer to a #iodefv2_node_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_counter_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_counter_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_counter_t object. The created #iodefv2_counter_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_node_new_counter(iodefv2_node_t *ptr, iodefv2_counter_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_counter_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->counter_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_node_get_location:
 * @ptr: pointer to a #iodefv2_node_t object.
 *
 * Get location children of the #iodefv2_node_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_node_get_location(iodefv2_node_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->location;

}


/**
 * iodefv2_node_set_location:
 * @ptr: pointer to a #iodefv2_node_t object.
 * @location: pointer to a #libiodefv2_string_t object.
 *
 * Set @location object as a children of @ptr.
 * if @ptr already contain an @location object, then it is destroyed,
 * and updated to point to the provided @location object.
 */

void iodefv2_node_set_location(iodefv2_node_t *ptr, libiodefv2_string_t *location)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->location )
                libiodefv2_string_destroy(ptr->location);

        ptr->location = location;
}
/**
 * iodefv2_node_new_location:
 * @ptr: pointer to a #iodefv2_node_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new location object, children of #iodefv2_node_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_node_new_location(iodefv2_node_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->location ) {
                retval = libiodefv2_string_new(&ptr->location);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->location;
        return 0;
}





/**
 * iodefv2_node_get_next_domain_data:
 * @node: pointer to a #iodefv2_node_t object.
 * @domain_data_cur: pointer to a #iodefv2_domain_data_t object.
 *
 * Get the next #iodefv2_domain_data_t object listed in @ptr.
 * When iterating over the iodefv2_domain_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_domain_data_t object.
 *
 * Returns: the next #iodefv2_domain_data_t in the list.
 */
iodefv2_domain_data_t *iodefv2_node_get_next_domain_data(iodefv2_node_t *node, iodefv2_domain_data_t *domain_data_cur)
{
        libiodefv2_list_t *tmp = (domain_data_cur) ? &((libiodefv2_linked_object_t *) domain_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(node, NULL);

        libiodefv2_list_for_each_continue(&node->domain_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_node_set_domain_data:
 * @ptr: pointer to a #iodefv2_node_t object.
 * @object: pointer to a #iodefv2_domain_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_domain_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_node_set_domain_data(iodefv2_node_t *ptr, iodefv2_domain_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->domain_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_node_new_domain_data:
 *  @ptr: pointer to a #iodefv2_node_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_domain_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_domain_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_domain_data_t object. The created #iodefv2_domain_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_node_new_domain_data(iodefv2_node_t *ptr, iodefv2_domain_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_domain_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->domain_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_node_get_next_address:
 * @node: pointer to a #iodefv2_node_t object.
 * @address_cur: pointer to a #iodefv2_address_t object.
 *
 * Get the next #iodefv2_address_t object listed in @ptr.
 * When iterating over the iodefv2_address_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_address_t object.
 *
 * Returns: the next #iodefv2_address_t in the list.
 */
iodefv2_address_t *iodefv2_node_get_next_address(iodefv2_node_t *node, iodefv2_address_t *address_cur)
{
        libiodefv2_list_t *tmp = (address_cur) ? &((libiodefv2_linked_object_t *) address_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(node, NULL);

        libiodefv2_list_for_each_continue(&node->address_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_node_set_address:
 * @ptr: pointer to a #iodefv2_node_t object.
 * @object: pointer to a #iodefv2_address_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_address_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_node_set_address(iodefv2_node_t *ptr, iodefv2_address_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->address_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_node_new_address:
 *  @ptr: pointer to a #iodefv2_node_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_address_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_address_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_address_t object. The created #iodefv2_address_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_node_new_address(iodefv2_node_t *ptr, iodefv2_address_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_address_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->address_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_node_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_node_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_node_copy(const iodefv2_node_t *src, iodefv2_node_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        if ( dst->postal_address ) {
                libiodefv2_string_destroy(dst->postal_address);
                dst->postal_address = NULL;
        }

        if ( src->postal_address ) {
                ret = libiodefv2_string_clone(src->postal_address, &dst->postal_address);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_counter_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->counter_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_counter_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->counter_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_counter_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->counter_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->location ) {
                libiodefv2_string_destroy(dst->location);
                dst->location = NULL;
        }

        if ( src->location ) {
                ret = libiodefv2_string_clone(src->location, &dst->location);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_domain_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->domain_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_domain_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->domain_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_domain_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->domain_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_address_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->address_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_address_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->address_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_address_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->address_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_node_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_node_clone(iodefv2_node_t *src, iodefv2_node_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_node_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_node_copy(src, *dst);
}


/**
 * iodefv2_node_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_node_compare(const iodefv2_node_t *obj1, const iodefv2_node_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        ret = libiodefv2_string_compare(obj1->postal_address, obj2->postal_address);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_counter_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->counter_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->counter_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_counter_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->location, obj2->location);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_domain_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->domain_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->domain_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_domain_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_address_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->address_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->address_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_address_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_service_new:
 * @ret: Pointer where to store the created #iodefv2_service_t object.
 *
 * Create a new #iodefv2_service_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_service_new(iodefv2_service_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_SERVICE;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->software_list);
















            return 0;
}


/**
 * iodefv2_service_ref:
 * @service: pointer to a #iodefv2_service_t object.
 *
 * Increase @service reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @service.
 */
iodefv2_service_t *iodefv2_service_ref(iodefv2_service_t *service)
{
        libiodefv2_return_val_if_fail(service, NULL);
        service->refcount++;

        return service;
}



int _iodefv2_service_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_service_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {

            case 0:
                return iodefv2_value_new_uint32((iodefv2_value_t **) childptr, ptr->ip_protocol);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);


            case 2:
                         return (ptr->proto_code_is_set) ? iodefv2_value_new_uint32((iodefv2_value_t **) childptr, ptr->proto_code) : 0;


            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->portlist, TRUE);


            case 4:
                         return (ptr->proto_field_is_set) ? iodefv2_value_new_uint32((iodefv2_value_t **) childptr, ptr->proto_field) : 0;


            case 5:
                *childptr = ptr->service_name;
                return 0;


            case 6:
                *childptr = ptr->application_header;
                return 0;


            case 7:
                *childptr = ptr->email_data;
                return 0;

            case 8:
                         return (ptr->proto_type_is_set) ? iodefv2_value_new_uint32((iodefv2_value_t **) childptr, ptr->proto_type) : 0;

            case 9:
                         return (ptr->port_is_set) ? iodefv2_value_new_uint32((iodefv2_value_t **) childptr, ptr->port) : 0;

            case 10:
                *childptr = &ptr->software_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_service_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_service_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_service_new_ip_protocol(ptr, (uint32_t **) ret);

                case 1:
                    return iodefv2_service_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_service_new_proto_code(ptr, (uint32_t **) ret);

                case 3:
                    return iodefv2_service_new_portlist(ptr, (libiodefv2_string_t **) ret);

                case 4:
                    return iodefv2_service_new_proto_field(ptr, (uint32_t **) ret);

                case 5:
                    return iodefv2_service_new_service_name(ptr, (iodefv2_service_name_t **) ret);

                case 6:
                    return iodefv2_service_new_application_header(ptr, (iodefv2_application_header_t **) ret);

                case 7:
                    return iodefv2_service_new_email_data(ptr, (iodefv2_email_data_t **) ret);

                case 8:
                    return iodefv2_service_new_proto_type(ptr, (uint32_t **) ret);

                case 9:
                    return iodefv2_service_new_port(ptr, (uint32_t **) ret);

                case 10: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_service_new_software(ptr, (iodefv2_software_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->software_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->software_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_service_new_software(ptr, (iodefv2_software_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_service_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_service_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {





                case 1:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;

                case 2:
                        ptr->proto_code_is_set = 0;
                        return 0;




                case 3:
                        if ( ptr->portlist ) {
                                libiodefv2_string_destroy(ptr->portlist);
                                ptr->portlist = NULL;
                        }

                        return 0;

                case 4:
                        ptr->proto_field_is_set = 0;
                        return 0;




                case 5:
                        if ( ptr->service_name ) {
                                iodefv2_service_name_destroy(ptr->service_name);
                                ptr->service_name = NULL;
                        }

                        return 0;




                case 6:
                        if ( ptr->application_header ) {
                                iodefv2_application_header_destroy(ptr->application_header);
                                ptr->application_header = NULL;
                        }

                        return 0;




                case 7:
                        if ( ptr->email_data ) {
                                iodefv2_email_data_destroy(ptr->email_data);
                                ptr->email_data = NULL;
                        }

                        return 0;

                case 8:
                        ptr->proto_type_is_set = 0;
                        return 0;

                case 9:
                        ptr->port_is_set = 0;
                        return 0;

    
                case 10: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->software_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_software_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->software_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_software_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_service_destroy_internal(iodefv2_service_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }





        if ( ptr->portlist ) {
                libiodefv2_string_destroy(ptr->portlist);
                ptr->portlist = NULL;
        }






        if ( ptr->service_name ) {
                iodefv2_service_name_destroy(ptr->service_name);
                ptr->service_name = NULL;
        }




        if ( ptr->application_header ) {
                iodefv2_application_header_destroy(ptr->application_header);
                ptr->application_header = NULL;
        }




        if ( ptr->email_data ) {
                iodefv2_email_data_destroy(ptr->email_data);
                ptr->email_data = NULL;
        }








        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_software_t *entry;

                libiodefv2_list_for_each_safe(&ptr->software_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_software_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_service_destroy:
 * @ptr: pointer to a #iodefv2_service_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_service_destroy(iodefv2_service_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_service_destroy_internal(ptr);
        free(ptr);
}




/**
 * iodefv2_service_get_ip_protocol:
 * @ptr: pointer to a #iodefv2_service_t object.
 *
 * Get ip_protocol children of the #iodefv2_service_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t iodefv2_service_get_ip_protocol(iodefv2_service_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ip_protocol;

}


/**
 * iodefv2_service_set_ip_protocol:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @ip_protocol: pointer to a #uint32_t object.
 *
 * Set @ip_protocol object as a children of @ptr.
 * if @ptr already contain an @ip_protocol object, then it is destroyed,
 * and updated to point to the provided @ip_protocol object.
 */
void iodefv2_service_set_ip_protocol(iodefv2_service_t *ptr, uint32_t ip_protocol)
{
        libiodefv2_return_if_fail(ptr);
        ptr->ip_protocol = ip_protocol;
}
/**
 * iodefv2_service_new_ip_protocol:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new ip_protocol object, children of #iodefv2_service_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_service_new_ip_protocol(iodefv2_service_t *ptr, uint32_t **ret)
{




        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->ip_protocol;
        return 0;
}




/**
 * iodefv2_service_get_observable_id:
 * @ptr: pointer to a #iodefv2_service_t object.
 *
 * Get observable_id children of the #iodefv2_service_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_service_get_observable_id(iodefv2_service_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_service_set_observable_id:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_service_set_observable_id(iodefv2_service_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_service_new_observable_id:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_service_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_service_new_observable_id(iodefv2_service_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}




/**
 * iodefv2_service_get_proto_code:
 * @ptr: pointer to a #iodefv2_service_t object.
 *
 * Get proto_code children of the #iodefv2_service_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *iodefv2_service_get_proto_code(iodefv2_service_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->proto_code_is_set ? &ptr->proto_code : NULL;


}


/**
 * iodefv2_service_set_proto_code:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @proto_code: pointer to a #uint32_t object.
 *
 * Set @proto_code object as a children of @ptr.
 * if @ptr already contain an @proto_code object, then it is destroyed,
 * and updated to point to the provided @proto_code object.
 */
void iodefv2_service_set_proto_code(iodefv2_service_t *ptr, uint32_t proto_code)
{
        libiodefv2_return_if_fail(ptr);
        ptr->proto_code = proto_code;
        ptr->proto_code_is_set = 1;
}

void iodefv2_service_unset_proto_code(iodefv2_service_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->proto_code_is_set = 0;
}
/**
 * iodefv2_service_new_proto_code:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new proto_code object, children of #iodefv2_service_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_service_new_proto_code(iodefv2_service_t *ptr, uint32_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->proto_code_is_set = 1;



        *ret = &ptr->proto_code;
        return 0;
}




/**
 * iodefv2_service_get_portlist:
 * @ptr: pointer to a #iodefv2_service_t object.
 *
 * Get portlist children of the #iodefv2_service_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_service_get_portlist(iodefv2_service_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->portlist;

}


/**
 * iodefv2_service_set_portlist:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @portlist: pointer to a #libiodefv2_string_t object.
 *
 * Set @portlist object as a children of @ptr.
 * if @ptr already contain an @portlist object, then it is destroyed,
 * and updated to point to the provided @portlist object.
 */

void iodefv2_service_set_portlist(iodefv2_service_t *ptr, libiodefv2_string_t *portlist)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->portlist )
                libiodefv2_string_destroy(ptr->portlist);

        ptr->portlist = portlist;
}
/**
 * iodefv2_service_new_portlist:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new portlist object, children of #iodefv2_service_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_service_new_portlist(iodefv2_service_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->portlist ) {
                retval = libiodefv2_string_new(&ptr->portlist);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->portlist;
        return 0;
}




/**
 * iodefv2_service_get_proto_field:
 * @ptr: pointer to a #iodefv2_service_t object.
 *
 * Get proto_field children of the #iodefv2_service_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *iodefv2_service_get_proto_field(iodefv2_service_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->proto_field_is_set ? &ptr->proto_field : NULL;


}


/**
 * iodefv2_service_set_proto_field:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @proto_field: pointer to a #uint32_t object.
 *
 * Set @proto_field object as a children of @ptr.
 * if @ptr already contain an @proto_field object, then it is destroyed,
 * and updated to point to the provided @proto_field object.
 */
void iodefv2_service_set_proto_field(iodefv2_service_t *ptr, uint32_t proto_field)
{
        libiodefv2_return_if_fail(ptr);
        ptr->proto_field = proto_field;
        ptr->proto_field_is_set = 1;
}

void iodefv2_service_unset_proto_field(iodefv2_service_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->proto_field_is_set = 0;
}
/**
 * iodefv2_service_new_proto_field:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new proto_field object, children of #iodefv2_service_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_service_new_proto_field(iodefv2_service_t *ptr, uint32_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->proto_field_is_set = 1;



        *ret = &ptr->proto_field;
        return 0;
}




/**
 * iodefv2_service_get_service_name:
 * @ptr: pointer to a #iodefv2_service_t object.
 *
 * Get service_name children of the #iodefv2_service_t object.
 *
 * Returns: a pointer to a iodefv2_service_name_t object, or NULL if the children object is not set.
 */
iodefv2_service_name_t *iodefv2_service_get_service_name(iodefv2_service_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->service_name;

}


/**
 * iodefv2_service_set_service_name:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @service_name: pointer to a #iodefv2_service_name_t object.
 *
 * Set @service_name object as a children of @ptr.
 * if @ptr already contain an @service_name object, then it is destroyed,
 * and updated to point to the provided @service_name object.
 */

void iodefv2_service_set_service_name(iodefv2_service_t *ptr, iodefv2_service_name_t *service_name)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->service_name )
                iodefv2_service_name_destroy(ptr->service_name);

        ptr->service_name = service_name;
}
/**
 * iodefv2_service_new_service_name:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @ret: pointer to an address where to store the created #iodefv2_service_name_t object.
 *
 * Create a new service_name object, children of #iodefv2_service_t.
 * If @ptr already contain a #iodefv2_service_name_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_service_new_service_name(iodefv2_service_t *ptr, iodefv2_service_name_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->service_name ) {
                retval = iodefv2_service_name_new(&ptr->service_name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->service_name;
        return 0;
}




/**
 * iodefv2_service_get_application_header:
 * @ptr: pointer to a #iodefv2_service_t object.
 *
 * Get application_header children of the #iodefv2_service_t object.
 *
 * Returns: a pointer to a iodefv2_application_header_t object, or NULL if the children object is not set.
 */
iodefv2_application_header_t *iodefv2_service_get_application_header(iodefv2_service_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->application_header;

}


/**
 * iodefv2_service_set_application_header:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @application_header: pointer to a #iodefv2_application_header_t object.
 *
 * Set @application_header object as a children of @ptr.
 * if @ptr already contain an @application_header object, then it is destroyed,
 * and updated to point to the provided @application_header object.
 */

void iodefv2_service_set_application_header(iodefv2_service_t *ptr, iodefv2_application_header_t *application_header)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->application_header )
                iodefv2_application_header_destroy(ptr->application_header);

        ptr->application_header = application_header;
}
/**
 * iodefv2_service_new_application_header:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @ret: pointer to an address where to store the created #iodefv2_application_header_t object.
 *
 * Create a new application_header object, children of #iodefv2_service_t.
 * If @ptr already contain a #iodefv2_application_header_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_service_new_application_header(iodefv2_service_t *ptr, iodefv2_application_header_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->application_header ) {
                retval = iodefv2_application_header_new(&ptr->application_header);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->application_header;
        return 0;
}




/**
 * iodefv2_service_get_email_data:
 * @ptr: pointer to a #iodefv2_service_t object.
 *
 * Get email_data children of the #iodefv2_service_t object.
 *
 * Returns: a pointer to a iodefv2_email_data_t object, or NULL if the children object is not set.
 */
iodefv2_email_data_t *iodefv2_service_get_email_data(iodefv2_service_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->email_data;

}


/**
 * iodefv2_service_set_email_data:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @email_data: pointer to a #iodefv2_email_data_t object.
 *
 * Set @email_data object as a children of @ptr.
 * if @ptr already contain an @email_data object, then it is destroyed,
 * and updated to point to the provided @email_data object.
 */

void iodefv2_service_set_email_data(iodefv2_service_t *ptr, iodefv2_email_data_t *email_data)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->email_data )
                iodefv2_email_data_destroy(ptr->email_data);

        ptr->email_data = email_data;
}
/**
 * iodefv2_service_new_email_data:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @ret: pointer to an address where to store the created #iodefv2_email_data_t object.
 *
 * Create a new email_data object, children of #iodefv2_service_t.
 * If @ptr already contain a #iodefv2_email_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_service_new_email_data(iodefv2_service_t *ptr, iodefv2_email_data_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->email_data ) {
                retval = iodefv2_email_data_new(&ptr->email_data);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->email_data;
        return 0;
}




/**
 * iodefv2_service_get_proto_type:
 * @ptr: pointer to a #iodefv2_service_t object.
 *
 * Get proto_type children of the #iodefv2_service_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *iodefv2_service_get_proto_type(iodefv2_service_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->proto_type_is_set ? &ptr->proto_type : NULL;


}


/**
 * iodefv2_service_set_proto_type:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @proto_type: pointer to a #uint32_t object.
 *
 * Set @proto_type object as a children of @ptr.
 * if @ptr already contain an @proto_type object, then it is destroyed,
 * and updated to point to the provided @proto_type object.
 */
void iodefv2_service_set_proto_type(iodefv2_service_t *ptr, uint32_t proto_type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->proto_type = proto_type;
        ptr->proto_type_is_set = 1;
}

void iodefv2_service_unset_proto_type(iodefv2_service_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->proto_type_is_set = 0;
}
/**
 * iodefv2_service_new_proto_type:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new proto_type object, children of #iodefv2_service_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_service_new_proto_type(iodefv2_service_t *ptr, uint32_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->proto_type_is_set = 1;



        *ret = &ptr->proto_type;
        return 0;
}




/**
 * iodefv2_service_get_port:
 * @ptr: pointer to a #iodefv2_service_t object.
 *
 * Get port children of the #iodefv2_service_t object.
 *
 * Returns: a pointer to a uint32_t object, or NULL if the children object is not set.
 */
uint32_t *iodefv2_service_get_port(iodefv2_service_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->port_is_set ? &ptr->port : NULL;


}


/**
 * iodefv2_service_set_port:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @port: pointer to a #uint32_t object.
 *
 * Set @port object as a children of @ptr.
 * if @ptr already contain an @port object, then it is destroyed,
 * and updated to point to the provided @port object.
 */
void iodefv2_service_set_port(iodefv2_service_t *ptr, uint32_t port)
{
        libiodefv2_return_if_fail(ptr);
        ptr->port = port;
        ptr->port_is_set = 1;
}

void iodefv2_service_unset_port(iodefv2_service_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->port_is_set = 0;
}
/**
 * iodefv2_service_new_port:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @ret: pointer to an address where to store the created #uint32_t object.
 *
 * Create a new port object, children of #iodefv2_service_t.
 * If @ptr already contain a #uint32_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_service_new_port(iodefv2_service_t *ptr, uint32_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->port_is_set = 1;



        *ret = &ptr->port;
        return 0;
}





/**
 * iodefv2_service_get_next_software:
 * @service: pointer to a #iodefv2_service_t object.
 * @software_cur: pointer to a #iodefv2_software_t object.
 *
 * Get the next #iodefv2_software_t object listed in @ptr.
 * When iterating over the iodefv2_software_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_software_t object.
 *
 * Returns: the next #iodefv2_software_t in the list.
 */
iodefv2_software_t *iodefv2_service_get_next_software(iodefv2_service_t *service, iodefv2_software_t *software_cur)
{
        libiodefv2_list_t *tmp = (software_cur) ? &((libiodefv2_linked_object_t *) software_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(service, NULL);

        libiodefv2_list_for_each_continue(&service->software_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_service_set_software:
 * @ptr: pointer to a #iodefv2_service_t object.
 * @object: pointer to a #iodefv2_software_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_software_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_service_set_software(iodefv2_service_t *ptr, iodefv2_software_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->software_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_service_new_software:
 *  @ptr: pointer to a #iodefv2_service_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_software_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_software_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_software_t object. The created #iodefv2_software_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_service_new_software(iodefv2_service_t *ptr, iodefv2_software_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_software_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->software_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_service_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_service_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_service_copy(const iodefv2_service_t *src, iodefv2_service_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;


        dst->ip_protocol = src->ip_protocol;



        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }



        dst->proto_code_is_set = src->proto_code_is_set;
        dst->proto_code = src->proto_code;



        if ( dst->portlist ) {
                libiodefv2_string_destroy(dst->portlist);
                dst->portlist = NULL;
        }

        if ( src->portlist ) {
                ret = libiodefv2_string_clone(src->portlist, &dst->portlist);
                if ( ret < 0 )
                        return ret;
        }



        dst->proto_field_is_set = src->proto_field_is_set;
        dst->proto_field = src->proto_field;




        if ( dst->service_name ) {
                iodefv2_service_name_destroy(dst->service_name);
                dst->service_name = NULL;
        }

        if ( src->service_name ) {
                ret = iodefv2_service_name_clone(src->service_name, &dst->service_name);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->application_header ) {
                iodefv2_application_header_destroy(dst->application_header);
                dst->application_header = NULL;
        }

        if ( src->application_header ) {
                ret = iodefv2_application_header_clone(src->application_header, &dst->application_header);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->email_data ) {
                iodefv2_email_data_destroy(dst->email_data);
                dst->email_data = NULL;
        }

        if ( src->email_data ) {
                ret = iodefv2_email_data_clone(src->email_data, &dst->email_data);
                if ( ret < 0 )
                        return ret;
        }



        dst->proto_type_is_set = src->proto_type_is_set;
        dst->proto_type = src->proto_type;


        dst->port_is_set = src->port_is_set;
        dst->port = src->port;



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_software_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->software_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_software_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->software_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_software_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->software_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_service_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_service_clone(iodefv2_service_t *src, iodefv2_service_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_service_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_service_copy(src, *dst);
}


/**
 * iodefv2_service_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_service_compare(const iodefv2_service_t *obj1, const iodefv2_service_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;

        if ( obj1->ip_protocol != obj2->ip_protocol )
                return -1;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;

        if ( obj1->proto_code_is_set != obj2->proto_code_is_set )
                return -1;

        if ( obj1->proto_code_is_set && obj1->proto_code != obj2->proto_code )
                return -1;


        ret = libiodefv2_string_compare(obj1->portlist, obj2->portlist);
        if ( ret != 0 )
                return ret;

        if ( obj1->proto_field_is_set != obj2->proto_field_is_set )
                return -1;

        if ( obj1->proto_field_is_set && obj1->proto_field != obj2->proto_field )
                return -1;



        ret = iodefv2_service_name_compare(obj1->service_name, obj2->service_name);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_application_header_compare(obj1->application_header, obj2->application_header);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_email_data_compare(obj1->email_data, obj2->email_data);
        if ( ret != 0 )
                return ret;

        if ( obj1->proto_type_is_set != obj2->proto_type_is_set )
                return -1;

        if ( obj1->proto_type_is_set && obj1->proto_type != obj2->proto_type )
                return -1;


        if ( obj1->port_is_set != obj2->port_is_set )
                return -1;

        if ( obj1->port_is_set && obj1->port != obj2->port )
                return -1;



        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_software_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->software_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->software_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_software_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_file_data_new:
 * @ret: Pointer where to store the created #iodefv2_file_data_t object.
 *
 * Create a new #iodefv2_file_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_file_data_new(iodefv2_file_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_FILE_DATA;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->file_list);







            return 0;
}


/**
 * iodefv2_file_data_ref:
 * @file_data: pointer to a #iodefv2_file_data_t object.
 *
 * Increase @file_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @file_data.
 */
iodefv2_file_data_t *iodefv2_file_data_ref(iodefv2_file_data_t *file_data)
{
        libiodefv2_return_val_if_fail(file_data, NULL);
        file_data->refcount++;

        return file_data;
}



int _iodefv2_file_data_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_file_data_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_FILE_DATA_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);


            case 3:
                *childptr = &ptr->file_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_file_data_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_file_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_file_data_new_restriction(ptr, (iodefv2_file_data_restriction_t **) ret);

                case 1:
                    return iodefv2_file_data_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_file_data_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 3: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_file_data_new_file(ptr, (iodefv2_file_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->file_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->file_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_file_data_new_file(ptr, (iodefv2_file_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_file_data_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_file_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;

    
                case 3: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->file_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_file_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->file_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_file_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_file_data_destroy_internal(iodefv2_file_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }



        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_file_t *entry;

                libiodefv2_list_for_each_safe(&ptr->file_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_file_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_file_data_destroy:
 * @ptr: pointer to a #iodefv2_file_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_file_data_destroy(iodefv2_file_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_file_data_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_file_data_get_restriction:
 * @ptr: pointer to a #iodefv2_file_data_t object.
 *
 * Get restriction children of the #iodefv2_file_data_t object.
 *
 * Returns: a pointer to a iodefv2_file_data_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_file_data_restriction_t *iodefv2_file_data_get_restriction(iodefv2_file_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_file_data_set_restriction:
 * @ptr: pointer to a #iodefv2_file_data_t object.
 * @restriction: pointer to a #iodefv2_file_data_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_file_data_set_restriction(iodefv2_file_data_t *ptr, iodefv2_file_data_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_file_data_unset_restriction(iodefv2_file_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_file_data_new_restriction:
 * @ptr: pointer to a #iodefv2_file_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_file_data_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_file_data_t.
 * If @ptr already contain a #iodefv2_file_data_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_file_data_new_restriction(iodefv2_file_data_t *ptr, iodefv2_file_data_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_file_data_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_file_data_t object.
 *
 * Get ext_restriction children of the #iodefv2_file_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_file_data_get_ext_restriction(iodefv2_file_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_file_data_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_file_data_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_file_data_set_ext_restriction(iodefv2_file_data_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_file_data_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_file_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_file_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_file_data_new_ext_restriction(iodefv2_file_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_file_data_get_observable_id:
 * @ptr: pointer to a #iodefv2_file_data_t object.
 *
 * Get observable_id children of the #iodefv2_file_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_file_data_get_observable_id(iodefv2_file_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_file_data_set_observable_id:
 * @ptr: pointer to a #iodefv2_file_data_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_file_data_set_observable_id(iodefv2_file_data_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_file_data_new_observable_id:
 * @ptr: pointer to a #iodefv2_file_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_file_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_file_data_new_observable_id(iodefv2_file_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}





/**
 * iodefv2_file_data_get_next_file:
 * @file_data: pointer to a #iodefv2_file_data_t object.
 * @file_cur: pointer to a #iodefv2_file_t object.
 *
 * Get the next #iodefv2_file_t object listed in @ptr.
 * When iterating over the iodefv2_file_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_file_t object.
 *
 * Returns: the next #iodefv2_file_t in the list.
 */
iodefv2_file_t *iodefv2_file_data_get_next_file(iodefv2_file_data_t *file_data, iodefv2_file_t *file_cur)
{
        libiodefv2_list_t *tmp = (file_cur) ? &((libiodefv2_linked_object_t *) file_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(file_data, NULL);

        libiodefv2_list_for_each_continue(&file_data->file_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_file_data_set_file:
 * @ptr: pointer to a #iodefv2_file_data_t object.
 * @object: pointer to a #iodefv2_file_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_file_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_file_data_set_file(iodefv2_file_data_t *ptr, iodefv2_file_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->file_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_file_data_new_file:
 *  @ptr: pointer to a #iodefv2_file_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_file_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_file_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_file_t object. The created #iodefv2_file_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_file_data_new_file(iodefv2_file_data_t *ptr, iodefv2_file_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_file_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->file_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_file_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_file_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_file_data_copy(const iodefv2_file_data_t *src, iodefv2_file_data_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_file_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->file_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_file_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->file_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_file_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->file_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_file_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_file_data_clone(iodefv2_file_data_t *src, iodefv2_file_data_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_file_data_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_file_data_copy(src, *dst);
}


/**
 * iodefv2_file_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_file_data_compare(const iodefv2_file_data_t *obj1, const iodefv2_file_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_file_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->file_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->file_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_file_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_system_new:
 * @ret: Pointer where to store the created #iodefv2_system_t object.
 *
 * Create a new #iodefv2_system_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_system_new(iodefv2_system_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_SYSTEM;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);


        libiodefv2_list_init(&(*ret)->service_list);


        libiodefv2_list_init(&(*ret)->counter_list);


        libiodefv2_list_init(&(*ret)->node_role_list);






























            return 0;
}


/**
 * iodefv2_system_ref:
 * @system: pointer to a #iodefv2_system_t object.
 *
 * Increase @system reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @system.
 */
iodefv2_system_t *iodefv2_system_ref(iodefv2_system_t *system)
{
        libiodefv2_return_val_if_fail(system, NULL);
        system->refcount++;

        return system;
}



int _iodefv2_system_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_system_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_SYSTEM_CATEGORY , ptr->category);

            case 1:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_SYSTEM_RESTRICTION , ptr->restriction);


            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);



            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_ownership, TRUE);



            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_category, TRUE);


            case 5:

                    if ( ! ptr->spoofed_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_SYSTEM_SPOOFED , ptr->spoofed);

            case 6:

                    if ( ! ptr->virtual_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_SYSTEM_VIRTUAL , ptr->virtual);


            case 7:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);


            case 8:

                    if ( ! ptr->ownership_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_SYSTEM_OWNERSHIP , ptr->ownership);


            case 9:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->interface, TRUE);



            case 10:
                *childptr = ptr->node;
                return 0;

            case 11:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 12:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            case 13:
                *childptr = &ptr->service_list;
                return 0;


            case 14:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->asset_id, TRUE);


            case 15:
                *childptr = &ptr->counter_list;
                return 0;

            case 16:
                *childptr = &ptr->node_role_list;
                return 0;


            case 17:
                *childptr = ptr->software;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_system_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_system_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_system_new_category(ptr, (iodefv2_system_category_t **) ret);

                case 1:
                    return iodefv2_system_new_restriction(ptr, (iodefv2_system_restriction_t **) ret);

                case 2:
                    return iodefv2_system_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_system_new_ext_ownership(ptr, (libiodefv2_string_t **) ret);

                case 4:
                    return iodefv2_system_new_ext_category(ptr, (libiodefv2_string_t **) ret);

                case 5:
                    return iodefv2_system_new_spoofed(ptr, (iodefv2_system_spoofed_t **) ret);

                case 6:
                    return iodefv2_system_new_virtual(ptr, (iodefv2_system_virtual_t **) ret);

                case 7:
                    return iodefv2_system_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 8:
                    return iodefv2_system_new_ownership(ptr, (iodefv2_system_ownership_t **) ret);

                case 9:
                    return iodefv2_system_new_interface(ptr, (libiodefv2_string_t **) ret);

                case 10:
                    return iodefv2_system_new_node(ptr, (iodefv2_node_t **) ret);

                case 11: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_system_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_system_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 12:
                    return iodefv2_system_new_description(ptr, (libiodefv2_string_t **) ret);

                case 13: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_system_new_service(ptr, (iodefv2_service_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->service_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->service_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_system_new_service(ptr, (iodefv2_service_t **) ret, n);
                }

                case 14:
                    return iodefv2_system_new_asset_id(ptr, (libiodefv2_string_t **) ret);

                case 15: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_system_new_counter(ptr, (iodefv2_counter_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->counter_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->counter_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_system_new_counter(ptr, (iodefv2_counter_t **) ret, n);
                }

                case 16: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_system_new_node_role(ptr, (iodefv2_node_role_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->node_role_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->node_role_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_system_new_node_role(ptr, (iodefv2_node_role_t **) ret, n);
                }

                case 17:
                    return iodefv2_system_new_software(ptr, (iodefv2_software_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_system_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_system_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->category = 0;
                    return 0;

                case 1:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 2:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->ext_ownership ) {
                                libiodefv2_string_destroy(ptr->ext_ownership);
                                ptr->ext_ownership = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->ext_category ) {
                                libiodefv2_string_destroy(ptr->ext_category);
                                ptr->ext_category = NULL;
                        }

                        return 0;

                case 5:
                        ptr->spoofed_is_set = 0;
                        return 0;

                case 6:
                        ptr->virtual_is_set = 0;
                        return 0;




                case 7:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;

                case 8:
                        ptr->ownership_is_set = 0;
                        return 0;




                case 9:
                        if ( ptr->interface ) {
                                libiodefv2_string_destroy(ptr->interface);
                                ptr->interface = NULL;
                        }

                        return 0;




                case 10:
                        if ( ptr->node ) {
                                iodefv2_node_destroy(ptr->node);
                                ptr->node = NULL;
                        }

                        return 0;

    
                case 11: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 12:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

    
                case 13: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->service_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_service_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->service_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_service_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 14:
                        if ( ptr->asset_id ) {
                                libiodefv2_string_destroy(ptr->asset_id);
                                ptr->asset_id = NULL;
                        }

                        return 0;

    
                case 15: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->counter_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_counter_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->counter_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_counter_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 16: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->node_role_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_node_role_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->node_role_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_node_role_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 17:
                        if ( ptr->software ) {
                                iodefv2_software_destroy(ptr->software);
                                ptr->software = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_system_destroy_internal(iodefv2_system_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);





        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }



        if ( ptr->ext_ownership ) {
                libiodefv2_string_destroy(ptr->ext_ownership);
                ptr->ext_ownership = NULL;
        }



        if ( ptr->ext_category ) {
                libiodefv2_string_destroy(ptr->ext_category);
                ptr->ext_category = NULL;
        }







        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }





        if ( ptr->interface ) {
                libiodefv2_string_destroy(ptr->interface);
                ptr->interface = NULL;
        }




        if ( ptr->node ) {
                iodefv2_node_destroy(ptr->node);
                ptr->node = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }

        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_service_t *entry;

                libiodefv2_list_for_each_safe(&ptr->service_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_service_destroy(entry);
                }
        }

        if ( ptr->asset_id ) {
                libiodefv2_string_destroy(ptr->asset_id);
                ptr->asset_id = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_counter_t *entry;

                libiodefv2_list_for_each_safe(&ptr->counter_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_counter_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_node_role_t *entry;

                libiodefv2_list_for_each_safe(&ptr->node_role_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_node_role_destroy(entry);
                }
        }


        if ( ptr->software ) {
                iodefv2_software_destroy(ptr->software);
                ptr->software = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_system_destroy:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_system_destroy(iodefv2_system_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_system_destroy_internal(ptr);
        free(ptr);
}




/**
 * iodefv2_system_get_category:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Get category children of the #iodefv2_system_t object.
 *
 * Returns: a pointer to a iodefv2_system_category_t object, or NULL if the children object is not set.
 */
iodefv2_system_category_t iodefv2_system_get_category(iodefv2_system_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->category;

}


/**
 * iodefv2_system_set_category:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @category: pointer to a #iodefv2_system_category_t object.
 *
 * Set @category object as a children of @ptr.
 * if @ptr already contain an @category object, then it is destroyed,
 * and updated to point to the provided @category object.
 */
void iodefv2_system_set_category(iodefv2_system_t *ptr, iodefv2_system_category_t category)
{
        libiodefv2_return_if_fail(ptr);
        ptr->category = category;
}
/**
 * iodefv2_system_new_category:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ret: pointer to an address where to store the created #iodefv2_system_category_t object.
 *
 * Create a new category object, children of #iodefv2_system_t.
 * If @ptr already contain a #iodefv2_system_category_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_category(iodefv2_system_t *ptr, iodefv2_system_category_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->category;
        return 0;
}




/**
 * iodefv2_system_get_restriction:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Get restriction children of the #iodefv2_system_t object.
 *
 * Returns: a pointer to a iodefv2_system_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_system_restriction_t *iodefv2_system_get_restriction(iodefv2_system_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_system_set_restriction:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @restriction: pointer to a #iodefv2_system_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_system_set_restriction(iodefv2_system_t *ptr, iodefv2_system_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_system_unset_restriction(iodefv2_system_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_system_new_restriction:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ret: pointer to an address where to store the created #iodefv2_system_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_system_t.
 * If @ptr already contain a #iodefv2_system_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_restriction(iodefv2_system_t *ptr, iodefv2_system_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_system_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Get ext_restriction children of the #iodefv2_system_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_system_get_ext_restriction(iodefv2_system_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_system_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_system_set_ext_restriction(iodefv2_system_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_system_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_system_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_ext_restriction(iodefv2_system_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_system_get_ext_ownership:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Get ext_ownership children of the #iodefv2_system_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_system_get_ext_ownership(iodefv2_system_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_ownership;

}


/**
 * iodefv2_system_set_ext_ownership:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ext_ownership: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_ownership object as a children of @ptr.
 * if @ptr already contain an @ext_ownership object, then it is destroyed,
 * and updated to point to the provided @ext_ownership object.
 */

void iodefv2_system_set_ext_ownership(iodefv2_system_t *ptr, libiodefv2_string_t *ext_ownership)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_ownership )
                libiodefv2_string_destroy(ptr->ext_ownership);

        ptr->ext_ownership = ext_ownership;
}
/**
 * iodefv2_system_new_ext_ownership:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_ownership object, children of #iodefv2_system_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_ext_ownership(iodefv2_system_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_ownership ) {
                retval = libiodefv2_string_new(&ptr->ext_ownership);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_ownership;
        return 0;
}




/**
 * iodefv2_system_get_ext_category:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Get ext_category children of the #iodefv2_system_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_system_get_ext_category(iodefv2_system_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_category;

}


/**
 * iodefv2_system_set_ext_category:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ext_category: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_category object as a children of @ptr.
 * if @ptr already contain an @ext_category object, then it is destroyed,
 * and updated to point to the provided @ext_category object.
 */

void iodefv2_system_set_ext_category(iodefv2_system_t *ptr, libiodefv2_string_t *ext_category)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_category )
                libiodefv2_string_destroy(ptr->ext_category);

        ptr->ext_category = ext_category;
}
/**
 * iodefv2_system_new_ext_category:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_category object, children of #iodefv2_system_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_ext_category(iodefv2_system_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_category ) {
                retval = libiodefv2_string_new(&ptr->ext_category);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_category;
        return 0;
}




/**
 * iodefv2_system_get_spoofed:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Get spoofed children of the #iodefv2_system_t object.
 *
 * Returns: a pointer to a iodefv2_system_spoofed_t object, or NULL if the children object is not set.
 */
iodefv2_system_spoofed_t *iodefv2_system_get_spoofed(iodefv2_system_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->spoofed_is_set ? &ptr->spoofed : NULL;


}


/**
 * iodefv2_system_set_spoofed:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @spoofed: pointer to a #iodefv2_system_spoofed_t object.
 *
 * Set @spoofed object as a children of @ptr.
 * if @ptr already contain an @spoofed object, then it is destroyed,
 * and updated to point to the provided @spoofed object.
 */
void iodefv2_system_set_spoofed(iodefv2_system_t *ptr, iodefv2_system_spoofed_t spoofed)
{
        libiodefv2_return_if_fail(ptr);
        ptr->spoofed = spoofed;
        ptr->spoofed_is_set = 1;
}

void iodefv2_system_unset_spoofed(iodefv2_system_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->spoofed_is_set = 0;
}
/**
 * iodefv2_system_new_spoofed:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ret: pointer to an address where to store the created #iodefv2_system_spoofed_t object.
 *
 * Create a new spoofed object, children of #iodefv2_system_t.
 * If @ptr already contain a #iodefv2_system_spoofed_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_spoofed(iodefv2_system_t *ptr, iodefv2_system_spoofed_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->spoofed_is_set = 1;



        *ret = &ptr->spoofed;
        return 0;
}




/**
 * iodefv2_system_get_virtual:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Get virtual children of the #iodefv2_system_t object.
 *
 * Returns: a pointer to a iodefv2_system_virtual_t object, or NULL if the children object is not set.
 */
iodefv2_system_virtual_t *iodefv2_system_get_virtual(iodefv2_system_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->virtual_is_set ? &ptr->virtual : NULL;


}


/**
 * iodefv2_system_set_virtual:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @virtual_sys: pointer to a #iodefv2_system_virtual_t object.
 *
 * Set @virtual_sys object as a children of @ptr.
 * if @ptr already contain an @virtual_sys object, then it is destroyed,
 * and updated to point to the provided @virtual_sys object.
 */
void iodefv2_system_set_virtual(iodefv2_system_t *ptr, iodefv2_system_virtual_t virtual_sys)
{
        libiodefv2_return_if_fail(ptr);
        ptr->virtual = virtual_sys;
        ptr->virtual_is_set = 1;
}

void iodefv2_system_unset_virtual(iodefv2_system_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->virtual_is_set = 0;
}
/**
 * iodefv2_system_new_virtual:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ret: pointer to an address where to store the created #iodefv2_system_virtual_t object.
 *
 * Create a new virtual object, children of #iodefv2_system_t.
 * If @ptr already contain a #iodefv2_system_virtual_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_virtual(iodefv2_system_t *ptr, iodefv2_system_virtual_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->virtual_is_set = 1;



        *ret = &ptr->virtual;
        return 0;
}




/**
 * iodefv2_system_get_observable_id:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Get observable_id children of the #iodefv2_system_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_system_get_observable_id(iodefv2_system_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_system_set_observable_id:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_system_set_observable_id(iodefv2_system_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_system_new_observable_id:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_system_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_observable_id(iodefv2_system_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}




/**
 * iodefv2_system_get_ownership:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Get ownership children of the #iodefv2_system_t object.
 *
 * Returns: a pointer to a iodefv2_system_ownership_t object, or NULL if the children object is not set.
 */
iodefv2_system_ownership_t *iodefv2_system_get_ownership(iodefv2_system_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ownership_is_set ? &ptr->ownership : NULL;


}


/**
 * iodefv2_system_set_ownership:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ownership: pointer to a #iodefv2_system_ownership_t object.
 *
 * Set @ownership object as a children of @ptr.
 * if @ptr already contain an @ownership object, then it is destroyed,
 * and updated to point to the provided @ownership object.
 */
void iodefv2_system_set_ownership(iodefv2_system_t *ptr, iodefv2_system_ownership_t ownership)
{
        libiodefv2_return_if_fail(ptr);
        ptr->ownership = ownership;
        ptr->ownership_is_set = 1;
}

void iodefv2_system_unset_ownership(iodefv2_system_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->ownership_is_set = 0;
}
/**
 * iodefv2_system_new_ownership:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ret: pointer to an address where to store the created #iodefv2_system_ownership_t object.
 *
 * Create a new ownership object, children of #iodefv2_system_t.
 * If @ptr already contain a #iodefv2_system_ownership_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_ownership(iodefv2_system_t *ptr, iodefv2_system_ownership_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->ownership_is_set = 1;



        *ret = &ptr->ownership;
        return 0;
}




/**
 * iodefv2_system_get_interface:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Get interface children of the #iodefv2_system_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_system_get_interface(iodefv2_system_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->interface;

}


/**
 * iodefv2_system_set_interface:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @interface: pointer to a #libiodefv2_string_t object.
 *
 * Set @interface object as a children of @ptr.
 * if @ptr already contain an @interface object, then it is destroyed,
 * and updated to point to the provided @interface object.
 */

void iodefv2_system_set_interface(iodefv2_system_t *ptr, libiodefv2_string_t *interface)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->interface )
                libiodefv2_string_destroy(ptr->interface);

        ptr->interface = interface;
}
/**
 * iodefv2_system_new_interface:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new interface object, children of #iodefv2_system_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_interface(iodefv2_system_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->interface ) {
                retval = libiodefv2_string_new(&ptr->interface);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->interface;
        return 0;
}




/**
 * iodefv2_system_get_node:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Get node children of the #iodefv2_system_t object.
 *
 * Returns: a pointer to a iodefv2_node_t object, or NULL if the children object is not set.
 */
iodefv2_node_t *iodefv2_system_get_node(iodefv2_system_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->node;

}


/**
 * iodefv2_system_set_node:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @node: pointer to a #iodefv2_node_t object.
 *
 * Set @node object as a children of @ptr.
 * if @ptr already contain an @node object, then it is destroyed,
 * and updated to point to the provided @node object.
 */

void iodefv2_system_set_node(iodefv2_system_t *ptr, iodefv2_node_t *node)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->node )
                iodefv2_node_destroy(ptr->node);

        ptr->node = node;
}
/**
 * iodefv2_system_new_node:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ret: pointer to an address where to store the created #iodefv2_node_t object.
 *
 * Create a new node object, children of #iodefv2_system_t.
 * If @ptr already contain a #iodefv2_node_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_node(iodefv2_system_t *ptr, iodefv2_node_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->node ) {
                retval = iodefv2_node_new(&ptr->node);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->node;
        return 0;
}





/**
 * iodefv2_system_get_next_additional_data:
 * @system: pointer to a #iodefv2_system_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_system_get_next_additional_data(iodefv2_system_t *system, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(system, NULL);

        libiodefv2_list_for_each_continue(&system->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_system_set_additional_data:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_system_set_additional_data(iodefv2_system_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_system_new_additional_data:
 *  @ptr: pointer to a #iodefv2_system_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_additional_data(iodefv2_system_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_system_get_description:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Get description children of the #iodefv2_system_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_system_get_description(iodefv2_system_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_system_set_description:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_system_set_description(iodefv2_system_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_system_new_description:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_system_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_description(iodefv2_system_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}





/**
 * iodefv2_system_get_next_service:
 * @system: pointer to a #iodefv2_system_t object.
 * @service_cur: pointer to a #iodefv2_service_t object.
 *
 * Get the next #iodefv2_service_t object listed in @ptr.
 * When iterating over the iodefv2_service_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_service_t object.
 *
 * Returns: the next #iodefv2_service_t in the list.
 */
iodefv2_service_t *iodefv2_system_get_next_service(iodefv2_system_t *system, iodefv2_service_t *service_cur)
{
        libiodefv2_list_t *tmp = (service_cur) ? &((libiodefv2_linked_object_t *) service_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(system, NULL);

        libiodefv2_list_for_each_continue(&system->service_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_system_set_service:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @object: pointer to a #iodefv2_service_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_service_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_system_set_service(iodefv2_system_t *ptr, iodefv2_service_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->service_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_system_new_service:
 *  @ptr: pointer to a #iodefv2_system_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_service_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_service_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_service_t object. The created #iodefv2_service_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_service(iodefv2_system_t *ptr, iodefv2_service_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_service_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->service_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_system_get_asset_id:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Get asset_id children of the #iodefv2_system_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_system_get_asset_id(iodefv2_system_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->asset_id;

}


/**
 * iodefv2_system_set_asset_id:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @asset_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @asset_id object as a children of @ptr.
 * if @ptr already contain an @asset_id object, then it is destroyed,
 * and updated to point to the provided @asset_id object.
 */

void iodefv2_system_set_asset_id(iodefv2_system_t *ptr, libiodefv2_string_t *asset_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->asset_id )
                libiodefv2_string_destroy(ptr->asset_id);

        ptr->asset_id = asset_id;
}
/**
 * iodefv2_system_new_asset_id:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new asset_id object, children of #iodefv2_system_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_asset_id(iodefv2_system_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->asset_id ) {
                retval = libiodefv2_string_new(&ptr->asset_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->asset_id;
        return 0;
}





/**
 * iodefv2_system_get_next_counter:
 * @system: pointer to a #iodefv2_system_t object.
 * @counter_cur: pointer to a #iodefv2_counter_t object.
 *
 * Get the next #iodefv2_counter_t object listed in @ptr.
 * When iterating over the iodefv2_counter_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_counter_t object.
 *
 * Returns: the next #iodefv2_counter_t in the list.
 */
iodefv2_counter_t *iodefv2_system_get_next_counter(iodefv2_system_t *system, iodefv2_counter_t *counter_cur)
{
        libiodefv2_list_t *tmp = (counter_cur) ? &((libiodefv2_linked_object_t *) counter_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(system, NULL);

        libiodefv2_list_for_each_continue(&system->counter_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_system_set_counter:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @object: pointer to a #iodefv2_counter_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_counter_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_system_set_counter(iodefv2_system_t *ptr, iodefv2_counter_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->counter_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_system_new_counter:
 *  @ptr: pointer to a #iodefv2_system_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_counter_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_counter_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_counter_t object. The created #iodefv2_counter_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_counter(iodefv2_system_t *ptr, iodefv2_counter_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_counter_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->counter_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_system_get_next_node_role:
 * @system: pointer to a #iodefv2_system_t object.
 * @node_role_cur: pointer to a #iodefv2_node_role_t object.
 *
 * Get the next #iodefv2_node_role_t object listed in @ptr.
 * When iterating over the iodefv2_node_role_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_node_role_t object.
 *
 * Returns: the next #iodefv2_node_role_t in the list.
 */
iodefv2_node_role_t *iodefv2_system_get_next_node_role(iodefv2_system_t *system, iodefv2_node_role_t *node_role_cur)
{
        libiodefv2_list_t *tmp = (node_role_cur) ? &((libiodefv2_linked_object_t *) node_role_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(system, NULL);

        libiodefv2_list_for_each_continue(&system->node_role_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_system_set_node_role:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @object: pointer to a #iodefv2_node_role_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_node_role_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_system_set_node_role(iodefv2_system_t *ptr, iodefv2_node_role_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->node_role_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_system_new_node_role:
 *  @ptr: pointer to a #iodefv2_system_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_node_role_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_node_role_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_node_role_t object. The created #iodefv2_node_role_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_node_role(iodefv2_system_t *ptr, iodefv2_node_role_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_node_role_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->node_role_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_system_get_software:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Get software children of the #iodefv2_system_t object.
 *
 * Returns: a pointer to a iodefv2_software_t object, or NULL if the children object is not set.
 */
iodefv2_software_t *iodefv2_system_get_software(iodefv2_system_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->software;

}


/**
 * iodefv2_system_set_software:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @software: pointer to a #iodefv2_software_t object.
 *
 * Set @software object as a children of @ptr.
 * if @ptr already contain an @software object, then it is destroyed,
 * and updated to point to the provided @software object.
 */

void iodefv2_system_set_software(iodefv2_system_t *ptr, iodefv2_software_t *software)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->software )
                iodefv2_software_destroy(ptr->software);

        ptr->software = software;
}
/**
 * iodefv2_system_new_software:
 * @ptr: pointer to a #iodefv2_system_t object.
 * @ret: pointer to an address where to store the created #iodefv2_software_t object.
 *
 * Create a new software object, children of #iodefv2_system_t.
 * If @ptr already contain a #iodefv2_software_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_system_new_software(iodefv2_system_t *ptr, iodefv2_software_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->software ) {
                retval = iodefv2_software_new(&ptr->software);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->software;
        return 0;
}



/**
 * iodefv2_system_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_system_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_system_copy(const iodefv2_system_t *src, iodefv2_system_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->category = src->category;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->ext_ownership ) {
                libiodefv2_string_destroy(dst->ext_ownership);
                dst->ext_ownership = NULL;
        }

        if ( src->ext_ownership ) {
                ret = libiodefv2_string_clone(src->ext_ownership, &dst->ext_ownership);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->ext_category ) {
                libiodefv2_string_destroy(dst->ext_category);
                dst->ext_category = NULL;
        }

        if ( src->ext_category ) {
                ret = libiodefv2_string_clone(src->ext_category, &dst->ext_category);
                if ( ret < 0 )
                        return ret;
        }




        dst->spoofed_is_set = src->spoofed_is_set;
        dst->spoofed = src->spoofed;



        dst->virtual_is_set = src->virtual_is_set;
        dst->virtual = src->virtual;



        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }




        dst->ownership_is_set = src->ownership_is_set;
        dst->ownership = src->ownership;



        if ( dst->interface ) {
                libiodefv2_string_destroy(dst->interface);
                dst->interface = NULL;
        }

        if ( src->interface ) {
                ret = libiodefv2_string_clone(src->interface, &dst->interface);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->node ) {
                iodefv2_node_destroy(dst->node);
                dst->node = NULL;
        }

        if ( src->node ) {
                ret = iodefv2_node_clone(src->node, &dst->node);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_service_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->service_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_service_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->service_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_service_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->service_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->asset_id ) {
                libiodefv2_string_destroy(dst->asset_id);
                dst->asset_id = NULL;
        }

        if ( src->asset_id ) {
                ret = libiodefv2_string_clone(src->asset_id, &dst->asset_id);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_counter_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->counter_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_counter_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->counter_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_counter_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->counter_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_node_role_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->node_role_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_node_role_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->node_role_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_node_role_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->node_role_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->software ) {
                iodefv2_software_destroy(dst->software);
                dst->software = NULL;
        }

        if ( src->software ) {
                ret = iodefv2_software_clone(src->software, &dst->software);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_system_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_system_clone(iodefv2_system_t *src, iodefv2_system_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_system_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_system_copy(src, *dst);
}


/**
 * iodefv2_system_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_system_compare(const iodefv2_system_t *obj1, const iodefv2_system_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->category != obj2->category )
                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->ext_ownership, obj2->ext_ownership);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->ext_category, obj2->ext_category);
        if ( ret != 0 )
                return ret;


        if ( obj1->spoofed_is_set != obj2->spoofed_is_set )
                return -1;

        if ( obj1->spoofed_is_set && obj1->spoofed != obj2->spoofed )
                return -1;



        if ( obj1->virtual_is_set != obj2->virtual_is_set )
                return -1;

        if ( obj1->virtual_is_set && obj1->virtual != obj2->virtual )
                return -1;


        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;


        if ( obj1->ownership_is_set != obj2->ownership_is_set )
                return -1;

        if ( obj1->ownership_is_set && obj1->ownership != obj2->ownership )
                return -1;


        ret = libiodefv2_string_compare(obj1->interface, obj2->interface);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_node_compare(obj1->node, obj2->node);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_service_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->service_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->service_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_service_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->asset_id, obj2->asset_id);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_counter_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->counter_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->counter_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_counter_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_node_role_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->node_role_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->node_role_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_node_role_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_software_compare(obj1->software, obj2->software);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_record_data_new:
 * @ret: Pointer where to store the created #iodefv2_record_data_t object.
 *
 * Create a new #iodefv2_record_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_record_data_new(iodefv2_record_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_RECORD_DATA;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);


        libiodefv2_list_init(&(*ret)->certificate_data_list);


        libiodefv2_list_init(&(*ret)->record_pattern_list);


        libiodefv2_list_init(&(*ret)->windows_registry_keys_modified_list);


        libiodefv2_list_init(&(*ret)->file_data_list);




















            return 0;
}


/**
 * iodefv2_record_data_ref:
 * @record_data: pointer to a #iodefv2_record_data_t object.
 *
 * Increase @record_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @record_data.
 */
iodefv2_record_data_t *iodefv2_record_data_ref(iodefv2_record_data_t *record_data)
{
        libiodefv2_return_val_if_fail(record_data, NULL);
        record_data->refcount++;

        return record_data;
}



int _iodefv2_record_data_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_record_data_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_RECORD_DATA_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);


            case 3:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);



            case 5:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->url, TRUE);


            case 6:
                *childptr = &ptr->certificate_data_list;
                return 0;

            case 7:
                *childptr = &ptr->record_pattern_list;
                return 0;


            case 8:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->date_time, TRUE);


            case 9:
                *childptr = &ptr->windows_registry_keys_modified_list;
                return 0;

            case 10:
                *childptr = &ptr->file_data_list;
                return 0;


            case 11:
                *childptr = ptr->software;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_record_data_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_record_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_record_data_new_restriction(ptr, (iodefv2_record_data_restriction_t **) ret);

                case 1:
                    return iodefv2_record_data_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_record_data_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 3: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_record_data_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_record_data_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 4:
                    return iodefv2_record_data_new_description(ptr, (libiodefv2_string_t **) ret);

                case 5:
                    return iodefv2_record_data_new_url(ptr, (libiodefv2_string_t **) ret);

                case 6: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_record_data_new_certificate_data(ptr, (iodefv2_certificate_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->certificate_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->certificate_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_record_data_new_certificate_data(ptr, (iodefv2_certificate_data_t **) ret, n);
                }

                case 7: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_record_data_new_record_pattern(ptr, (iodefv2_record_pattern_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->record_pattern_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->record_pattern_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_record_data_new_record_pattern(ptr, (iodefv2_record_pattern_t **) ret, n);
                }

                case 8:
                    return iodefv2_record_data_new_date_time(ptr, (iodefv2_time_t **) ret);

                case 9: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_record_data_new_windows_registry_keys_modified(ptr, (iodefv2_windows_registry_keys_modified_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->windows_registry_keys_modified_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->windows_registry_keys_modified_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_record_data_new_windows_registry_keys_modified(ptr, (iodefv2_windows_registry_keys_modified_t **) ret, n);
                }

                case 10: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_record_data_new_file_data(ptr, (iodefv2_file_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->file_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->file_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_record_data_new_file_data(ptr, (iodefv2_file_data_t **) ret, n);
                }

                case 11:
                    return iodefv2_record_data_new_software(ptr, (iodefv2_software_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_record_data_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_record_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;

    
                case 3: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 4:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;




                case 5:
                        if ( ptr->url ) {
                                libiodefv2_string_destroy(ptr->url);
                                ptr->url = NULL;
                        }

                        return 0;

    
                case 6: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->certificate_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_certificate_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->certificate_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_certificate_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 7: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->record_pattern_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_record_pattern_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->record_pattern_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_record_pattern_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 8:
                        if ( ptr->date_time ) {
                                iodefv2_time_destroy(ptr->date_time);
                                ptr->date_time = NULL;
                        }

                        return 0;

    
                case 9: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->windows_registry_keys_modified_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_windows_registry_keys_modified_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->windows_registry_keys_modified_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_windows_registry_keys_modified_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 10: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->file_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_file_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->file_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_file_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 11:
                        if ( ptr->software ) {
                                iodefv2_software_destroy(ptr->software);
                                ptr->software = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_record_data_destroy_internal(iodefv2_record_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }



        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }

        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }



        if ( ptr->url ) {
                libiodefv2_string_destroy(ptr->url);
                ptr->url = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_certificate_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->certificate_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_certificate_data_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_record_pattern_t *entry;

                libiodefv2_list_for_each_safe(&ptr->record_pattern_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_record_pattern_destroy(entry);
                }
        }

        if ( ptr->date_time ) {
                iodefv2_time_destroy(ptr->date_time);
                ptr->date_time = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_windows_registry_keys_modified_t *entry;

                libiodefv2_list_for_each_safe(&ptr->windows_registry_keys_modified_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_windows_registry_keys_modified_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_file_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->file_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_file_data_destroy(entry);
                }
        }


        if ( ptr->software ) {
                iodefv2_software_destroy(ptr->software);
                ptr->software = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_record_data_destroy:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_record_data_destroy(iodefv2_record_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_record_data_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_record_data_get_restriction:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 *
 * Get restriction children of the #iodefv2_record_data_t object.
 *
 * Returns: a pointer to a iodefv2_record_data_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_record_data_restriction_t *iodefv2_record_data_get_restriction(iodefv2_record_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_record_data_set_restriction:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @restriction: pointer to a #iodefv2_record_data_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_record_data_set_restriction(iodefv2_record_data_t *ptr, iodefv2_record_data_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_record_data_unset_restriction(iodefv2_record_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_record_data_new_restriction:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_record_data_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_record_data_t.
 * If @ptr already contain a #iodefv2_record_data_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_data_new_restriction(iodefv2_record_data_t *ptr, iodefv2_record_data_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_record_data_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 *
 * Get ext_restriction children of the #iodefv2_record_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_record_data_get_ext_restriction(iodefv2_record_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_record_data_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_record_data_set_ext_restriction(iodefv2_record_data_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_record_data_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_record_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_data_new_ext_restriction(iodefv2_record_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_record_data_get_observable_id:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 *
 * Get observable_id children of the #iodefv2_record_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_record_data_get_observable_id(iodefv2_record_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_record_data_set_observable_id:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_record_data_set_observable_id(iodefv2_record_data_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_record_data_new_observable_id:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_record_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_data_new_observable_id(iodefv2_record_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}





/**
 * iodefv2_record_data_get_next_additional_data:
 * @record_data: pointer to a #iodefv2_record_data_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_record_data_get_next_additional_data(iodefv2_record_data_t *record_data, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(record_data, NULL);

        libiodefv2_list_for_each_continue(&record_data->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_record_data_set_additional_data:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_record_data_set_additional_data(iodefv2_record_data_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_record_data_new_additional_data:
 *  @ptr: pointer to a #iodefv2_record_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_data_new_additional_data(iodefv2_record_data_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_record_data_get_description:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 *
 * Get description children of the #iodefv2_record_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_record_data_get_description(iodefv2_record_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_record_data_set_description:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_record_data_set_description(iodefv2_record_data_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_record_data_new_description:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_record_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_data_new_description(iodefv2_record_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}




/**
 * iodefv2_record_data_get_url:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 *
 * Get url children of the #iodefv2_record_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_record_data_get_url(iodefv2_record_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->url;

}


/**
 * iodefv2_record_data_set_url:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @url: pointer to a #libiodefv2_string_t object.
 *
 * Set @url object as a children of @ptr.
 * if @ptr already contain an @url object, then it is destroyed,
 * and updated to point to the provided @url object.
 */

void iodefv2_record_data_set_url(iodefv2_record_data_t *ptr, libiodefv2_string_t *url)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->url )
                libiodefv2_string_destroy(ptr->url);

        ptr->url = url;
}
/**
 * iodefv2_record_data_new_url:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new url object, children of #iodefv2_record_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_data_new_url(iodefv2_record_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->url ) {
                retval = libiodefv2_string_new(&ptr->url);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->url;
        return 0;
}





/**
 * iodefv2_record_data_get_next_certificate_data:
 * @record_data: pointer to a #iodefv2_record_data_t object.
 * @certificate_data_cur: pointer to a #iodefv2_certificate_data_t object.
 *
 * Get the next #iodefv2_certificate_data_t object listed in @ptr.
 * When iterating over the iodefv2_certificate_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_certificate_data_t object.
 *
 * Returns: the next #iodefv2_certificate_data_t in the list.
 */
iodefv2_certificate_data_t *iodefv2_record_data_get_next_certificate_data(iodefv2_record_data_t *record_data, iodefv2_certificate_data_t *certificate_data_cur)
{
        libiodefv2_list_t *tmp = (certificate_data_cur) ? &((libiodefv2_linked_object_t *) certificate_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(record_data, NULL);

        libiodefv2_list_for_each_continue(&record_data->certificate_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_record_data_set_certificate_data:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @object: pointer to a #iodefv2_certificate_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_certificate_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_record_data_set_certificate_data(iodefv2_record_data_t *ptr, iodefv2_certificate_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->certificate_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_record_data_new_certificate_data:
 *  @ptr: pointer to a #iodefv2_record_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_certificate_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_certificate_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_certificate_data_t object. The created #iodefv2_certificate_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_data_new_certificate_data(iodefv2_record_data_t *ptr, iodefv2_certificate_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_certificate_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->certificate_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_record_data_get_next_record_pattern:
 * @record_data: pointer to a #iodefv2_record_data_t object.
 * @record_pattern_cur: pointer to a #iodefv2_record_pattern_t object.
 *
 * Get the next #iodefv2_record_pattern_t object listed in @ptr.
 * When iterating over the iodefv2_record_pattern_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_record_pattern_t object.
 *
 * Returns: the next #iodefv2_record_pattern_t in the list.
 */
iodefv2_record_pattern_t *iodefv2_record_data_get_next_record_pattern(iodefv2_record_data_t *record_data, iodefv2_record_pattern_t *record_pattern_cur)
{
        libiodefv2_list_t *tmp = (record_pattern_cur) ? &((libiodefv2_linked_object_t *) record_pattern_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(record_data, NULL);

        libiodefv2_list_for_each_continue(&record_data->record_pattern_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_record_data_set_record_pattern:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @object: pointer to a #iodefv2_record_pattern_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_record_pattern_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_record_data_set_record_pattern(iodefv2_record_data_t *ptr, iodefv2_record_pattern_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->record_pattern_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_record_data_new_record_pattern:
 *  @ptr: pointer to a #iodefv2_record_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_record_pattern_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_record_pattern_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_record_pattern_t object. The created #iodefv2_record_pattern_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_data_new_record_pattern(iodefv2_record_data_t *ptr, iodefv2_record_pattern_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_record_pattern_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->record_pattern_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_record_data_get_date_time:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 *
 * Get date_time children of the #iodefv2_record_data_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_record_data_get_date_time(iodefv2_record_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->date_time;

}


/**
 * iodefv2_record_data_set_date_time:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @date_time: pointer to a #iodefv2_time_t object.
 *
 * Set @date_time object as a children of @ptr.
 * if @ptr already contain an @date_time object, then it is destroyed,
 * and updated to point to the provided @date_time object.
 */

void iodefv2_record_data_set_date_time(iodefv2_record_data_t *ptr, iodefv2_time_t *date_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->date_time )
                iodefv2_time_destroy(ptr->date_time);

        ptr->date_time = date_time;
}
/**
 * iodefv2_record_data_new_date_time:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new date_time object, children of #iodefv2_record_data_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_data_new_date_time(iodefv2_record_data_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->date_time ) {
                retval = iodefv2_time_new(&ptr->date_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->date_time;
        return 0;
}





/**
 * iodefv2_record_data_get_next_windows_registry_keys_modified:
 * @record_data: pointer to a #iodefv2_record_data_t object.
 * @windows_registry_keys_modified_cur: pointer to a #iodefv2_windows_registry_keys_modified_t object.
 *
 * Get the next #iodefv2_windows_registry_keys_modified_t object listed in @ptr.
 * When iterating over the iodefv2_windows_registry_keys_modified_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_windows_registry_keys_modified_t object.
 *
 * Returns: the next #iodefv2_windows_registry_keys_modified_t in the list.
 */
iodefv2_windows_registry_keys_modified_t *iodefv2_record_data_get_next_windows_registry_keys_modified(iodefv2_record_data_t *record_data, iodefv2_windows_registry_keys_modified_t *windows_registry_keys_modified_cur)
{
        libiodefv2_list_t *tmp = (windows_registry_keys_modified_cur) ? &((libiodefv2_linked_object_t *) windows_registry_keys_modified_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(record_data, NULL);

        libiodefv2_list_for_each_continue(&record_data->windows_registry_keys_modified_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_record_data_set_windows_registry_keys_modified:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @object: pointer to a #iodefv2_windows_registry_keys_modified_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_windows_registry_keys_modified_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_record_data_set_windows_registry_keys_modified(iodefv2_record_data_t *ptr, iodefv2_windows_registry_keys_modified_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->windows_registry_keys_modified_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_record_data_new_windows_registry_keys_modified:
 *  @ptr: pointer to a #iodefv2_record_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_windows_registry_keys_modified_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_windows_registry_keys_modified_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_windows_registry_keys_modified_t object. The created #iodefv2_windows_registry_keys_modified_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_data_new_windows_registry_keys_modified(iodefv2_record_data_t *ptr, iodefv2_windows_registry_keys_modified_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_windows_registry_keys_modified_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->windows_registry_keys_modified_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_record_data_get_next_file_data:
 * @record_data: pointer to a #iodefv2_record_data_t object.
 * @file_data_cur: pointer to a #iodefv2_file_data_t object.
 *
 * Get the next #iodefv2_file_data_t object listed in @ptr.
 * When iterating over the iodefv2_file_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_file_data_t object.
 *
 * Returns: the next #iodefv2_file_data_t in the list.
 */
iodefv2_file_data_t *iodefv2_record_data_get_next_file_data(iodefv2_record_data_t *record_data, iodefv2_file_data_t *file_data_cur)
{
        libiodefv2_list_t *tmp = (file_data_cur) ? &((libiodefv2_linked_object_t *) file_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(record_data, NULL);

        libiodefv2_list_for_each_continue(&record_data->file_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_record_data_set_file_data:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @object: pointer to a #iodefv2_file_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_file_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_record_data_set_file_data(iodefv2_record_data_t *ptr, iodefv2_file_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->file_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_record_data_new_file_data:
 *  @ptr: pointer to a #iodefv2_record_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_file_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_file_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_file_data_t object. The created #iodefv2_file_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_data_new_file_data(iodefv2_record_data_t *ptr, iodefv2_file_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_file_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->file_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_record_data_get_software:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 *
 * Get software children of the #iodefv2_record_data_t object.
 *
 * Returns: a pointer to a iodefv2_software_t object, or NULL if the children object is not set.
 */
iodefv2_software_t *iodefv2_record_data_get_software(iodefv2_record_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->software;

}


/**
 * iodefv2_record_data_set_software:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @software: pointer to a #iodefv2_software_t object.
 *
 * Set @software object as a children of @ptr.
 * if @ptr already contain an @software object, then it is destroyed,
 * and updated to point to the provided @software object.
 */

void iodefv2_record_data_set_software(iodefv2_record_data_t *ptr, iodefv2_software_t *software)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->software )
                iodefv2_software_destroy(ptr->software);

        ptr->software = software;
}
/**
 * iodefv2_record_data_new_software:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_software_t object.
 *
 * Create a new software object, children of #iodefv2_record_data_t.
 * If @ptr already contain a #iodefv2_software_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_data_new_software(iodefv2_record_data_t *ptr, iodefv2_software_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->software ) {
                retval = iodefv2_software_new(&ptr->software);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->software;
        return 0;
}



/**
 * iodefv2_record_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_record_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_record_data_copy(const iodefv2_record_data_t *src, iodefv2_record_data_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->url ) {
                libiodefv2_string_destroy(dst->url);
                dst->url = NULL;
        }

        if ( src->url ) {
                ret = libiodefv2_string_clone(src->url, &dst->url);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_certificate_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->certificate_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_certificate_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->certificate_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_certificate_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->certificate_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_record_pattern_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->record_pattern_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_record_pattern_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->record_pattern_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_record_pattern_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->record_pattern_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->date_time ) {
                iodefv2_time_destroy(dst->date_time);
                dst->date_time = NULL;
        }

        if ( src->date_time ) {
                ret = iodefv2_time_clone(src->date_time, &dst->date_time);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_windows_registry_keys_modified_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->windows_registry_keys_modified_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_windows_registry_keys_modified_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->windows_registry_keys_modified_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_windows_registry_keys_modified_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->windows_registry_keys_modified_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_file_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->file_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_file_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->file_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_file_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->file_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->software ) {
                iodefv2_software_destroy(dst->software);
                dst->software = NULL;
        }

        if ( src->software ) {
                ret = iodefv2_software_clone(src->software, &dst->software);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_record_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_record_data_clone(iodefv2_record_data_t *src, iodefv2_record_data_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_record_data_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_record_data_copy(src, *dst);
}


/**
 * iodefv2_record_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_record_data_compare(const iodefv2_record_data_t *obj1, const iodefv2_record_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->url, obj2->url);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_certificate_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->certificate_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->certificate_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_certificate_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_record_pattern_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->record_pattern_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->record_pattern_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_record_pattern_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = iodefv2_time_compare(obj1->date_time, obj2->date_time);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_windows_registry_keys_modified_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->windows_registry_keys_modified_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->windows_registry_keys_modified_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_windows_registry_keys_modified_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_file_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->file_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->file_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_file_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_software_compare(obj1->software, obj2->software);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_record_new:
 * @ret: Pointer where to store the created #iodefv2_record_t object.
 *
 * Create a new #iodefv2_record_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_record_new(iodefv2_record_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_RECORD;


        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->record_data_list);






            return 0;
}


/**
 * iodefv2_record_ref:
 * @record: pointer to a #iodefv2_record_t object.
 *
 * Increase @record reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @record.
 */
iodefv2_record_t *iodefv2_record_ref(iodefv2_record_t *record)
{
        libiodefv2_return_val_if_fail(record, NULL);
        record->refcount++;

        return record;
}



int _iodefv2_record_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_record_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_RECORD_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);


            case 2:
                *childptr = &ptr->record_data_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_record_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_record_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_record_new_restriction(ptr, (iodefv2_record_restriction_t **) ret);

                case 1:
                    return iodefv2_record_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_record_new_record_data(ptr, (iodefv2_record_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->record_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->record_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_record_new_record_data(ptr, (iodefv2_record_data_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_record_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_record_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;

    
                case 2: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->record_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_record_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->record_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_record_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_record_destroy_internal(iodefv2_record_t *ptr)
{
        libiodefv2_return_if_fail(ptr);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_record_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->record_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_record_data_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_record_destroy:
 * @ptr: pointer to a #iodefv2_record_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_record_destroy(iodefv2_record_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_record_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_record_get_restriction:
 * @ptr: pointer to a #iodefv2_record_t object.
 *
 * Get restriction children of the #iodefv2_record_t object.
 *
 * Returns: a pointer to a iodefv2_record_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_record_restriction_t *iodefv2_record_get_restriction(iodefv2_record_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_record_set_restriction:
 * @ptr: pointer to a #iodefv2_record_t object.
 * @restriction: pointer to a #iodefv2_record_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_record_set_restriction(iodefv2_record_t *ptr, iodefv2_record_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_record_unset_restriction(iodefv2_record_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_record_new_restriction:
 * @ptr: pointer to a #iodefv2_record_t object.
 * @ret: pointer to an address where to store the created #iodefv2_record_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_record_t.
 * If @ptr already contain a #iodefv2_record_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_new_restriction(iodefv2_record_t *ptr, iodefv2_record_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_record_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_record_t object.
 *
 * Get ext_restriction children of the #iodefv2_record_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_record_get_ext_restriction(iodefv2_record_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_record_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_record_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_record_set_ext_restriction(iodefv2_record_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_record_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_record_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_record_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_new_ext_restriction(iodefv2_record_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}





/**
 * iodefv2_record_get_next_record_data:
 * @record: pointer to a #iodefv2_record_t object.
 * @record_data_cur: pointer to a #iodefv2_record_data_t object.
 *
 * Get the next #iodefv2_record_data_t object listed in @ptr.
 * When iterating over the iodefv2_record_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_record_data_t object.
 *
 * Returns: the next #iodefv2_record_data_t in the list.
 */
iodefv2_record_data_t *iodefv2_record_get_next_record_data(iodefv2_record_t *record, iodefv2_record_data_t *record_data_cur)
{
        libiodefv2_list_t *tmp = (record_data_cur) ? &((libiodefv2_linked_object_t *) record_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(record, NULL);

        libiodefv2_list_for_each_continue(&record->record_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_record_set_record_data:
 * @ptr: pointer to a #iodefv2_record_t object.
 * @object: pointer to a #iodefv2_record_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_record_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_record_set_record_data(iodefv2_record_t *ptr, iodefv2_record_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->record_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_record_new_record_data:
 *  @ptr: pointer to a #iodefv2_record_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_record_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_record_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_record_data_t object. The created #iodefv2_record_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_record_new_record_data(iodefv2_record_t *ptr, iodefv2_record_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_record_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->record_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_record_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_record_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_record_copy(const iodefv2_record_t *src, iodefv2_record_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_record_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->record_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_record_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->record_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_record_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->record_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_record_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_record_clone(iodefv2_record_t *src, iodefv2_record_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_record_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_record_copy(src, *dst);
}


/**
 * iodefv2_record_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_record_compare(const iodefv2_record_t *obj1, const iodefv2_record_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_record_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->record_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->record_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_record_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_flow_new:
 * @ret: Pointer where to store the created #iodefv2_flow_t object.
 *
 * Create a new #iodefv2_flow_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_flow_new(iodefv2_flow_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_FLOW;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->system_list);



            return 0;
}


/**
 * iodefv2_flow_ref:
 * @flow: pointer to a #iodefv2_flow_t object.
 *
 * Increase @flow reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @flow.
 */
iodefv2_flow_t *iodefv2_flow_ref(iodefv2_flow_t *flow)
{
        libiodefv2_return_val_if_fail(flow, NULL);
        flow->refcount++;

        return flow;
}



int _iodefv2_flow_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_flow_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:
                *childptr = &ptr->system_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_flow_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_flow_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_flow_new_system(ptr, (iodefv2_system_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->system_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->system_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_flow_new_system(ptr, (iodefv2_system_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_flow_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_flow_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
    
                case 0: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->system_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_system_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->system_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_system_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_flow_destroy_internal(iodefv2_flow_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_system_t *entry;

                libiodefv2_list_for_each_safe(&ptr->system_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_system_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_flow_destroy:
 * @ptr: pointer to a #iodefv2_flow_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_flow_destroy(iodefv2_flow_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_flow_destroy_internal(ptr);
        free(ptr);
}






/**
 * iodefv2_flow_get_next_system:
 * @flow: pointer to a #iodefv2_flow_t object.
 * @system_cur: pointer to a #iodefv2_system_t object.
 *
 * Get the next #iodefv2_system_t object listed in @ptr.
 * When iterating over the iodefv2_system_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_system_t object.
 *
 * Returns: the next #iodefv2_system_t in the list.
 */
iodefv2_system_t *iodefv2_flow_get_next_system(iodefv2_flow_t *flow, iodefv2_system_t *system_cur)
{
        libiodefv2_list_t *tmp = (system_cur) ? &((libiodefv2_linked_object_t *) system_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(flow, NULL);

        libiodefv2_list_for_each_continue(&flow->system_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_flow_set_system:
 * @ptr: pointer to a #iodefv2_flow_t object.
 * @object: pointer to a #iodefv2_system_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_system_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_flow_set_system(iodefv2_flow_t *ptr, iodefv2_system_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->system_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_flow_new_system:
 *  @ptr: pointer to a #iodefv2_flow_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_system_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_system_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_system_t object. The created #iodefv2_system_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_flow_new_system(iodefv2_flow_t *ptr, iodefv2_system_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_system_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->system_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_flow_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_flow_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_flow_copy(const iodefv2_flow_t *src, iodefv2_flow_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_system_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->system_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_system_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->system_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_system_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->system_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_flow_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_flow_clone(iodefv2_flow_t *src, iodefv2_flow_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_flow_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_flow_copy(src, *dst);
}


/**
 * iodefv2_flow_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_flow_compare(const iodefv2_flow_t *obj1, const iodefv2_flow_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_system_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->system_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->system_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_system_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_event_data_new:
 * @ret: Pointer where to store the created #iodefv2_event_data_t object.
 *
 * Create a new #iodefv2_event_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_event_data_new(iodefv2_event_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_EVENT_DATA;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);


        libiodefv2_list_init(&(*ret)->flow_list);


        libiodefv2_list_init(&(*ret)->expectation_list);


        libiodefv2_list_init(&(*ret)->contact_list);


        libiodefv2_list_init(&(*ret)->method_list);


        libiodefv2_list_init(&(*ret)->discovery_list);



























            return 0;
}


/**
 * iodefv2_event_data_ref:
 * @event_data: pointer to a #iodefv2_event_data_t object.
 *
 * Increase @event_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @event_data.
 */
iodefv2_event_data_t *iodefv2_event_data_ref(iodefv2_event_data_t *event_data)
{
        libiodefv2_return_val_if_fail(event_data, NULL);
        event_data->refcount++;

        return event_data;
}



int _iodefv2_event_data_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_event_data_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_EVENT_DATA_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);



            case 3:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->detect_time, TRUE);


            case 4:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 5:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->report_time, TRUE);



            case 6:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);


            case 7:
                *childptr = &ptr->flow_list;
                return 0;

            case 8:
                *childptr = &ptr->expectation_list;
                return 0;


            case 9:
                *childptr = ptr->record;
                return 0;

            case 10:
                *childptr = &ptr->contact_list;
                return 0;


            case 11:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->start_time, TRUE);



            case 12:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->end_time, TRUE);



            case 13:
                *childptr = ptr->assessment;
                return 0;

            case 14:
                *childptr = &ptr->method_list;
                return 0;


            case 15:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->recovery_time, TRUE);


            case 16:
                *childptr = &ptr->discovery_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_event_data_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_event_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_event_data_new_restriction(ptr, (iodefv2_event_data_restriction_t **) ret);

                case 1:
                    return iodefv2_event_data_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_event_data_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_event_data_new_detect_time(ptr, (iodefv2_time_t **) ret);

                case 4: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_event_data_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_event_data_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 5:
                    return iodefv2_event_data_new_report_time(ptr, (iodefv2_time_t **) ret);

                case 6:
                    return iodefv2_event_data_new_description(ptr, (libiodefv2_string_t **) ret);

                case 7: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_event_data_new_flow(ptr, (iodefv2_flow_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->flow_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->flow_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_event_data_new_flow(ptr, (iodefv2_flow_t **) ret, n);
                }

                case 8: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_event_data_new_expectation(ptr, (iodefv2_expectation_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->expectation_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->expectation_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_event_data_new_expectation(ptr, (iodefv2_expectation_t **) ret, n);
                }

                case 9:
                    return iodefv2_event_data_new_record(ptr, (iodefv2_record_t **) ret);

                case 10: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_event_data_new_contact(ptr, (iodefv2_contact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->contact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->contact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_event_data_new_contact(ptr, (iodefv2_contact_t **) ret, n);
                }

                case 11:
                    return iodefv2_event_data_new_start_time(ptr, (iodefv2_time_t **) ret);

                case 12:
                    return iodefv2_event_data_new_end_time(ptr, (iodefv2_time_t **) ret);

                case 13:
                    return iodefv2_event_data_new_assessment(ptr, (iodefv2_assessment_t **) ret);

                case 14: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_event_data_new_method(ptr, (iodefv2_method_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->method_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->method_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_event_data_new_method(ptr, (iodefv2_method_t **) ret, n);
                }

                case 15:
                    return iodefv2_event_data_new_recovery_time(ptr, (iodefv2_time_t **) ret);

                case 16: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_event_data_new_discovery(ptr, (iodefv2_discovery_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->discovery_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->discovery_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_event_data_new_discovery(ptr, (iodefv2_discovery_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_event_data_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_event_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->detect_time ) {
                                iodefv2_time_destroy(ptr->detect_time);
                                ptr->detect_time = NULL;
                        }

                        return 0;

    
                case 4: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 5:
                        if ( ptr->report_time ) {
                                iodefv2_time_destroy(ptr->report_time);
                                ptr->report_time = NULL;
                        }

                        return 0;




                case 6:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;

    
                case 7: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->flow_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_flow_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->flow_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_flow_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 8: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->expectation_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_expectation_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->expectation_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_expectation_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 9:
                        if ( ptr->record ) {
                                iodefv2_record_destroy(ptr->record);
                                ptr->record = NULL;
                        }

                        return 0;

    
                case 10: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->contact_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_contact_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->contact_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_contact_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 11:
                        if ( ptr->start_time ) {
                                iodefv2_time_destroy(ptr->start_time);
                                ptr->start_time = NULL;
                        }

                        return 0;




                case 12:
                        if ( ptr->end_time ) {
                                iodefv2_time_destroy(ptr->end_time);
                                ptr->end_time = NULL;
                        }

                        return 0;




                case 13:
                        if ( ptr->assessment ) {
                                iodefv2_assessment_destroy(ptr->assessment);
                                ptr->assessment = NULL;
                        }

                        return 0;

    
                case 14: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->method_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_method_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->method_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_method_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 15:
                        if ( ptr->recovery_time ) {
                                iodefv2_time_destroy(ptr->recovery_time);
                                ptr->recovery_time = NULL;
                        }

                        return 0;

    
                case 16: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->discovery_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_discovery_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->discovery_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_discovery_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_event_data_destroy_internal(iodefv2_event_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }



        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }



        if ( ptr->detect_time ) {
                iodefv2_time_destroy(ptr->detect_time);
                ptr->detect_time = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }

        if ( ptr->report_time ) {
                iodefv2_time_destroy(ptr->report_time);
                ptr->report_time = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_flow_t *entry;

                libiodefv2_list_for_each_safe(&ptr->flow_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_flow_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_expectation_t *entry;

                libiodefv2_list_for_each_safe(&ptr->expectation_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_expectation_destroy(entry);
                }
        }


        if ( ptr->record ) {
                iodefv2_record_destroy(ptr->record);
                ptr->record = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_contact_t *entry;

                libiodefv2_list_for_each_safe(&ptr->contact_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_contact_destroy(entry);
                }
        }

        if ( ptr->start_time ) {
                iodefv2_time_destroy(ptr->start_time);
                ptr->start_time = NULL;
        }



        if ( ptr->end_time ) {
                iodefv2_time_destroy(ptr->end_time);
                ptr->end_time = NULL;
        }




        if ( ptr->assessment ) {
                iodefv2_assessment_destroy(ptr->assessment);
                ptr->assessment = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_method_t *entry;

                libiodefv2_list_for_each_safe(&ptr->method_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_method_destroy(entry);
                }
        }

        if ( ptr->recovery_time ) {
                iodefv2_time_destroy(ptr->recovery_time);
                ptr->recovery_time = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_discovery_t *entry;

                libiodefv2_list_for_each_safe(&ptr->discovery_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_discovery_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_event_data_destroy:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_event_data_destroy(iodefv2_event_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_event_data_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_event_data_get_restriction:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 *
 * Get restriction children of the #iodefv2_event_data_t object.
 *
 * Returns: a pointer to a iodefv2_event_data_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_event_data_restriction_t *iodefv2_event_data_get_restriction(iodefv2_event_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_event_data_set_restriction:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @restriction: pointer to a #iodefv2_event_data_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_event_data_set_restriction(iodefv2_event_data_t *ptr, iodefv2_event_data_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_event_data_unset_restriction(iodefv2_event_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_event_data_new_restriction:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_event_data_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_event_data_t.
 * If @ptr already contain a #iodefv2_event_data_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_restriction(iodefv2_event_data_t *ptr, iodefv2_event_data_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_event_data_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 *
 * Get ext_restriction children of the #iodefv2_event_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_event_data_get_ext_restriction(iodefv2_event_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_event_data_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_event_data_set_ext_restriction(iodefv2_event_data_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_event_data_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_event_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_ext_restriction(iodefv2_event_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_event_data_get_observable_id:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 *
 * Get observable_id children of the #iodefv2_event_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_event_data_get_observable_id(iodefv2_event_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_event_data_set_observable_id:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_event_data_set_observable_id(iodefv2_event_data_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_event_data_new_observable_id:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_event_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_observable_id(iodefv2_event_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}




/**
 * iodefv2_event_data_get_detect_time:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 *
 * Get detect_time children of the #iodefv2_event_data_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_event_data_get_detect_time(iodefv2_event_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->detect_time;

}


/**
 * iodefv2_event_data_set_detect_time:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @detect_time: pointer to a #iodefv2_time_t object.
 *
 * Set @detect_time object as a children of @ptr.
 * if @ptr already contain an @detect_time object, then it is destroyed,
 * and updated to point to the provided @detect_time object.
 */

void iodefv2_event_data_set_detect_time(iodefv2_event_data_t *ptr, iodefv2_time_t *detect_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->detect_time )
                iodefv2_time_destroy(ptr->detect_time);

        ptr->detect_time = detect_time;
}
/**
 * iodefv2_event_data_new_detect_time:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new detect_time object, children of #iodefv2_event_data_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_detect_time(iodefv2_event_data_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->detect_time ) {
                retval = iodefv2_time_new(&ptr->detect_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->detect_time;
        return 0;
}





/**
 * iodefv2_event_data_get_next_additional_data:
 * @event_data: pointer to a #iodefv2_event_data_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_event_data_get_next_additional_data(iodefv2_event_data_t *event_data, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(event_data, NULL);

        libiodefv2_list_for_each_continue(&event_data->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_event_data_set_additional_data:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_event_data_set_additional_data(iodefv2_event_data_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_event_data_new_additional_data:
 *  @ptr: pointer to a #iodefv2_event_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_additional_data(iodefv2_event_data_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_event_data_get_report_time:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 *
 * Get report_time children of the #iodefv2_event_data_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_event_data_get_report_time(iodefv2_event_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->report_time;

}


/**
 * iodefv2_event_data_set_report_time:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @report_time: pointer to a #iodefv2_time_t object.
 *
 * Set @report_time object as a children of @ptr.
 * if @ptr already contain an @report_time object, then it is destroyed,
 * and updated to point to the provided @report_time object.
 */

void iodefv2_event_data_set_report_time(iodefv2_event_data_t *ptr, iodefv2_time_t *report_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->report_time )
                iodefv2_time_destroy(ptr->report_time);

        ptr->report_time = report_time;
}
/**
 * iodefv2_event_data_new_report_time:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new report_time object, children of #iodefv2_event_data_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_report_time(iodefv2_event_data_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->report_time ) {
                retval = iodefv2_time_new(&ptr->report_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->report_time;
        return 0;
}




/**
 * iodefv2_event_data_get_description:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 *
 * Get description children of the #iodefv2_event_data_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_event_data_get_description(iodefv2_event_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_event_data_set_description:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_event_data_set_description(iodefv2_event_data_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_event_data_new_description:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_event_data_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_description(iodefv2_event_data_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}





/**
 * iodefv2_event_data_get_next_flow:
 * @event_data: pointer to a #iodefv2_event_data_t object.
 * @flow_cur: pointer to a #iodefv2_flow_t object.
 *
 * Get the next #iodefv2_flow_t object listed in @ptr.
 * When iterating over the iodefv2_flow_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_flow_t object.
 *
 * Returns: the next #iodefv2_flow_t in the list.
 */
iodefv2_flow_t *iodefv2_event_data_get_next_flow(iodefv2_event_data_t *event_data, iodefv2_flow_t *flow_cur)
{
        libiodefv2_list_t *tmp = (flow_cur) ? &((libiodefv2_linked_object_t *) flow_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(event_data, NULL);

        libiodefv2_list_for_each_continue(&event_data->flow_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_event_data_set_flow:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @object: pointer to a #iodefv2_flow_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_flow_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_event_data_set_flow(iodefv2_event_data_t *ptr, iodefv2_flow_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->flow_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_event_data_new_flow:
 *  @ptr: pointer to a #iodefv2_event_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_flow_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_flow_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_flow_t object. The created #iodefv2_flow_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_flow(iodefv2_event_data_t *ptr, iodefv2_flow_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_flow_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->flow_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_event_data_get_next_expectation:
 * @event_data: pointer to a #iodefv2_event_data_t object.
 * @expectation_cur: pointer to a #iodefv2_expectation_t object.
 *
 * Get the next #iodefv2_expectation_t object listed in @ptr.
 * When iterating over the iodefv2_expectation_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_expectation_t object.
 *
 * Returns: the next #iodefv2_expectation_t in the list.
 */
iodefv2_expectation_t *iodefv2_event_data_get_next_expectation(iodefv2_event_data_t *event_data, iodefv2_expectation_t *expectation_cur)
{
        libiodefv2_list_t *tmp = (expectation_cur) ? &((libiodefv2_linked_object_t *) expectation_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(event_data, NULL);

        libiodefv2_list_for_each_continue(&event_data->expectation_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_event_data_set_expectation:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @object: pointer to a #iodefv2_expectation_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_expectation_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_event_data_set_expectation(iodefv2_event_data_t *ptr, iodefv2_expectation_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->expectation_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_event_data_new_expectation:
 *  @ptr: pointer to a #iodefv2_event_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_expectation_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_expectation_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_expectation_t object. The created #iodefv2_expectation_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_expectation(iodefv2_event_data_t *ptr, iodefv2_expectation_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_expectation_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->expectation_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_event_data_get_record:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 *
 * Get record children of the #iodefv2_event_data_t object.
 *
 * Returns: a pointer to a iodefv2_record_t object, or NULL if the children object is not set.
 */
iodefv2_record_t *iodefv2_event_data_get_record(iodefv2_event_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->record;

}


/**
 * iodefv2_event_data_set_record:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @record: pointer to a #iodefv2_record_t object.
 *
 * Set @record object as a children of @ptr.
 * if @ptr already contain an @record object, then it is destroyed,
 * and updated to point to the provided @record object.
 */

void iodefv2_event_data_set_record(iodefv2_event_data_t *ptr, iodefv2_record_t *record)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->record )
                iodefv2_record_destroy(ptr->record);

        ptr->record = record;
}
/**
 * iodefv2_event_data_new_record:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_record_t object.
 *
 * Create a new record object, children of #iodefv2_event_data_t.
 * If @ptr already contain a #iodefv2_record_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_record(iodefv2_event_data_t *ptr, iodefv2_record_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->record ) {
                retval = iodefv2_record_new(&ptr->record);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->record;
        return 0;
}





/**
 * iodefv2_event_data_get_next_contact:
 * @event_data: pointer to a #iodefv2_event_data_t object.
 * @contact_cur: pointer to a #iodefv2_contact_t object.
 *
 * Get the next #iodefv2_contact_t object listed in @ptr.
 * When iterating over the iodefv2_contact_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_contact_t object.
 *
 * Returns: the next #iodefv2_contact_t in the list.
 */
iodefv2_contact_t *iodefv2_event_data_get_next_contact(iodefv2_event_data_t *event_data, iodefv2_contact_t *contact_cur)
{
        libiodefv2_list_t *tmp = (contact_cur) ? &((libiodefv2_linked_object_t *) contact_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(event_data, NULL);

        libiodefv2_list_for_each_continue(&event_data->contact_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_event_data_set_contact:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @object: pointer to a #iodefv2_contact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_contact_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_event_data_set_contact(iodefv2_event_data_t *ptr, iodefv2_contact_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->contact_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_event_data_new_contact:
 *  @ptr: pointer to a #iodefv2_event_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_contact_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_contact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_contact_t object. The created #iodefv2_contact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_contact(iodefv2_event_data_t *ptr, iodefv2_contact_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_contact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->contact_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_event_data_get_start_time:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 *
 * Get start_time children of the #iodefv2_event_data_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_event_data_get_start_time(iodefv2_event_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->start_time;

}


/**
 * iodefv2_event_data_set_start_time:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @start_time: pointer to a #iodefv2_time_t object.
 *
 * Set @start_time object as a children of @ptr.
 * if @ptr already contain an @start_time object, then it is destroyed,
 * and updated to point to the provided @start_time object.
 */

void iodefv2_event_data_set_start_time(iodefv2_event_data_t *ptr, iodefv2_time_t *start_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->start_time )
                iodefv2_time_destroy(ptr->start_time);

        ptr->start_time = start_time;
}
/**
 * iodefv2_event_data_new_start_time:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new start_time object, children of #iodefv2_event_data_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_start_time(iodefv2_event_data_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->start_time ) {
                retval = iodefv2_time_new(&ptr->start_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->start_time;
        return 0;
}




/**
 * iodefv2_event_data_get_end_time:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 *
 * Get end_time children of the #iodefv2_event_data_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_event_data_get_end_time(iodefv2_event_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->end_time;

}


/**
 * iodefv2_event_data_set_end_time:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @end_time: pointer to a #iodefv2_time_t object.
 *
 * Set @end_time object as a children of @ptr.
 * if @ptr already contain an @end_time object, then it is destroyed,
 * and updated to point to the provided @end_time object.
 */

void iodefv2_event_data_set_end_time(iodefv2_event_data_t *ptr, iodefv2_time_t *end_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->end_time )
                iodefv2_time_destroy(ptr->end_time);

        ptr->end_time = end_time;
}
/**
 * iodefv2_event_data_new_end_time:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new end_time object, children of #iodefv2_event_data_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_end_time(iodefv2_event_data_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->end_time ) {
                retval = iodefv2_time_new(&ptr->end_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->end_time;
        return 0;
}




/**
 * iodefv2_event_data_get_assessment:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 *
 * Get assessment children of the #iodefv2_event_data_t object.
 *
 * Returns: a pointer to a iodefv2_assessment_t object, or NULL if the children object is not set.
 */
iodefv2_assessment_t *iodefv2_event_data_get_assessment(iodefv2_event_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->assessment;

}


/**
 * iodefv2_event_data_set_assessment:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @assessment: pointer to a #iodefv2_assessment_t object.
 *
 * Set @assessment object as a children of @ptr.
 * if @ptr already contain an @assessment object, then it is destroyed,
 * and updated to point to the provided @assessment object.
 */

void iodefv2_event_data_set_assessment(iodefv2_event_data_t *ptr, iodefv2_assessment_t *assessment)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->assessment )
                iodefv2_assessment_destroy(ptr->assessment);

        ptr->assessment = assessment;
}
/**
 * iodefv2_event_data_new_assessment:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_assessment_t object.
 *
 * Create a new assessment object, children of #iodefv2_event_data_t.
 * If @ptr already contain a #iodefv2_assessment_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_assessment(iodefv2_event_data_t *ptr, iodefv2_assessment_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->assessment ) {
                retval = iodefv2_assessment_new(&ptr->assessment);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->assessment;
        return 0;
}





/**
 * iodefv2_event_data_get_next_method:
 * @event_data: pointer to a #iodefv2_event_data_t object.
 * @method_cur: pointer to a #iodefv2_method_t object.
 *
 * Get the next #iodefv2_method_t object listed in @ptr.
 * When iterating over the iodefv2_method_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_method_t object.
 *
 * Returns: the next #iodefv2_method_t in the list.
 */
iodefv2_method_t *iodefv2_event_data_get_next_method(iodefv2_event_data_t *event_data, iodefv2_method_t *method_cur)
{
        libiodefv2_list_t *tmp = (method_cur) ? &((libiodefv2_linked_object_t *) method_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(event_data, NULL);

        libiodefv2_list_for_each_continue(&event_data->method_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_event_data_set_method:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @object: pointer to a #iodefv2_method_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_method_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_event_data_set_method(iodefv2_event_data_t *ptr, iodefv2_method_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->method_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_event_data_new_method:
 *  @ptr: pointer to a #iodefv2_event_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_method_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_method_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_method_t object. The created #iodefv2_method_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_method(iodefv2_event_data_t *ptr, iodefv2_method_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_method_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->method_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_event_data_get_recovery_time:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 *
 * Get recovery_time children of the #iodefv2_event_data_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_event_data_get_recovery_time(iodefv2_event_data_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->recovery_time;

}


/**
 * iodefv2_event_data_set_recovery_time:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @recovery_time: pointer to a #iodefv2_time_t object.
 *
 * Set @recovery_time object as a children of @ptr.
 * if @ptr already contain an @recovery_time object, then it is destroyed,
 * and updated to point to the provided @recovery_time object.
 */

void iodefv2_event_data_set_recovery_time(iodefv2_event_data_t *ptr, iodefv2_time_t *recovery_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->recovery_time )
                iodefv2_time_destroy(ptr->recovery_time);

        ptr->recovery_time = recovery_time;
}
/**
 * iodefv2_event_data_new_recovery_time:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new recovery_time object, children of #iodefv2_event_data_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_recovery_time(iodefv2_event_data_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->recovery_time ) {
                retval = iodefv2_time_new(&ptr->recovery_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->recovery_time;
        return 0;
}





/**
 * iodefv2_event_data_get_next_discovery:
 * @event_data: pointer to a #iodefv2_event_data_t object.
 * @discovery_cur: pointer to a #iodefv2_discovery_t object.
 *
 * Get the next #iodefv2_discovery_t object listed in @ptr.
 * When iterating over the iodefv2_discovery_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_discovery_t object.
 *
 * Returns: the next #iodefv2_discovery_t in the list.
 */
iodefv2_discovery_t *iodefv2_event_data_get_next_discovery(iodefv2_event_data_t *event_data, iodefv2_discovery_t *discovery_cur)
{
        libiodefv2_list_t *tmp = (discovery_cur) ? &((libiodefv2_linked_object_t *) discovery_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(event_data, NULL);

        libiodefv2_list_for_each_continue(&event_data->discovery_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_event_data_set_discovery:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 * @object: pointer to a #iodefv2_discovery_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_discovery_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_event_data_set_discovery(iodefv2_event_data_t *ptr, iodefv2_discovery_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->discovery_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_event_data_new_discovery:
 *  @ptr: pointer to a #iodefv2_event_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_discovery_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_discovery_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_discovery_t object. The created #iodefv2_discovery_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_event_data_new_discovery(iodefv2_event_data_t *ptr, iodefv2_discovery_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_discovery_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->discovery_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_event_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_event_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_event_data_copy(const iodefv2_event_data_t *src, iodefv2_event_data_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->detect_time ) {
                iodefv2_time_destroy(dst->detect_time);
                dst->detect_time = NULL;
        }

        if ( src->detect_time ) {
                ret = iodefv2_time_clone(src->detect_time, &dst->detect_time);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->report_time ) {
                iodefv2_time_destroy(dst->report_time);
                dst->report_time = NULL;
        }

        if ( src->report_time ) {
                ret = iodefv2_time_clone(src->report_time, &dst->report_time);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_flow_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->flow_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_flow_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->flow_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_flow_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->flow_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_expectation_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->expectation_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_expectation_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->expectation_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_expectation_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->expectation_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->record ) {
                iodefv2_record_destroy(dst->record);
                dst->record = NULL;
        }

        if ( src->record ) {
                ret = iodefv2_record_clone(src->record, &dst->record);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_contact_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->contact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_contact_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->contact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_contact_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->contact_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->start_time ) {
                iodefv2_time_destroy(dst->start_time);
                dst->start_time = NULL;
        }

        if ( src->start_time ) {
                ret = iodefv2_time_clone(src->start_time, &dst->start_time);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->end_time ) {
                iodefv2_time_destroy(dst->end_time);
                dst->end_time = NULL;
        }

        if ( src->end_time ) {
                ret = iodefv2_time_clone(src->end_time, &dst->end_time);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->assessment ) {
                iodefv2_assessment_destroy(dst->assessment);
                dst->assessment = NULL;
        }

        if ( src->assessment ) {
                ret = iodefv2_assessment_clone(src->assessment, &dst->assessment);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_method_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->method_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_method_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->method_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_method_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->method_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->recovery_time ) {
                iodefv2_time_destroy(dst->recovery_time);
                dst->recovery_time = NULL;
        }

        if ( src->recovery_time ) {
                ret = iodefv2_time_clone(src->recovery_time, &dst->recovery_time);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_discovery_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->discovery_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_discovery_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->discovery_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_discovery_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->discovery_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_event_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_event_data_clone(iodefv2_event_data_t *src, iodefv2_event_data_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_event_data_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_event_data_copy(src, *dst);
}


/**
 * iodefv2_event_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_event_data_compare(const iodefv2_event_data_t *obj1, const iodefv2_event_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;

        ret = iodefv2_time_compare(obj1->detect_time, obj2->detect_time);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = iodefv2_time_compare(obj1->report_time, obj2->report_time);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_flow_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->flow_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->flow_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_flow_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_expectation_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->expectation_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->expectation_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_expectation_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_record_compare(obj1->record, obj2->record);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_contact_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->contact_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->contact_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_contact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = iodefv2_time_compare(obj1->start_time, obj2->start_time);
        if ( ret != 0 )
                return ret;

        ret = iodefv2_time_compare(obj1->end_time, obj2->end_time);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_assessment_compare(obj1->assessment, obj2->assessment);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_method_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->method_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->method_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_method_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = iodefv2_time_compare(obj1->recovery_time, obj2->recovery_time);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_discovery_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->discovery_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->discovery_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_discovery_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_observable_new:
 * @ret: Pointer where to store the created #iodefv2_observable_t object.
 *
 * Create a new #iodefv2_observable_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_observable_new(iodefv2_observable_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_OBSERVABLE;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);








































            return 0;
}


/**
 * iodefv2_observable_ref:
 * @observable: pointer to a #iodefv2_observable_t object.
 *
 * Increase @observable reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @observable.
 */
iodefv2_observable_t *iodefv2_observable_ref(iodefv2_observable_t *observable)
{
        libiodefv2_return_val_if_fail(observable, NULL);
        observable->refcount++;

        return observable;
}



int _iodefv2_observable_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_observable_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_OBSERVABLE_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);



            case 2:
                *childptr = ptr->detection_pattern;
                return 0;


            case 3:
                *childptr = ptr->service;
                return 0;

            case 4:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 5:
                *childptr = ptr->system;
                return 0;


            case 6:
                *childptr = ptr->domain_data;
                return 0;


            case 7:
                *childptr = ptr->email_data;
                return 0;


            case 8:
                *childptr = ptr->assessment;
                return 0;


            case 9:
                *childptr = ptr->record_data;
                return 0;


            case 10:
                *childptr = ptr->reference;
                return 0;


            case 11:
                *childptr = ptr->history_item;
                return 0;


            case 12:
                *childptr = ptr->bulk_observable;
                return 0;


            case 13:
                *childptr = ptr->certificate_data;
                return 0;


            case 14:
                *childptr = ptr->expectation;
                return 0;


            case 15:
                *childptr = ptr->windows_registry_keys_modified;
                return 0;


            case 16:
                *childptr = ptr->address;
                return 0;


            case 17:
                *childptr = ptr->event_data;
                return 0;


            case 18:
                *childptr = ptr->file_data;
                return 0;


            case 19:
                *childptr = ptr->registry_handle;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_observable_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_observable_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_observable_new_restriction(ptr, (iodefv2_observable_restriction_t **) ret);

                case 1:
                    return iodefv2_observable_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_observable_new_detection_pattern(ptr, (iodefv2_detection_pattern_t **) ret);

                case 3:
                    return iodefv2_observable_new_service(ptr, (iodefv2_service_t **) ret);

                case 4: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_observable_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_observable_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 5:
                    return iodefv2_observable_new_system(ptr, (iodefv2_system_t **) ret);

                case 6:
                    return iodefv2_observable_new_domain_data(ptr, (iodefv2_domain_data_t **) ret);

                case 7:
                    return iodefv2_observable_new_email_data(ptr, (iodefv2_email_data_t **) ret);

                case 8:
                    return iodefv2_observable_new_assessment(ptr, (iodefv2_assessment_t **) ret);

                case 9:
                    return iodefv2_observable_new_record_data(ptr, (iodefv2_record_data_t **) ret);

                case 10:
                    return iodefv2_observable_new_reference(ptr, (iodefv2_reference_t **) ret);

                case 11:
                    return iodefv2_observable_new_history_item(ptr, (iodefv2_history_item_t **) ret);

                case 12:
                    return iodefv2_observable_new_bulk_observable(ptr, (iodefv2_bulk_observable_t **) ret);

                case 13:
                    return iodefv2_observable_new_certificate_data(ptr, (iodefv2_certificate_data_t **) ret);

                case 14:
                    return iodefv2_observable_new_expectation(ptr, (iodefv2_expectation_t **) ret);

                case 15:
                    return iodefv2_observable_new_windows_registry_keys_modified(ptr, (iodefv2_windows_registry_keys_modified_t **) ret);

                case 16:
                    return iodefv2_observable_new_address(ptr, (iodefv2_address_t **) ret);

                case 17:
                    return iodefv2_observable_new_event_data(ptr, (iodefv2_event_data_t **) ret);

                case 18:
                    return iodefv2_observable_new_file_data(ptr, (iodefv2_file_data_t **) ret);

                case 19:
                    return iodefv2_observable_new_registry_handle(ptr, (iodefv2_registry_handle_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_observable_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_observable_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->detection_pattern ) {
                                iodefv2_detection_pattern_destroy(ptr->detection_pattern);
                                ptr->detection_pattern = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->service ) {
                                iodefv2_service_destroy(ptr->service);
                                ptr->service = NULL;
                        }

                        return 0;

    
                case 4: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 5:
                        if ( ptr->system ) {
                                iodefv2_system_destroy(ptr->system);
                                ptr->system = NULL;
                        }

                        return 0;




                case 6:
                        if ( ptr->domain_data ) {
                                iodefv2_domain_data_destroy(ptr->domain_data);
                                ptr->domain_data = NULL;
                        }

                        return 0;




                case 7:
                        if ( ptr->email_data ) {
                                iodefv2_email_data_destroy(ptr->email_data);
                                ptr->email_data = NULL;
                        }

                        return 0;




                case 8:
                        if ( ptr->assessment ) {
                                iodefv2_assessment_destroy(ptr->assessment);
                                ptr->assessment = NULL;
                        }

                        return 0;




                case 9:
                        if ( ptr->record_data ) {
                                iodefv2_record_data_destroy(ptr->record_data);
                                ptr->record_data = NULL;
                        }

                        return 0;




                case 10:
                        if ( ptr->reference ) {
                                iodefv2_reference_destroy(ptr->reference);
                                ptr->reference = NULL;
                        }

                        return 0;




                case 11:
                        if ( ptr->history_item ) {
                                iodefv2_history_item_destroy(ptr->history_item);
                                ptr->history_item = NULL;
                        }

                        return 0;




                case 12:
                        if ( ptr->bulk_observable ) {
                                iodefv2_bulk_observable_destroy(ptr->bulk_observable);
                                ptr->bulk_observable = NULL;
                        }

                        return 0;




                case 13:
                        if ( ptr->certificate_data ) {
                                iodefv2_certificate_data_destroy(ptr->certificate_data);
                                ptr->certificate_data = NULL;
                        }

                        return 0;




                case 14:
                        if ( ptr->expectation ) {
                                iodefv2_expectation_destroy(ptr->expectation);
                                ptr->expectation = NULL;
                        }

                        return 0;




                case 15:
                        if ( ptr->windows_registry_keys_modified ) {
                                iodefv2_windows_registry_keys_modified_destroy(ptr->windows_registry_keys_modified);
                                ptr->windows_registry_keys_modified = NULL;
                        }

                        return 0;




                case 16:
                        if ( ptr->address ) {
                                iodefv2_address_destroy(ptr->address);
                                ptr->address = NULL;
                        }

                        return 0;




                case 17:
                        if ( ptr->event_data ) {
                                iodefv2_event_data_destroy(ptr->event_data);
                                ptr->event_data = NULL;
                        }

                        return 0;




                case 18:
                        if ( ptr->file_data ) {
                                iodefv2_file_data_destroy(ptr->file_data);
                                ptr->file_data = NULL;
                        }

                        return 0;




                case 19:
                        if ( ptr->registry_handle ) {
                                iodefv2_registry_handle_destroy(ptr->registry_handle);
                                ptr->registry_handle = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_observable_destroy_internal(iodefv2_observable_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }




        if ( ptr->detection_pattern ) {
                iodefv2_detection_pattern_destroy(ptr->detection_pattern);
                ptr->detection_pattern = NULL;
        }




        if ( ptr->service ) {
                iodefv2_service_destroy(ptr->service);
                ptr->service = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }


        if ( ptr->system ) {
                iodefv2_system_destroy(ptr->system);
                ptr->system = NULL;
        }




        if ( ptr->domain_data ) {
                iodefv2_domain_data_destroy(ptr->domain_data);
                ptr->domain_data = NULL;
        }




        if ( ptr->email_data ) {
                iodefv2_email_data_destroy(ptr->email_data);
                ptr->email_data = NULL;
        }




        if ( ptr->assessment ) {
                iodefv2_assessment_destroy(ptr->assessment);
                ptr->assessment = NULL;
        }




        if ( ptr->record_data ) {
                iodefv2_record_data_destroy(ptr->record_data);
                ptr->record_data = NULL;
        }




        if ( ptr->reference ) {
                iodefv2_reference_destroy(ptr->reference);
                ptr->reference = NULL;
        }




        if ( ptr->history_item ) {
                iodefv2_history_item_destroy(ptr->history_item);
                ptr->history_item = NULL;
        }




        if ( ptr->bulk_observable ) {
                iodefv2_bulk_observable_destroy(ptr->bulk_observable);
                ptr->bulk_observable = NULL;
        }




        if ( ptr->certificate_data ) {
                iodefv2_certificate_data_destroy(ptr->certificate_data);
                ptr->certificate_data = NULL;
        }




        if ( ptr->expectation ) {
                iodefv2_expectation_destroy(ptr->expectation);
                ptr->expectation = NULL;
        }




        if ( ptr->windows_registry_keys_modified ) {
                iodefv2_windows_registry_keys_modified_destroy(ptr->windows_registry_keys_modified);
                ptr->windows_registry_keys_modified = NULL;
        }




        if ( ptr->address ) {
                iodefv2_address_destroy(ptr->address);
                ptr->address = NULL;
        }




        if ( ptr->event_data ) {
                iodefv2_event_data_destroy(ptr->event_data);
                ptr->event_data = NULL;
        }




        if ( ptr->file_data ) {
                iodefv2_file_data_destroy(ptr->file_data);
                ptr->file_data = NULL;
        }




        if ( ptr->registry_handle ) {
                iodefv2_registry_handle_destroy(ptr->registry_handle);
                ptr->registry_handle = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_observable_destroy:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_observable_destroy(iodefv2_observable_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_observable_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_observable_get_restriction:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get restriction children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_observable_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_observable_restriction_t *iodefv2_observable_get_restriction(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_observable_set_restriction:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @restriction: pointer to a #iodefv2_observable_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_observable_set_restriction(iodefv2_observable_t *ptr, iodefv2_observable_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_observable_unset_restriction(iodefv2_observable_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_observable_new_restriction:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_observable_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_observable_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_restriction(iodefv2_observable_t *ptr, iodefv2_observable_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_observable_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get ext_restriction children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_observable_get_ext_restriction(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_observable_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_observable_set_ext_restriction(iodefv2_observable_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_observable_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_observable_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_ext_restriction(iodefv2_observable_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}




/**
 * iodefv2_observable_get_detection_pattern:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get detection_pattern children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_detection_pattern_t object, or NULL if the children object is not set.
 */
iodefv2_detection_pattern_t *iodefv2_observable_get_detection_pattern(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->detection_pattern;

}


/**
 * iodefv2_observable_set_detection_pattern:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @detection_pattern: pointer to a #iodefv2_detection_pattern_t object.
 *
 * Set @detection_pattern object as a children of @ptr.
 * if @ptr already contain an @detection_pattern object, then it is destroyed,
 * and updated to point to the provided @detection_pattern object.
 */

void iodefv2_observable_set_detection_pattern(iodefv2_observable_t *ptr, iodefv2_detection_pattern_t *detection_pattern)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->detection_pattern )
                iodefv2_detection_pattern_destroy(ptr->detection_pattern);

        ptr->detection_pattern = detection_pattern;
}
/**
 * iodefv2_observable_new_detection_pattern:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_detection_pattern_t object.
 *
 * Create a new detection_pattern object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_detection_pattern_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_detection_pattern(iodefv2_observable_t *ptr, iodefv2_detection_pattern_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->detection_pattern ) {
                retval = iodefv2_detection_pattern_new(&ptr->detection_pattern);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->detection_pattern;
        return 0;
}




/**
 * iodefv2_observable_get_service:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get service children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_service_t object, or NULL if the children object is not set.
 */
iodefv2_service_t *iodefv2_observable_get_service(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->service;

}


/**
 * iodefv2_observable_set_service:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @service: pointer to a #iodefv2_service_t object.
 *
 * Set @service object as a children of @ptr.
 * if @ptr already contain an @service object, then it is destroyed,
 * and updated to point to the provided @service object.
 */

void iodefv2_observable_set_service(iodefv2_observable_t *ptr, iodefv2_service_t *service)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->service )
                iodefv2_service_destroy(ptr->service);

        ptr->service = service;
}
/**
 * iodefv2_observable_new_service:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_service_t object.
 *
 * Create a new service object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_service_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_service(iodefv2_observable_t *ptr, iodefv2_service_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->service ) {
                retval = iodefv2_service_new(&ptr->service);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->service;
        return 0;
}





/**
 * iodefv2_observable_get_next_additional_data:
 * @observable: pointer to a #iodefv2_observable_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_observable_get_next_additional_data(iodefv2_observable_t *observable, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(observable, NULL);

        libiodefv2_list_for_each_continue(&observable->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_observable_set_additional_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_observable_set_additional_data(iodefv2_observable_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_observable_new_additional_data:
 *  @ptr: pointer to a #iodefv2_observable_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_additional_data(iodefv2_observable_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_observable_get_system:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get system children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_system_t object, or NULL if the children object is not set.
 */
iodefv2_system_t *iodefv2_observable_get_system(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->system;

}


/**
 * iodefv2_observable_set_system:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @system: pointer to a #iodefv2_system_t object.
 *
 * Set @system object as a children of @ptr.
 * if @ptr already contain an @system object, then it is destroyed,
 * and updated to point to the provided @system object.
 */

void iodefv2_observable_set_system(iodefv2_observable_t *ptr, iodefv2_system_t *system)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->system )
                iodefv2_system_destroy(ptr->system);

        ptr->system = system;
}
/**
 * iodefv2_observable_new_system:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_system_t object.
 *
 * Create a new system object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_system_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_system(iodefv2_observable_t *ptr, iodefv2_system_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->system ) {
                retval = iodefv2_system_new(&ptr->system);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->system;
        return 0;
}




/**
 * iodefv2_observable_get_domain_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get domain_data children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_domain_data_t object, or NULL if the children object is not set.
 */
iodefv2_domain_data_t *iodefv2_observable_get_domain_data(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->domain_data;

}


/**
 * iodefv2_observable_set_domain_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @domain_data: pointer to a #iodefv2_domain_data_t object.
 *
 * Set @domain_data object as a children of @ptr.
 * if @ptr already contain an @domain_data object, then it is destroyed,
 * and updated to point to the provided @domain_data object.
 */

void iodefv2_observable_set_domain_data(iodefv2_observable_t *ptr, iodefv2_domain_data_t *domain_data)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->domain_data )
                iodefv2_domain_data_destroy(ptr->domain_data);

        ptr->domain_data = domain_data;
}
/**
 * iodefv2_observable_new_domain_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_domain_data_t object.
 *
 * Create a new domain_data object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_domain_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_domain_data(iodefv2_observable_t *ptr, iodefv2_domain_data_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->domain_data ) {
                retval = iodefv2_domain_data_new(&ptr->domain_data);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->domain_data;
        return 0;
}




/**
 * iodefv2_observable_get_email_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get email_data children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_email_data_t object, or NULL if the children object is not set.
 */
iodefv2_email_data_t *iodefv2_observable_get_email_data(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->email_data;

}


/**
 * iodefv2_observable_set_email_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @email_data: pointer to a #iodefv2_email_data_t object.
 *
 * Set @email_data object as a children of @ptr.
 * if @ptr already contain an @email_data object, then it is destroyed,
 * and updated to point to the provided @email_data object.
 */

void iodefv2_observable_set_email_data(iodefv2_observable_t *ptr, iodefv2_email_data_t *email_data)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->email_data )
                iodefv2_email_data_destroy(ptr->email_data);

        ptr->email_data = email_data;
}
/**
 * iodefv2_observable_new_email_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_email_data_t object.
 *
 * Create a new email_data object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_email_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_email_data(iodefv2_observable_t *ptr, iodefv2_email_data_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->email_data ) {
                retval = iodefv2_email_data_new(&ptr->email_data);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->email_data;
        return 0;
}




/**
 * iodefv2_observable_get_assessment:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get assessment children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_assessment_t object, or NULL if the children object is not set.
 */
iodefv2_assessment_t *iodefv2_observable_get_assessment(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->assessment;

}


/**
 * iodefv2_observable_set_assessment:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @assessment: pointer to a #iodefv2_assessment_t object.
 *
 * Set @assessment object as a children of @ptr.
 * if @ptr already contain an @assessment object, then it is destroyed,
 * and updated to point to the provided @assessment object.
 */

void iodefv2_observable_set_assessment(iodefv2_observable_t *ptr, iodefv2_assessment_t *assessment)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->assessment )
                iodefv2_assessment_destroy(ptr->assessment);

        ptr->assessment = assessment;
}
/**
 * iodefv2_observable_new_assessment:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_assessment_t object.
 *
 * Create a new assessment object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_assessment_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_assessment(iodefv2_observable_t *ptr, iodefv2_assessment_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->assessment ) {
                retval = iodefv2_assessment_new(&ptr->assessment);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->assessment;
        return 0;
}




/**
 * iodefv2_observable_get_record_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get record_data children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_record_data_t object, or NULL if the children object is not set.
 */
iodefv2_record_data_t *iodefv2_observable_get_record_data(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->record_data;

}


/**
 * iodefv2_observable_set_record_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @record_data: pointer to a #iodefv2_record_data_t object.
 *
 * Set @record_data object as a children of @ptr.
 * if @ptr already contain an @record_data object, then it is destroyed,
 * and updated to point to the provided @record_data object.
 */

void iodefv2_observable_set_record_data(iodefv2_observable_t *ptr, iodefv2_record_data_t *record_data)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->record_data )
                iodefv2_record_data_destroy(ptr->record_data);

        ptr->record_data = record_data;
}
/**
 * iodefv2_observable_new_record_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_record_data_t object.
 *
 * Create a new record_data object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_record_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_record_data(iodefv2_observable_t *ptr, iodefv2_record_data_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->record_data ) {
                retval = iodefv2_record_data_new(&ptr->record_data);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->record_data;
        return 0;
}




/**
 * iodefv2_observable_get_reference:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get reference children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_reference_t object, or NULL if the children object is not set.
 */
iodefv2_reference_t *iodefv2_observable_get_reference(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->reference;

}


/**
 * iodefv2_observable_set_reference:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @reference: pointer to a #iodefv2_reference_t object.
 *
 * Set @reference object as a children of @ptr.
 * if @ptr already contain an @reference object, then it is destroyed,
 * and updated to point to the provided @reference object.
 */

void iodefv2_observable_set_reference(iodefv2_observable_t *ptr, iodefv2_reference_t *reference)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->reference )
                iodefv2_reference_destroy(ptr->reference);

        ptr->reference = reference;
}
/**
 * iodefv2_observable_new_reference:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_reference_t object.
 *
 * Create a new reference object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_reference_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_reference(iodefv2_observable_t *ptr, iodefv2_reference_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->reference ) {
                retval = iodefv2_reference_new(&ptr->reference);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->reference;
        return 0;
}




/**
 * iodefv2_observable_get_history_item:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get history_item children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_history_item_t object, or NULL if the children object is not set.
 */
iodefv2_history_item_t *iodefv2_observable_get_history_item(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->history_item;

}


/**
 * iodefv2_observable_set_history_item:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @history_item: pointer to a #iodefv2_history_item_t object.
 *
 * Set @history_item object as a children of @ptr.
 * if @ptr already contain an @history_item object, then it is destroyed,
 * and updated to point to the provided @history_item object.
 */

void iodefv2_observable_set_history_item(iodefv2_observable_t *ptr, iodefv2_history_item_t *history_item)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->history_item )
                iodefv2_history_item_destroy(ptr->history_item);

        ptr->history_item = history_item;
}
/**
 * iodefv2_observable_new_history_item:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_history_item_t object.
 *
 * Create a new history_item object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_history_item_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_history_item(iodefv2_observable_t *ptr, iodefv2_history_item_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->history_item ) {
                retval = iodefv2_history_item_new(&ptr->history_item);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->history_item;
        return 0;
}




/**
 * iodefv2_observable_get_bulk_observable:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get bulk_observable children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_bulk_observable_t object, or NULL if the children object is not set.
 */
iodefv2_bulk_observable_t *iodefv2_observable_get_bulk_observable(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->bulk_observable;

}


/**
 * iodefv2_observable_set_bulk_observable:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @bulk_observable: pointer to a #iodefv2_bulk_observable_t object.
 *
 * Set @bulk_observable object as a children of @ptr.
 * if @ptr already contain an @bulk_observable object, then it is destroyed,
 * and updated to point to the provided @bulk_observable object.
 */

void iodefv2_observable_set_bulk_observable(iodefv2_observable_t *ptr, iodefv2_bulk_observable_t *bulk_observable)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->bulk_observable )
                iodefv2_bulk_observable_destroy(ptr->bulk_observable);

        ptr->bulk_observable = bulk_observable;
}
/**
 * iodefv2_observable_new_bulk_observable:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_bulk_observable_t object.
 *
 * Create a new bulk_observable object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_bulk_observable_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_bulk_observable(iodefv2_observable_t *ptr, iodefv2_bulk_observable_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->bulk_observable ) {
                retval = iodefv2_bulk_observable_new(&ptr->bulk_observable);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->bulk_observable;
        return 0;
}




/**
 * iodefv2_observable_get_certificate_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get certificate_data children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_certificate_data_t object, or NULL if the children object is not set.
 */
iodefv2_certificate_data_t *iodefv2_observable_get_certificate_data(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->certificate_data;

}


/**
 * iodefv2_observable_set_certificate_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @certificate_data: pointer to a #iodefv2_certificate_data_t object.
 *
 * Set @certificate_data object as a children of @ptr.
 * if @ptr already contain an @certificate_data object, then it is destroyed,
 * and updated to point to the provided @certificate_data object.
 */

void iodefv2_observable_set_certificate_data(iodefv2_observable_t *ptr, iodefv2_certificate_data_t *certificate_data)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->certificate_data )
                iodefv2_certificate_data_destroy(ptr->certificate_data);

        ptr->certificate_data = certificate_data;
}
/**
 * iodefv2_observable_new_certificate_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_certificate_data_t object.
 *
 * Create a new certificate_data object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_certificate_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_certificate_data(iodefv2_observable_t *ptr, iodefv2_certificate_data_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->certificate_data ) {
                retval = iodefv2_certificate_data_new(&ptr->certificate_data);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->certificate_data;
        return 0;
}




/**
 * iodefv2_observable_get_expectation:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get expectation children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_expectation_t object, or NULL if the children object is not set.
 */
iodefv2_expectation_t *iodefv2_observable_get_expectation(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->expectation;

}


/**
 * iodefv2_observable_set_expectation:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @expectation: pointer to a #iodefv2_expectation_t object.
 *
 * Set @expectation object as a children of @ptr.
 * if @ptr already contain an @expectation object, then it is destroyed,
 * and updated to point to the provided @expectation object.
 */

void iodefv2_observable_set_expectation(iodefv2_observable_t *ptr, iodefv2_expectation_t *expectation)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->expectation )
                iodefv2_expectation_destroy(ptr->expectation);

        ptr->expectation = expectation;
}
/**
 * iodefv2_observable_new_expectation:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_expectation_t object.
 *
 * Create a new expectation object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_expectation_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_expectation(iodefv2_observable_t *ptr, iodefv2_expectation_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->expectation ) {
                retval = iodefv2_expectation_new(&ptr->expectation);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->expectation;
        return 0;
}




/**
 * iodefv2_observable_get_windows_registry_keys_modified:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get windows_registry_keys_modified children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_windows_registry_keys_modified_t object, or NULL if the children object is not set.
 */
iodefv2_windows_registry_keys_modified_t *iodefv2_observable_get_windows_registry_keys_modified(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->windows_registry_keys_modified;

}


/**
 * iodefv2_observable_set_windows_registry_keys_modified:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @windows_registry_keys_modified: pointer to a #iodefv2_windows_registry_keys_modified_t object.
 *
 * Set @windows_registry_keys_modified object as a children of @ptr.
 * if @ptr already contain an @windows_registry_keys_modified object, then it is destroyed,
 * and updated to point to the provided @windows_registry_keys_modified object.
 */

void iodefv2_observable_set_windows_registry_keys_modified(iodefv2_observable_t *ptr, iodefv2_windows_registry_keys_modified_t *windows_registry_keys_modified)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->windows_registry_keys_modified )
                iodefv2_windows_registry_keys_modified_destroy(ptr->windows_registry_keys_modified);

        ptr->windows_registry_keys_modified = windows_registry_keys_modified;
}
/**
 * iodefv2_observable_new_windows_registry_keys_modified:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_windows_registry_keys_modified_t object.
 *
 * Create a new windows_registry_keys_modified object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_windows_registry_keys_modified_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_windows_registry_keys_modified(iodefv2_observable_t *ptr, iodefv2_windows_registry_keys_modified_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->windows_registry_keys_modified ) {
                retval = iodefv2_windows_registry_keys_modified_new(&ptr->windows_registry_keys_modified);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->windows_registry_keys_modified;
        return 0;
}




/**
 * iodefv2_observable_get_address:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get address children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_address_t object, or NULL if the children object is not set.
 */
iodefv2_address_t *iodefv2_observable_get_address(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->address;

}


/**
 * iodefv2_observable_set_address:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @address: pointer to a #iodefv2_address_t object.
 *
 * Set @address object as a children of @ptr.
 * if @ptr already contain an @address object, then it is destroyed,
 * and updated to point to the provided @address object.
 */

void iodefv2_observable_set_address(iodefv2_observable_t *ptr, iodefv2_address_t *address)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->address )
                iodefv2_address_destroy(ptr->address);

        ptr->address = address;
}
/**
 * iodefv2_observable_new_address:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_address_t object.
 *
 * Create a new address object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_address_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_address(iodefv2_observable_t *ptr, iodefv2_address_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->address ) {
                retval = iodefv2_address_new(&ptr->address);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->address;
        return 0;
}




/**
 * iodefv2_observable_get_event_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get event_data children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_event_data_t object, or NULL if the children object is not set.
 */
iodefv2_event_data_t *iodefv2_observable_get_event_data(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->event_data;

}


/**
 * iodefv2_observable_set_event_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @event_data: pointer to a #iodefv2_event_data_t object.
 *
 * Set @event_data object as a children of @ptr.
 * if @ptr already contain an @event_data object, then it is destroyed,
 * and updated to point to the provided @event_data object.
 */

void iodefv2_observable_set_event_data(iodefv2_observable_t *ptr, iodefv2_event_data_t *event_data)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->event_data )
                iodefv2_event_data_destroy(ptr->event_data);

        ptr->event_data = event_data;
}
/**
 * iodefv2_observable_new_event_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_event_data_t object.
 *
 * Create a new event_data object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_event_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_event_data(iodefv2_observable_t *ptr, iodefv2_event_data_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->event_data ) {
                retval = iodefv2_event_data_new(&ptr->event_data);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->event_data;
        return 0;
}




/**
 * iodefv2_observable_get_file_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get file_data children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_file_data_t object, or NULL if the children object is not set.
 */
iodefv2_file_data_t *iodefv2_observable_get_file_data(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->file_data;

}


/**
 * iodefv2_observable_set_file_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @file_data: pointer to a #iodefv2_file_data_t object.
 *
 * Set @file_data object as a children of @ptr.
 * if @ptr already contain an @file_data object, then it is destroyed,
 * and updated to point to the provided @file_data object.
 */

void iodefv2_observable_set_file_data(iodefv2_observable_t *ptr, iodefv2_file_data_t *file_data)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->file_data )
                iodefv2_file_data_destroy(ptr->file_data);

        ptr->file_data = file_data;
}
/**
 * iodefv2_observable_new_file_data:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_file_data_t object.
 *
 * Create a new file_data object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_file_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_file_data(iodefv2_observable_t *ptr, iodefv2_file_data_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->file_data ) {
                retval = iodefv2_file_data_new(&ptr->file_data);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->file_data;
        return 0;
}




/**
 * iodefv2_observable_get_registry_handle:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Get registry_handle children of the #iodefv2_observable_t object.
 *
 * Returns: a pointer to a iodefv2_registry_handle_t object, or NULL if the children object is not set.
 */
iodefv2_registry_handle_t *iodefv2_observable_get_registry_handle(iodefv2_observable_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->registry_handle;

}


/**
 * iodefv2_observable_set_registry_handle:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @registry_handle: pointer to a #iodefv2_registry_handle_t object.
 *
 * Set @registry_handle object as a children of @ptr.
 * if @ptr already contain an @registry_handle object, then it is destroyed,
 * and updated to point to the provided @registry_handle object.
 */

void iodefv2_observable_set_registry_handle(iodefv2_observable_t *ptr, iodefv2_registry_handle_t *registry_handle)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->registry_handle )
                iodefv2_registry_handle_destroy(ptr->registry_handle);

        ptr->registry_handle = registry_handle;
}
/**
 * iodefv2_observable_new_registry_handle:
 * @ptr: pointer to a #iodefv2_observable_t object.
 * @ret: pointer to an address where to store the created #iodefv2_registry_handle_t object.
 *
 * Create a new registry_handle object, children of #iodefv2_observable_t.
 * If @ptr already contain a #iodefv2_registry_handle_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_observable_new_registry_handle(iodefv2_observable_t *ptr, iodefv2_registry_handle_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->registry_handle ) {
                retval = iodefv2_registry_handle_new(&ptr->registry_handle);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->registry_handle;
        return 0;
}



/**
 * iodefv2_observable_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_observable_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_observable_copy(const iodefv2_observable_t *src, iodefv2_observable_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->detection_pattern ) {
                iodefv2_detection_pattern_destroy(dst->detection_pattern);
                dst->detection_pattern = NULL;
        }

        if ( src->detection_pattern ) {
                ret = iodefv2_detection_pattern_clone(src->detection_pattern, &dst->detection_pattern);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->service ) {
                iodefv2_service_destroy(dst->service);
                dst->service = NULL;
        }

        if ( src->service ) {
                ret = iodefv2_service_clone(src->service, &dst->service);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->system ) {
                iodefv2_system_destroy(dst->system);
                dst->system = NULL;
        }

        if ( src->system ) {
                ret = iodefv2_system_clone(src->system, &dst->system);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->domain_data ) {
                iodefv2_domain_data_destroy(dst->domain_data);
                dst->domain_data = NULL;
        }

        if ( src->domain_data ) {
                ret = iodefv2_domain_data_clone(src->domain_data, &dst->domain_data);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->email_data ) {
                iodefv2_email_data_destroy(dst->email_data);
                dst->email_data = NULL;
        }

        if ( src->email_data ) {
                ret = iodefv2_email_data_clone(src->email_data, &dst->email_data);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->assessment ) {
                iodefv2_assessment_destroy(dst->assessment);
                dst->assessment = NULL;
        }

        if ( src->assessment ) {
                ret = iodefv2_assessment_clone(src->assessment, &dst->assessment);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->record_data ) {
                iodefv2_record_data_destroy(dst->record_data);
                dst->record_data = NULL;
        }

        if ( src->record_data ) {
                ret = iodefv2_record_data_clone(src->record_data, &dst->record_data);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->reference ) {
                iodefv2_reference_destroy(dst->reference);
                dst->reference = NULL;
        }

        if ( src->reference ) {
                ret = iodefv2_reference_clone(src->reference, &dst->reference);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->history_item ) {
                iodefv2_history_item_destroy(dst->history_item);
                dst->history_item = NULL;
        }

        if ( src->history_item ) {
                ret = iodefv2_history_item_clone(src->history_item, &dst->history_item);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->bulk_observable ) {
                iodefv2_bulk_observable_destroy(dst->bulk_observable);
                dst->bulk_observable = NULL;
        }

        if ( src->bulk_observable ) {
                ret = iodefv2_bulk_observable_clone(src->bulk_observable, &dst->bulk_observable);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->certificate_data ) {
                iodefv2_certificate_data_destroy(dst->certificate_data);
                dst->certificate_data = NULL;
        }

        if ( src->certificate_data ) {
                ret = iodefv2_certificate_data_clone(src->certificate_data, &dst->certificate_data);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->expectation ) {
                iodefv2_expectation_destroy(dst->expectation);
                dst->expectation = NULL;
        }

        if ( src->expectation ) {
                ret = iodefv2_expectation_clone(src->expectation, &dst->expectation);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->windows_registry_keys_modified ) {
                iodefv2_windows_registry_keys_modified_destroy(dst->windows_registry_keys_modified);
                dst->windows_registry_keys_modified = NULL;
        }

        if ( src->windows_registry_keys_modified ) {
                ret = iodefv2_windows_registry_keys_modified_clone(src->windows_registry_keys_modified, &dst->windows_registry_keys_modified);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->address ) {
                iodefv2_address_destroy(dst->address);
                dst->address = NULL;
        }

        if ( src->address ) {
                ret = iodefv2_address_clone(src->address, &dst->address);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->event_data ) {
                iodefv2_event_data_destroy(dst->event_data);
                dst->event_data = NULL;
        }

        if ( src->event_data ) {
                ret = iodefv2_event_data_clone(src->event_data, &dst->event_data);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->file_data ) {
                iodefv2_file_data_destroy(dst->file_data);
                dst->file_data = NULL;
        }

        if ( src->file_data ) {
                ret = iodefv2_file_data_clone(src->file_data, &dst->file_data);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->registry_handle ) {
                iodefv2_registry_handle_destroy(dst->registry_handle);
                dst->registry_handle = NULL;
        }

        if ( src->registry_handle ) {
                ret = iodefv2_registry_handle_clone(src->registry_handle, &dst->registry_handle);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_observable_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_observable_clone(iodefv2_observable_t *src, iodefv2_observable_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_observable_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_observable_copy(src, *dst);
}


/**
 * iodefv2_observable_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_observable_compare(const iodefv2_observable_t *obj1, const iodefv2_observable_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_detection_pattern_compare(obj1->detection_pattern, obj2->detection_pattern);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_service_compare(obj1->service, obj2->service);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_system_compare(obj1->system, obj2->system);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_domain_data_compare(obj1->domain_data, obj2->domain_data);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_email_data_compare(obj1->email_data, obj2->email_data);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_assessment_compare(obj1->assessment, obj2->assessment);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_record_data_compare(obj1->record_data, obj2->record_data);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_reference_compare(obj1->reference, obj2->reference);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_history_item_compare(obj1->history_item, obj2->history_item);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_bulk_observable_compare(obj1->bulk_observable, obj2->bulk_observable);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_certificate_data_compare(obj1->certificate_data, obj2->certificate_data);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_expectation_compare(obj1->expectation, obj2->expectation);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_windows_registry_keys_modified_compare(obj1->windows_registry_keys_modified, obj2->windows_registry_keys_modified);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_address_compare(obj1->address, obj2->address);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_event_data_compare(obj1->event_data, obj2->event_data);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_file_data_compare(obj1->file_data, obj2->file_data);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_registry_handle_compare(obj1->registry_handle, obj2->registry_handle);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_indicator_expression_new:
 * @ret: Pointer where to store the created #iodefv2_indicator_expression_t object.
 *
 * Create a new #iodefv2_indicator_expression_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_indicator_expression_new(iodefv2_indicator_expression_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_INDICATOR_EXPRESSION;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->indicator_reference_list);


        libiodefv2_list_init(&(*ret)->observable_list);


        libiodefv2_list_init(&(*ret)->indicator_expression_list);


        libiodefv2_list_init(&(*ret)->additional_data_list);














            return 0;
}


/**
 * iodefv2_indicator_expression_ref:
 * @indicator_expression: pointer to a #iodefv2_indicator_expression_t object.
 *
 * Increase @indicator_expression reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @indicator_expression.
 */
iodefv2_indicator_expression_t *iodefv2_indicator_expression_ref(iodefv2_indicator_expression_t *indicator_expression)
{
        libiodefv2_return_val_if_fail(indicator_expression, NULL);
        indicator_expression->refcount++;

        return indicator_expression;
}



int _iodefv2_indicator_expression_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_indicator_expression_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->operator_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_INDICATOR_EXPRESSION_OPERATOR , ptr->operator);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_operator, TRUE);


            case 2:
                *childptr = &ptr->indicator_reference_list;
                return 0;

            case 3:
                *childptr = &ptr->observable_list;
                return 0;


            case 4:
                *childptr = ptr->confidence;
                return 0;

            case 5:
                *childptr = &ptr->indicator_expression_list;
                return 0;

            case 6:
                *childptr = &ptr->additional_data_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_indicator_expression_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_indicator_expression_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_indicator_expression_new_operator(ptr, (iodefv2_indicator_expression_operator_t **) ret);

                case 1:
                    return iodefv2_indicator_expression_new_ext_operator(ptr, (libiodefv2_string_t **) ret);

                case 2: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_indicator_expression_new_indicator_reference(ptr, (iodefv2_indicator_reference_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->indicator_reference_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->indicator_reference_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_indicator_expression_new_indicator_reference(ptr, (iodefv2_indicator_reference_t **) ret, n);
                }

                case 3: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_indicator_expression_new_observable(ptr, (iodefv2_observable_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->observable_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->observable_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_indicator_expression_new_observable(ptr, (iodefv2_observable_t **) ret, n);
                }

                case 4:
                    return iodefv2_indicator_expression_new_confidence(ptr, (iodefv2_confidence_t **) ret);

                case 5: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_indicator_expression_new_indicator_expression(ptr, (iodefv2_indicator_expression_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->indicator_expression_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->indicator_expression_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_indicator_expression_new_indicator_expression(ptr, (iodefv2_indicator_expression_t **) ret, n);
                }

                case 6: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_indicator_expression_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_indicator_expression_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_indicator_expression_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_indicator_expression_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->operator_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_operator ) {
                                libiodefv2_string_destroy(ptr->ext_operator);
                                ptr->ext_operator = NULL;
                        }

                        return 0;

    
                case 2: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->indicator_reference_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_indicator_reference_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->indicator_reference_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_indicator_reference_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 3: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->observable_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_observable_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->observable_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_observable_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 4:
                        if ( ptr->confidence ) {
                                iodefv2_confidence_destroy(ptr->confidence);
                                ptr->confidence = NULL;
                        }

                        return 0;

    
                case 5: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->indicator_expression_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_indicator_expression_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->indicator_expression_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_indicator_expression_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 6: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_indicator_expression_destroy_internal(iodefv2_indicator_expression_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_operator ) {
                libiodefv2_string_destroy(ptr->ext_operator);
                ptr->ext_operator = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_indicator_reference_t *entry;

                libiodefv2_list_for_each_safe(&ptr->indicator_reference_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_indicator_reference_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_observable_t *entry;

                libiodefv2_list_for_each_safe(&ptr->observable_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_observable_destroy(entry);
                }
        }


        if ( ptr->confidence ) {
                iodefv2_confidence_destroy(ptr->confidence);
                ptr->confidence = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_indicator_expression_t *entry;

                libiodefv2_list_for_each_safe(&ptr->indicator_expression_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_indicator_expression_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_indicator_expression_destroy:
 * @ptr: pointer to a #iodefv2_indicator_expression_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_indicator_expression_destroy(iodefv2_indicator_expression_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_indicator_expression_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_indicator_expression_get_operator:
 * @ptr: pointer to a #iodefv2_indicator_expression_t object.
 *
 * Get operator children of the #iodefv2_indicator_expression_t object.
 *
 * Returns: a pointer to a iodefv2_indicator_expression_operator_t object, or NULL if the children object is not set.
 */
iodefv2_indicator_expression_operator_t *iodefv2_indicator_expression_get_operator(iodefv2_indicator_expression_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->operator_is_set ? &ptr->operator : NULL;


}


/**
 * iodefv2_indicator_expression_set_operator:
 * @ptr: pointer to a #iodefv2_indicator_expression_t object.
 * @operator_indic: pointer to a #iodefv2_indicator_expression_operator_t object.
 *
 * Set @operator_indic object as a children of @ptr.
 * if @ptr already contain an @operator_indic object, then it is destroyed,
 * and updated to point to the provided @operator_indic object.
 */
void iodefv2_indicator_expression_set_operator(iodefv2_indicator_expression_t *ptr, iodefv2_indicator_expression_operator_t operator_indic)
{
        libiodefv2_return_if_fail(ptr);
        ptr->operator = operator_indic;
        ptr->operator_is_set = 1;
}

void iodefv2_indicator_expression_unset_operator(iodefv2_indicator_expression_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->operator_is_set = 0;
}
/**
 * iodefv2_indicator_expression_new_operator:
 * @ptr: pointer to a #iodefv2_indicator_expression_t object.
 * @ret: pointer to an address where to store the created #iodefv2_indicator_expression_operator_t object.
 *
 * Create a new operator object, children of #iodefv2_indicator_expression_t.
 * If @ptr already contain a #iodefv2_indicator_expression_operator_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_expression_new_operator(iodefv2_indicator_expression_t *ptr, iodefv2_indicator_expression_operator_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->operator_is_set = 1;



        *ret = &ptr->operator;
        return 0;
}




/**
 * iodefv2_indicator_expression_get_ext_operator:
 * @ptr: pointer to a #iodefv2_indicator_expression_t object.
 *
 * Get ext_operator children of the #iodefv2_indicator_expression_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_indicator_expression_get_ext_operator(iodefv2_indicator_expression_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_operator;

}


/**
 * iodefv2_indicator_expression_set_ext_operator:
 * @ptr: pointer to a #iodefv2_indicator_expression_t object.
 * @ext_operator: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_operator object as a children of @ptr.
 * if @ptr already contain an @ext_operator object, then it is destroyed,
 * and updated to point to the provided @ext_operator object.
 */

void iodefv2_indicator_expression_set_ext_operator(iodefv2_indicator_expression_t *ptr, libiodefv2_string_t *ext_operator)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_operator )
                libiodefv2_string_destroy(ptr->ext_operator);

        ptr->ext_operator = ext_operator;
}
/**
 * iodefv2_indicator_expression_new_ext_operator:
 * @ptr: pointer to a #iodefv2_indicator_expression_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_operator object, children of #iodefv2_indicator_expression_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_expression_new_ext_operator(iodefv2_indicator_expression_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_operator ) {
                retval = libiodefv2_string_new(&ptr->ext_operator);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_operator;
        return 0;
}





/**
 * iodefv2_indicator_expression_get_next_indicator_reference:
 * @indicator_expression: pointer to a #iodefv2_indicator_expression_t object.
 * @indicator_reference_cur: pointer to a #iodefv2_indicator_reference_t object.
 *
 * Get the next #iodefv2_indicator_reference_t object listed in @ptr.
 * When iterating over the iodefv2_indicator_reference_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_indicator_reference_t object.
 *
 * Returns: the next #iodefv2_indicator_reference_t in the list.
 */
iodefv2_indicator_reference_t *iodefv2_indicator_expression_get_next_indicator_reference(iodefv2_indicator_expression_t *indicator_expression, iodefv2_indicator_reference_t *indicator_reference_cur)
{
        libiodefv2_list_t *tmp = (indicator_reference_cur) ? &((libiodefv2_linked_object_t *) indicator_reference_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(indicator_expression, NULL);

        libiodefv2_list_for_each_continue(&indicator_expression->indicator_reference_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_indicator_expression_set_indicator_reference:
 * @ptr: pointer to a #iodefv2_indicator_expression_t object.
 * @object: pointer to a #iodefv2_indicator_reference_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_indicator_reference_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_indicator_expression_set_indicator_reference(iodefv2_indicator_expression_t *ptr, iodefv2_indicator_reference_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->indicator_reference_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_indicator_expression_new_indicator_reference:
 *  @ptr: pointer to a #iodefv2_indicator_expression_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_indicator_reference_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_indicator_reference_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_indicator_reference_t object. The created #iodefv2_indicator_reference_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_expression_new_indicator_reference(iodefv2_indicator_expression_t *ptr, iodefv2_indicator_reference_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_indicator_reference_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->indicator_reference_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_indicator_expression_get_next_observable:
 * @indicator_expression: pointer to a #iodefv2_indicator_expression_t object.
 * @observable_cur: pointer to a #iodefv2_observable_t object.
 *
 * Get the next #iodefv2_observable_t object listed in @ptr.
 * When iterating over the iodefv2_observable_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_observable_t object.
 *
 * Returns: the next #iodefv2_observable_t in the list.
 */
iodefv2_observable_t *iodefv2_indicator_expression_get_next_observable(iodefv2_indicator_expression_t *indicator_expression, iodefv2_observable_t *observable_cur)
{
        libiodefv2_list_t *tmp = (observable_cur) ? &((libiodefv2_linked_object_t *) observable_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(indicator_expression, NULL);

        libiodefv2_list_for_each_continue(&indicator_expression->observable_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_indicator_expression_set_observable:
 * @ptr: pointer to a #iodefv2_indicator_expression_t object.
 * @object: pointer to a #iodefv2_observable_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_observable_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_indicator_expression_set_observable(iodefv2_indicator_expression_t *ptr, iodefv2_observable_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->observable_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_indicator_expression_new_observable:
 *  @ptr: pointer to a #iodefv2_indicator_expression_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_observable_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_observable_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_observable_t object. The created #iodefv2_observable_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_expression_new_observable(iodefv2_indicator_expression_t *ptr, iodefv2_observable_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_observable_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->observable_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_indicator_expression_get_confidence:
 * @ptr: pointer to a #iodefv2_indicator_expression_t object.
 *
 * Get confidence children of the #iodefv2_indicator_expression_t object.
 *
 * Returns: a pointer to a iodefv2_confidence_t object, or NULL if the children object is not set.
 */
iodefv2_confidence_t *iodefv2_indicator_expression_get_confidence(iodefv2_indicator_expression_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->confidence;

}


/**
 * iodefv2_indicator_expression_set_confidence:
 * @ptr: pointer to a #iodefv2_indicator_expression_t object.
 * @confidence: pointer to a #iodefv2_confidence_t object.
 *
 * Set @confidence object as a children of @ptr.
 * if @ptr already contain an @confidence object, then it is destroyed,
 * and updated to point to the provided @confidence object.
 */

void iodefv2_indicator_expression_set_confidence(iodefv2_indicator_expression_t *ptr, iodefv2_confidence_t *confidence)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->confidence )
                iodefv2_confidence_destroy(ptr->confidence);

        ptr->confidence = confidence;
}
/**
 * iodefv2_indicator_expression_new_confidence:
 * @ptr: pointer to a #iodefv2_indicator_expression_t object.
 * @ret: pointer to an address where to store the created #iodefv2_confidence_t object.
 *
 * Create a new confidence object, children of #iodefv2_indicator_expression_t.
 * If @ptr already contain a #iodefv2_confidence_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_expression_new_confidence(iodefv2_indicator_expression_t *ptr, iodefv2_confidence_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->confidence ) {
                retval = iodefv2_confidence_new(&ptr->confidence);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->confidence;
        return 0;
}





/**
 * iodefv2_indicator_expression_get_next_indicator_expression:
 * @indicator_expression: pointer to a #iodefv2_indicator_expression_t object.
 * @indicator_expression_cur: pointer to a #iodefv2_indicator_expression_t object.
 *
 * Get the next #iodefv2_indicator_expression_t object listed in @ptr.
 * When iterating over the iodefv2_indicator_expression_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_indicator_expression_t object.
 *
 * Returns: the next #iodefv2_indicator_expression_t in the list.
 */
iodefv2_indicator_expression_t *iodefv2_indicator_expression_get_next_indicator_expression(iodefv2_indicator_expression_t *indicator_expression, iodefv2_indicator_expression_t *indicator_expression_cur)
{
        libiodefv2_list_t *tmp = (indicator_expression_cur) ? &((libiodefv2_linked_object_t *) indicator_expression_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(indicator_expression, NULL);

        libiodefv2_list_for_each_continue(&indicator_expression->indicator_expression_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_indicator_expression_set_indicator_expression:
 * @ptr: pointer to a #iodefv2_indicator_expression_t object.
 * @object: pointer to a #iodefv2_indicator_expression_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_indicator_expression_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_indicator_expression_set_indicator_expression(iodefv2_indicator_expression_t *ptr, iodefv2_indicator_expression_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->indicator_expression_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_indicator_expression_new_indicator_expression:
 *  @ptr: pointer to a #iodefv2_indicator_expression_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_indicator_expression_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_indicator_expression_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_indicator_expression_t object. The created #iodefv2_indicator_expression_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_expression_new_indicator_expression(iodefv2_indicator_expression_t *ptr, iodefv2_indicator_expression_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_indicator_expression_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->indicator_expression_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_indicator_expression_get_next_additional_data:
 * @indicator_expression: pointer to a #iodefv2_indicator_expression_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_indicator_expression_get_next_additional_data(iodefv2_indicator_expression_t *indicator_expression, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(indicator_expression, NULL);

        libiodefv2_list_for_each_continue(&indicator_expression->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_indicator_expression_set_additional_data:
 * @ptr: pointer to a #iodefv2_indicator_expression_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_indicator_expression_set_additional_data(iodefv2_indicator_expression_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_indicator_expression_new_additional_data:
 *  @ptr: pointer to a #iodefv2_indicator_expression_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_expression_new_additional_data(iodefv2_indicator_expression_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_indicator_expression_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_indicator_expression_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_indicator_expression_copy(const iodefv2_indicator_expression_t *src, iodefv2_indicator_expression_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->operator_is_set = src->operator_is_set;
        dst->operator = src->operator;



        if ( dst->ext_operator ) {
                libiodefv2_string_destroy(dst->ext_operator);
                dst->ext_operator = NULL;
        }

        if ( src->ext_operator ) {
                ret = libiodefv2_string_clone(src->ext_operator, &dst->ext_operator);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_indicator_reference_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->indicator_reference_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_indicator_reference_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->indicator_reference_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_indicator_reference_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->indicator_reference_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_observable_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->observable_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_observable_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->observable_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_observable_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->observable_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->confidence ) {
                iodefv2_confidence_destroy(dst->confidence);
                dst->confidence = NULL;
        }

        if ( src->confidence ) {
                ret = iodefv2_confidence_clone(src->confidence, &dst->confidence);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_indicator_expression_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->indicator_expression_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_indicator_expression_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->indicator_expression_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_indicator_expression_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->indicator_expression_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_indicator_expression_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_indicator_expression_clone(iodefv2_indicator_expression_t *src, iodefv2_indicator_expression_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_indicator_expression_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_indicator_expression_copy(src, *dst);
}


/**
 * iodefv2_indicator_expression_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_indicator_expression_compare(const iodefv2_indicator_expression_t *obj1, const iodefv2_indicator_expression_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->operator_is_set != obj2->operator_is_set )
                return -1;

        if ( obj1->operator_is_set && obj1->operator != obj2->operator )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_operator, obj2->ext_operator);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_indicator_reference_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->indicator_reference_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->indicator_reference_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_indicator_reference_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_observable_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->observable_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->observable_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_observable_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_confidence_compare(obj1->confidence, obj2->confidence);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_indicator_expression_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->indicator_expression_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->indicator_expression_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_indicator_expression_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_indicator_new:
 * @ret: Pointer where to store the created #iodefv2_indicator_t object.
 *
 * Create a new #iodefv2_indicator_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_indicator_new(iodefv2_indicator_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_INDICATOR;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->alternative_indicator_id_list);


        libiodefv2_list_init(&(*ret)->reference_list);


        libiodefv2_list_init(&(*ret)->additional_data_list);


        libiodefv2_list_init(&(*ret)->contact_list);


        libiodefv2_list_init(&(*ret)->node_role_list);


        libiodefv2_list_init(&(*ret)->attack_phase_list);























        {
            int retval = iodefv2_indicator_id_new(&(*ret)->indicator_id);

            if ( retval < 0 ) {
                    iodefv2_indicator_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }







            return 0;
}


/**
 * iodefv2_indicator_ref:
 * @indicator: pointer to a #iodefv2_indicator_t object.
 *
 * Increase @indicator reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @indicator.
 */
iodefv2_indicator_t *iodefv2_indicator_ref(iodefv2_indicator_t *indicator)
{
        libiodefv2_return_val_if_fail(indicator, NULL);
        indicator->refcount++;

        return indicator;
}



int _iodefv2_indicator_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_indicator_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_INDICATOR_RESTRICTION , ptr->restriction);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_restriction, TRUE);


            case 2:
                *childptr = &ptr->alternative_indicator_id_list;
                return 0;


            case 3:
                *childptr = ptr->confidence;
                return 0;

            case 4:
                *childptr = &ptr->reference_list;
                return 0;


            case 5:
                *childptr = ptr->observable;
                return 0;

            case 6:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 7:
                *childptr = ptr->indicator_expression;
                return 0;

            case 8:
                *childptr = &ptr->contact_list;
                return 0;

            case 9:
                *childptr = &ptr->node_role_list;
                return 0;


            case 10:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->start_time, TRUE);



            case 11:
                *childptr = ptr->indicator_id;
                return 0;


            case 12:
                *childptr = ptr->indicator_reference;
                return 0;


            case 13:
                *childptr = ptr->observable_reference;
                return 0;

            case 14:
                *childptr = &ptr->attack_phase_list;
                return 0;


            case 15:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->end_time, TRUE);


            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_indicator_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_indicator_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_indicator_new_restriction(ptr, (iodefv2_indicator_restriction_t **) ret);

                case 1:
                    return iodefv2_indicator_new_ext_restriction(ptr, (libiodefv2_string_t **) ret);

                case 2: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_indicator_new_alternative_indicator_id(ptr, (iodefv2_alternative_indicator_id_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->alternative_indicator_id_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->alternative_indicator_id_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_indicator_new_alternative_indicator_id(ptr, (iodefv2_alternative_indicator_id_t **) ret, n);
                }

                case 3:
                    return iodefv2_indicator_new_confidence(ptr, (iodefv2_confidence_t **) ret);

                case 4: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_indicator_new_reference(ptr, (iodefv2_reference_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->reference_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->reference_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_indicator_new_reference(ptr, (iodefv2_reference_t **) ret, n);
                }

                case 5:
                    return iodefv2_indicator_new_observable(ptr, (iodefv2_observable_t **) ret);

                case 6: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_indicator_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_indicator_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 7:
                    return iodefv2_indicator_new_indicator_expression(ptr, (iodefv2_indicator_expression_t **) ret);

                case 8: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_indicator_new_contact(ptr, (iodefv2_contact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->contact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->contact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_indicator_new_contact(ptr, (iodefv2_contact_t **) ret, n);
                }

                case 9: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_indicator_new_node_role(ptr, (iodefv2_node_role_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->node_role_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->node_role_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_indicator_new_node_role(ptr, (iodefv2_node_role_t **) ret, n);
                }

                case 10:
                    return iodefv2_indicator_new_start_time(ptr, (iodefv2_time_t **) ret);

                case 11:
                    return iodefv2_indicator_new_indicator_id(ptr, (iodefv2_indicator_id_t **) ret);

                case 12:
                    return iodefv2_indicator_new_indicator_reference(ptr, (iodefv2_indicator_reference_t **) ret);

                case 13:
                    return iodefv2_indicator_new_observable_reference(ptr, (iodefv2_observable_reference_t **) ret);

                case 14: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_indicator_new_attack_phase(ptr, (iodefv2_attack_phase_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->attack_phase_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->attack_phase_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_indicator_new_attack_phase(ptr, (iodefv2_attack_phase_t **) ret, n);
                }

                case 15:
                    return iodefv2_indicator_new_end_time(ptr, (iodefv2_time_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_indicator_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_indicator_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 1:
                        if ( ptr->ext_restriction ) {
                                libiodefv2_string_destroy(ptr->ext_restriction);
                                ptr->ext_restriction = NULL;
                        }

                        return 0;

    
                case 2: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->alternative_indicator_id_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_alternative_indicator_id_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->alternative_indicator_id_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_alternative_indicator_id_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 3:
                        if ( ptr->confidence ) {
                                iodefv2_confidence_destroy(ptr->confidence);
                                ptr->confidence = NULL;
                        }

                        return 0;

    
                case 4: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->reference_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_reference_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->reference_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_reference_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 5:
                        if ( ptr->observable ) {
                                iodefv2_observable_destroy(ptr->observable);
                                ptr->observable = NULL;
                        }

                        return 0;

    
                case 6: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 7:
                        if ( ptr->indicator_expression ) {
                                iodefv2_indicator_expression_destroy(ptr->indicator_expression);
                                ptr->indicator_expression = NULL;
                        }

                        return 0;

    
                case 8: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->contact_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_contact_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->contact_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_contact_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 9: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->node_role_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_node_role_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->node_role_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_node_role_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 10:
                        if ( ptr->start_time ) {
                                iodefv2_time_destroy(ptr->start_time);
                                ptr->start_time = NULL;
                        }

                        return 0;




                case 11:
                        if ( ptr->indicator_id ) {
                                iodefv2_indicator_id_destroy(ptr->indicator_id);
                                ptr->indicator_id = NULL;
                        }

                        return 0;




                case 12:
                        if ( ptr->indicator_reference ) {
                                iodefv2_indicator_reference_destroy(ptr->indicator_reference);
                                ptr->indicator_reference = NULL;
                        }

                        return 0;




                case 13:
                        if ( ptr->observable_reference ) {
                                iodefv2_observable_reference_destroy(ptr->observable_reference);
                                ptr->observable_reference = NULL;
                        }

                        return 0;

    
                case 14: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->attack_phase_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_attack_phase_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->attack_phase_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_attack_phase_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 15:
                        if ( ptr->end_time ) {
                                iodefv2_time_destroy(ptr->end_time);
                                ptr->end_time = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_indicator_destroy_internal(iodefv2_indicator_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);



        if ( ptr->ext_restriction ) {
                libiodefv2_string_destroy(ptr->ext_restriction);
                ptr->ext_restriction = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_alternative_indicator_id_t *entry;

                libiodefv2_list_for_each_safe(&ptr->alternative_indicator_id_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_alternative_indicator_id_destroy(entry);
                }
        }


        if ( ptr->confidence ) {
                iodefv2_confidence_destroy(ptr->confidence);
                ptr->confidence = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_reference_t *entry;

                libiodefv2_list_for_each_safe(&ptr->reference_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_reference_destroy(entry);
                }
        }


        if ( ptr->observable ) {
                iodefv2_observable_destroy(ptr->observable);
                ptr->observable = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }


        if ( ptr->indicator_expression ) {
                iodefv2_indicator_expression_destroy(ptr->indicator_expression);
                ptr->indicator_expression = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_contact_t *entry;

                libiodefv2_list_for_each_safe(&ptr->contact_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_contact_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_node_role_t *entry;

                libiodefv2_list_for_each_safe(&ptr->node_role_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_node_role_destroy(entry);
                }
        }

        if ( ptr->start_time ) {
                iodefv2_time_destroy(ptr->start_time);
                ptr->start_time = NULL;
        }




        if ( ptr->indicator_id ) {
                iodefv2_indicator_id_destroy(ptr->indicator_id);
                ptr->indicator_id = NULL;
        }




        if ( ptr->indicator_reference ) {
                iodefv2_indicator_reference_destroy(ptr->indicator_reference);
                ptr->indicator_reference = NULL;
        }




        if ( ptr->observable_reference ) {
                iodefv2_observable_reference_destroy(ptr->observable_reference);
                ptr->observable_reference = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_attack_phase_t *entry;

                libiodefv2_list_for_each_safe(&ptr->attack_phase_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_attack_phase_destroy(entry);
                }
        }

        if ( ptr->end_time ) {
                iodefv2_time_destroy(ptr->end_time);
                ptr->end_time = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_indicator_destroy:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_indicator_destroy(iodefv2_indicator_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_indicator_destroy_internal(ptr);
        free(ptr);
}





/**
 * iodefv2_indicator_get_restriction:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 *
 * Get restriction children of the #iodefv2_indicator_t object.
 *
 * Returns: a pointer to a iodefv2_indicator_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_indicator_restriction_t *iodefv2_indicator_get_restriction(iodefv2_indicator_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_indicator_set_restriction:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @restriction: pointer to a #iodefv2_indicator_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_indicator_set_restriction(iodefv2_indicator_t *ptr, iodefv2_indicator_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_indicator_unset_restriction(iodefv2_indicator_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_indicator_new_restriction:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @ret: pointer to an address where to store the created #iodefv2_indicator_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_indicator_t.
 * If @ptr already contain a #iodefv2_indicator_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_restriction(iodefv2_indicator_t *ptr, iodefv2_indicator_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_indicator_get_ext_restriction:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 *
 * Get ext_restriction children of the #iodefv2_indicator_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_indicator_get_ext_restriction(iodefv2_indicator_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_restriction;

}


/**
 * iodefv2_indicator_set_ext_restriction:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @ext_restriction: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_restriction object as a children of @ptr.
 * if @ptr already contain an @ext_restriction object, then it is destroyed,
 * and updated to point to the provided @ext_restriction object.
 */

void iodefv2_indicator_set_ext_restriction(iodefv2_indicator_t *ptr, libiodefv2_string_t *ext_restriction)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_restriction )
                libiodefv2_string_destroy(ptr->ext_restriction);

        ptr->ext_restriction = ext_restriction;
}
/**
 * iodefv2_indicator_new_ext_restriction:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_restriction object, children of #iodefv2_indicator_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_ext_restriction(iodefv2_indicator_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_restriction ) {
                retval = libiodefv2_string_new(&ptr->ext_restriction);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_restriction;
        return 0;
}





/**
 * iodefv2_indicator_get_next_alternative_indicator_id:
 * @indicator: pointer to a #iodefv2_indicator_t object.
 * @alternative_indicator_id_cur: pointer to a #iodefv2_alternative_indicator_id_t object.
 *
 * Get the next #iodefv2_alternative_indicator_id_t object listed in @ptr.
 * When iterating over the iodefv2_alternative_indicator_id_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_alternative_indicator_id_t object.
 *
 * Returns: the next #iodefv2_alternative_indicator_id_t in the list.
 */
iodefv2_alternative_indicator_id_t *iodefv2_indicator_get_next_alternative_indicator_id(iodefv2_indicator_t *indicator, iodefv2_alternative_indicator_id_t *alternative_indicator_id_cur)
{
        libiodefv2_list_t *tmp = (alternative_indicator_id_cur) ? &((libiodefv2_linked_object_t *) alternative_indicator_id_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(indicator, NULL);

        libiodefv2_list_for_each_continue(&indicator->alternative_indicator_id_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_indicator_set_alternative_indicator_id:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @object: pointer to a #iodefv2_alternative_indicator_id_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_alternative_indicator_id_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_indicator_set_alternative_indicator_id(iodefv2_indicator_t *ptr, iodefv2_alternative_indicator_id_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->alternative_indicator_id_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_indicator_new_alternative_indicator_id:
 *  @ptr: pointer to a #iodefv2_indicator_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_alternative_indicator_id_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_alternative_indicator_id_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_alternative_indicator_id_t object. The created #iodefv2_alternative_indicator_id_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_alternative_indicator_id(iodefv2_indicator_t *ptr, iodefv2_alternative_indicator_id_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_alternative_indicator_id_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->alternative_indicator_id_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_indicator_get_confidence:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 *
 * Get confidence children of the #iodefv2_indicator_t object.
 *
 * Returns: a pointer to a iodefv2_confidence_t object, or NULL if the children object is not set.
 */
iodefv2_confidence_t *iodefv2_indicator_get_confidence(iodefv2_indicator_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->confidence;

}


/**
 * iodefv2_indicator_set_confidence:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @confidence: pointer to a #iodefv2_confidence_t object.
 *
 * Set @confidence object as a children of @ptr.
 * if @ptr already contain an @confidence object, then it is destroyed,
 * and updated to point to the provided @confidence object.
 */

void iodefv2_indicator_set_confidence(iodefv2_indicator_t *ptr, iodefv2_confidence_t *confidence)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->confidence )
                iodefv2_confidence_destroy(ptr->confidence);

        ptr->confidence = confidence;
}
/**
 * iodefv2_indicator_new_confidence:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @ret: pointer to an address where to store the created #iodefv2_confidence_t object.
 *
 * Create a new confidence object, children of #iodefv2_indicator_t.
 * If @ptr already contain a #iodefv2_confidence_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_confidence(iodefv2_indicator_t *ptr, iodefv2_confidence_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->confidence ) {
                retval = iodefv2_confidence_new(&ptr->confidence);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->confidence;
        return 0;
}





/**
 * iodefv2_indicator_get_next_reference:
 * @indicator: pointer to a #iodefv2_indicator_t object.
 * @reference_cur: pointer to a #iodefv2_reference_t object.
 *
 * Get the next #iodefv2_reference_t object listed in @ptr.
 * When iterating over the iodefv2_reference_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_reference_t object.
 *
 * Returns: the next #iodefv2_reference_t in the list.
 */
iodefv2_reference_t *iodefv2_indicator_get_next_reference(iodefv2_indicator_t *indicator, iodefv2_reference_t *reference_cur)
{
        libiodefv2_list_t *tmp = (reference_cur) ? &((libiodefv2_linked_object_t *) reference_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(indicator, NULL);

        libiodefv2_list_for_each_continue(&indicator->reference_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_indicator_set_reference:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @object: pointer to a #iodefv2_reference_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_reference_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_indicator_set_reference(iodefv2_indicator_t *ptr, iodefv2_reference_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->reference_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_indicator_new_reference:
 *  @ptr: pointer to a #iodefv2_indicator_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_reference_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_reference_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_reference_t object. The created #iodefv2_reference_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_reference(iodefv2_indicator_t *ptr, iodefv2_reference_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_reference_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->reference_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_indicator_get_observable:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 *
 * Get observable children of the #iodefv2_indicator_t object.
 *
 * Returns: a pointer to a iodefv2_observable_t object, or NULL if the children object is not set.
 */
iodefv2_observable_t *iodefv2_indicator_get_observable(iodefv2_indicator_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable;

}


/**
 * iodefv2_indicator_set_observable:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @observable: pointer to a #iodefv2_observable_t object.
 *
 * Set @observable object as a children of @ptr.
 * if @ptr already contain an @observable object, then it is destroyed,
 * and updated to point to the provided @observable object.
 */

void iodefv2_indicator_set_observable(iodefv2_indicator_t *ptr, iodefv2_observable_t *observable)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable )
                iodefv2_observable_destroy(ptr->observable);

        ptr->observable = observable;
}
/**
 * iodefv2_indicator_new_observable:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @ret: pointer to an address where to store the created #iodefv2_observable_t object.
 *
 * Create a new observable object, children of #iodefv2_indicator_t.
 * If @ptr already contain a #iodefv2_observable_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_observable(iodefv2_indicator_t *ptr, iodefv2_observable_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable ) {
                retval = iodefv2_observable_new(&ptr->observable);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable;
        return 0;
}





/**
 * iodefv2_indicator_get_next_additional_data:
 * @indicator: pointer to a #iodefv2_indicator_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_indicator_get_next_additional_data(iodefv2_indicator_t *indicator, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(indicator, NULL);

        libiodefv2_list_for_each_continue(&indicator->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_indicator_set_additional_data:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_indicator_set_additional_data(iodefv2_indicator_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_indicator_new_additional_data:
 *  @ptr: pointer to a #iodefv2_indicator_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_additional_data(iodefv2_indicator_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_indicator_get_indicator_expression:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 *
 * Get indicator_expression children of the #iodefv2_indicator_t object.
 *
 * Returns: a pointer to a iodefv2_indicator_expression_t object, or NULL if the children object is not set.
 */
iodefv2_indicator_expression_t *iodefv2_indicator_get_indicator_expression(iodefv2_indicator_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->indicator_expression;

}


/**
 * iodefv2_indicator_set_indicator_expression:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @indicator_expression: pointer to a #iodefv2_indicator_expression_t object.
 *
 * Set @indicator_expression object as a children of @ptr.
 * if @ptr already contain an @indicator_expression object, then it is destroyed,
 * and updated to point to the provided @indicator_expression object.
 */

void iodefv2_indicator_set_indicator_expression(iodefv2_indicator_t *ptr, iodefv2_indicator_expression_t *indicator_expression)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->indicator_expression )
                iodefv2_indicator_expression_destroy(ptr->indicator_expression);

        ptr->indicator_expression = indicator_expression;
}
/**
 * iodefv2_indicator_new_indicator_expression:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @ret: pointer to an address where to store the created #iodefv2_indicator_expression_t object.
 *
 * Create a new indicator_expression object, children of #iodefv2_indicator_t.
 * If @ptr already contain a #iodefv2_indicator_expression_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_indicator_expression(iodefv2_indicator_t *ptr, iodefv2_indicator_expression_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->indicator_expression ) {
                retval = iodefv2_indicator_expression_new(&ptr->indicator_expression);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->indicator_expression;
        return 0;
}





/**
 * iodefv2_indicator_get_next_contact:
 * @indicator: pointer to a #iodefv2_indicator_t object.
 * @contact_cur: pointer to a #iodefv2_contact_t object.
 *
 * Get the next #iodefv2_contact_t object listed in @ptr.
 * When iterating over the iodefv2_contact_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_contact_t object.
 *
 * Returns: the next #iodefv2_contact_t in the list.
 */
iodefv2_contact_t *iodefv2_indicator_get_next_contact(iodefv2_indicator_t *indicator, iodefv2_contact_t *contact_cur)
{
        libiodefv2_list_t *tmp = (contact_cur) ? &((libiodefv2_linked_object_t *) contact_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(indicator, NULL);

        libiodefv2_list_for_each_continue(&indicator->contact_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_indicator_set_contact:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @object: pointer to a #iodefv2_contact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_contact_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_indicator_set_contact(iodefv2_indicator_t *ptr, iodefv2_contact_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->contact_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_indicator_new_contact:
 *  @ptr: pointer to a #iodefv2_indicator_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_contact_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_contact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_contact_t object. The created #iodefv2_contact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_contact(iodefv2_indicator_t *ptr, iodefv2_contact_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_contact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->contact_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_indicator_get_next_node_role:
 * @indicator: pointer to a #iodefv2_indicator_t object.
 * @node_role_cur: pointer to a #iodefv2_node_role_t object.
 *
 * Get the next #iodefv2_node_role_t object listed in @ptr.
 * When iterating over the iodefv2_node_role_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_node_role_t object.
 *
 * Returns: the next #iodefv2_node_role_t in the list.
 */
iodefv2_node_role_t *iodefv2_indicator_get_next_node_role(iodefv2_indicator_t *indicator, iodefv2_node_role_t *node_role_cur)
{
        libiodefv2_list_t *tmp = (node_role_cur) ? &((libiodefv2_linked_object_t *) node_role_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(indicator, NULL);

        libiodefv2_list_for_each_continue(&indicator->node_role_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_indicator_set_node_role:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @object: pointer to a #iodefv2_node_role_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_node_role_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_indicator_set_node_role(iodefv2_indicator_t *ptr, iodefv2_node_role_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->node_role_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_indicator_new_node_role:
 *  @ptr: pointer to a #iodefv2_indicator_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_node_role_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_node_role_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_node_role_t object. The created #iodefv2_node_role_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_node_role(iodefv2_indicator_t *ptr, iodefv2_node_role_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_node_role_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->node_role_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_indicator_get_start_time:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 *
 * Get start_time children of the #iodefv2_indicator_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_indicator_get_start_time(iodefv2_indicator_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->start_time;

}


/**
 * iodefv2_indicator_set_start_time:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @start_time: pointer to a #iodefv2_time_t object.
 *
 * Set @start_time object as a children of @ptr.
 * if @ptr already contain an @start_time object, then it is destroyed,
 * and updated to point to the provided @start_time object.
 */

void iodefv2_indicator_set_start_time(iodefv2_indicator_t *ptr, iodefv2_time_t *start_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->start_time )
                iodefv2_time_destroy(ptr->start_time);

        ptr->start_time = start_time;
}
/**
 * iodefv2_indicator_new_start_time:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new start_time object, children of #iodefv2_indicator_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_start_time(iodefv2_indicator_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->start_time ) {
                retval = iodefv2_time_new(&ptr->start_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->start_time;
        return 0;
}




/**
 * iodefv2_indicator_get_indicator_id:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 *
 * Get indicator_id children of the #iodefv2_indicator_t object.
 *
 * Returns: a pointer to a iodefv2_indicator_id_t object, or NULL if the children object is not set.
 */
iodefv2_indicator_id_t *iodefv2_indicator_get_indicator_id(iodefv2_indicator_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->indicator_id;

}


/**
 * iodefv2_indicator_set_indicator_id:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @indicator_id: pointer to a #iodefv2_indicator_id_t object.
 *
 * Set @indicator_id object as a children of @ptr.
 * if @ptr already contain an @indicator_id object, then it is destroyed,
 * and updated to point to the provided @indicator_id object.
 */

void iodefv2_indicator_set_indicator_id(iodefv2_indicator_t *ptr, iodefv2_indicator_id_t *indicator_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->indicator_id )
                iodefv2_indicator_id_destroy(ptr->indicator_id);

        ptr->indicator_id = indicator_id;
}
/**
 * iodefv2_indicator_new_indicator_id:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @ret: pointer to an address where to store the created #iodefv2_indicator_id_t object.
 *
 * Create a new indicator_id object, children of #iodefv2_indicator_t.
 * If @ptr already contain a #iodefv2_indicator_id_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_indicator_id(iodefv2_indicator_t *ptr, iodefv2_indicator_id_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->indicator_id ) {
                retval = iodefv2_indicator_id_new(&ptr->indicator_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->indicator_id;
        return 0;
}




/**
 * iodefv2_indicator_get_indicator_reference:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 *
 * Get indicator_reference children of the #iodefv2_indicator_t object.
 *
 * Returns: a pointer to a iodefv2_indicator_reference_t object, or NULL if the children object is not set.
 */
iodefv2_indicator_reference_t *iodefv2_indicator_get_indicator_reference(iodefv2_indicator_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->indicator_reference;

}


/**
 * iodefv2_indicator_set_indicator_reference:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @indicator_reference: pointer to a #iodefv2_indicator_reference_t object.
 *
 * Set @indicator_reference object as a children of @ptr.
 * if @ptr already contain an @indicator_reference object, then it is destroyed,
 * and updated to point to the provided @indicator_reference object.
 */

void iodefv2_indicator_set_indicator_reference(iodefv2_indicator_t *ptr, iodefv2_indicator_reference_t *indicator_reference)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->indicator_reference )
                iodefv2_indicator_reference_destroy(ptr->indicator_reference);

        ptr->indicator_reference = indicator_reference;
}
/**
 * iodefv2_indicator_new_indicator_reference:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @ret: pointer to an address where to store the created #iodefv2_indicator_reference_t object.
 *
 * Create a new indicator_reference object, children of #iodefv2_indicator_t.
 * If @ptr already contain a #iodefv2_indicator_reference_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_indicator_reference(iodefv2_indicator_t *ptr, iodefv2_indicator_reference_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->indicator_reference ) {
                retval = iodefv2_indicator_reference_new(&ptr->indicator_reference);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->indicator_reference;
        return 0;
}




/**
 * iodefv2_indicator_get_observable_reference:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 *
 * Get observable_reference children of the #iodefv2_indicator_t object.
 *
 * Returns: a pointer to a iodefv2_observable_reference_t object, or NULL if the children object is not set.
 */
iodefv2_observable_reference_t *iodefv2_indicator_get_observable_reference(iodefv2_indicator_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_reference;

}


/**
 * iodefv2_indicator_set_observable_reference:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @observable_reference: pointer to a #iodefv2_observable_reference_t object.
 *
 * Set @observable_reference object as a children of @ptr.
 * if @ptr already contain an @observable_reference object, then it is destroyed,
 * and updated to point to the provided @observable_reference object.
 */

void iodefv2_indicator_set_observable_reference(iodefv2_indicator_t *ptr, iodefv2_observable_reference_t *observable_reference)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_reference )
                iodefv2_observable_reference_destroy(ptr->observable_reference);

        ptr->observable_reference = observable_reference;
}
/**
 * iodefv2_indicator_new_observable_reference:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @ret: pointer to an address where to store the created #iodefv2_observable_reference_t object.
 *
 * Create a new observable_reference object, children of #iodefv2_indicator_t.
 * If @ptr already contain a #iodefv2_observable_reference_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_observable_reference(iodefv2_indicator_t *ptr, iodefv2_observable_reference_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_reference ) {
                retval = iodefv2_observable_reference_new(&ptr->observable_reference);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_reference;
        return 0;
}





/**
 * iodefv2_indicator_get_next_attack_phase:
 * @indicator: pointer to a #iodefv2_indicator_t object.
 * @attack_phase_cur: pointer to a #iodefv2_attack_phase_t object.
 *
 * Get the next #iodefv2_attack_phase_t object listed in @ptr.
 * When iterating over the iodefv2_attack_phase_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_attack_phase_t object.
 *
 * Returns: the next #iodefv2_attack_phase_t in the list.
 */
iodefv2_attack_phase_t *iodefv2_indicator_get_next_attack_phase(iodefv2_indicator_t *indicator, iodefv2_attack_phase_t *attack_phase_cur)
{
        libiodefv2_list_t *tmp = (attack_phase_cur) ? &((libiodefv2_linked_object_t *) attack_phase_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(indicator, NULL);

        libiodefv2_list_for_each_continue(&indicator->attack_phase_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_indicator_set_attack_phase:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @object: pointer to a #iodefv2_attack_phase_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_attack_phase_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_indicator_set_attack_phase(iodefv2_indicator_t *ptr, iodefv2_attack_phase_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->attack_phase_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_indicator_new_attack_phase:
 *  @ptr: pointer to a #iodefv2_indicator_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_attack_phase_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_attack_phase_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_attack_phase_t object. The created #iodefv2_attack_phase_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_attack_phase(iodefv2_indicator_t *ptr, iodefv2_attack_phase_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_attack_phase_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->attack_phase_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_indicator_get_end_time:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 *
 * Get end_time children of the #iodefv2_indicator_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_indicator_get_end_time(iodefv2_indicator_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->end_time;

}


/**
 * iodefv2_indicator_set_end_time:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @end_time: pointer to a #iodefv2_time_t object.
 *
 * Set @end_time object as a children of @ptr.
 * if @ptr already contain an @end_time object, then it is destroyed,
 * and updated to point to the provided @end_time object.
 */

void iodefv2_indicator_set_end_time(iodefv2_indicator_t *ptr, iodefv2_time_t *end_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->end_time )
                iodefv2_time_destroy(ptr->end_time);

        ptr->end_time = end_time;
}
/**
 * iodefv2_indicator_new_end_time:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new end_time object, children of #iodefv2_indicator_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_new_end_time(iodefv2_indicator_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->end_time ) {
                retval = iodefv2_time_new(&ptr->end_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->end_time;
        return 0;
}



/**
 * iodefv2_indicator_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_indicator_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_indicator_copy(const iodefv2_indicator_t *src, iodefv2_indicator_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->ext_restriction ) {
                libiodefv2_string_destroy(dst->ext_restriction);
                dst->ext_restriction = NULL;
        }

        if ( src->ext_restriction ) {
                ret = libiodefv2_string_clone(src->ext_restriction, &dst->ext_restriction);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_alternative_indicator_id_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->alternative_indicator_id_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_alternative_indicator_id_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->alternative_indicator_id_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_alternative_indicator_id_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->alternative_indicator_id_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->confidence ) {
                iodefv2_confidence_destroy(dst->confidence);
                dst->confidence = NULL;
        }

        if ( src->confidence ) {
                ret = iodefv2_confidence_clone(src->confidence, &dst->confidence);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_reference_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->reference_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_reference_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->reference_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_reference_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->reference_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->observable ) {
                iodefv2_observable_destroy(dst->observable);
                dst->observable = NULL;
        }

        if ( src->observable ) {
                ret = iodefv2_observable_clone(src->observable, &dst->observable);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->indicator_expression ) {
                iodefv2_indicator_expression_destroy(dst->indicator_expression);
                dst->indicator_expression = NULL;
        }

        if ( src->indicator_expression ) {
                ret = iodefv2_indicator_expression_clone(src->indicator_expression, &dst->indicator_expression);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_contact_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->contact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_contact_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->contact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_contact_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->contact_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_node_role_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->node_role_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_node_role_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->node_role_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_node_role_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->node_role_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->start_time ) {
                iodefv2_time_destroy(dst->start_time);
                dst->start_time = NULL;
        }

        if ( src->start_time ) {
                ret = iodefv2_time_clone(src->start_time, &dst->start_time);
                if ( ret < 0 )
                        return ret;
        }




        if ( src->indicator_id ) {
                ret = iodefv2_indicator_id_copy(src->indicator_id, dst->indicator_id);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->indicator_reference ) {
                iodefv2_indicator_reference_destroy(dst->indicator_reference);
                dst->indicator_reference = NULL;
        }

        if ( src->indicator_reference ) {
                ret = iodefv2_indicator_reference_clone(src->indicator_reference, &dst->indicator_reference);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->observable_reference ) {
                iodefv2_observable_reference_destroy(dst->observable_reference);
                dst->observable_reference = NULL;
        }

        if ( src->observable_reference ) {
                ret = iodefv2_observable_reference_clone(src->observable_reference, &dst->observable_reference);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_attack_phase_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->attack_phase_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_attack_phase_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->attack_phase_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_attack_phase_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->attack_phase_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->end_time ) {
                iodefv2_time_destroy(dst->end_time);
                dst->end_time = NULL;
        }

        if ( src->end_time ) {
                ret = iodefv2_time_clone(src->end_time, &dst->end_time);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_indicator_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_indicator_clone(iodefv2_indicator_t *src, iodefv2_indicator_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_indicator_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_indicator_copy(src, *dst);
}


/**
 * iodefv2_indicator_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_indicator_compare(const iodefv2_indicator_t *obj1, const iodefv2_indicator_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_restriction, obj2->ext_restriction);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_alternative_indicator_id_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->alternative_indicator_id_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->alternative_indicator_id_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_alternative_indicator_id_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_confidence_compare(obj1->confidence, obj2->confidence);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_reference_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->reference_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->reference_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_reference_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_observable_compare(obj1->observable, obj2->observable);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_indicator_expression_compare(obj1->indicator_expression, obj2->indicator_expression);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_contact_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->contact_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->contact_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_contact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_node_role_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->node_role_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->node_role_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_node_role_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = iodefv2_time_compare(obj1->start_time, obj2->start_time);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_indicator_id_compare(obj1->indicator_id, obj2->indicator_id);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_indicator_reference_compare(obj1->indicator_reference, obj2->indicator_reference);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_observable_reference_compare(obj1->observable_reference, obj2->observable_reference);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_attack_phase_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->attack_phase_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->attack_phase_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_attack_phase_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = iodefv2_time_compare(obj1->end_time, obj2->end_time);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_indicator_data_new:
 * @ret: Pointer where to store the created #iodefv2_indicator_data_t object.
 *
 * Create a new #iodefv2_indicator_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_indicator_data_new(iodefv2_indicator_data_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_INDICATOR_DATA;


        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->indicator_list);



            return 0;
}


/**
 * iodefv2_indicator_data_ref:
 * @indicator_data: pointer to a #iodefv2_indicator_data_t object.
 *
 * Increase @indicator_data reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @indicator_data.
 */
iodefv2_indicator_data_t *iodefv2_indicator_data_ref(iodefv2_indicator_data_t *indicator_data)
{
        libiodefv2_return_val_if_fail(indicator_data, NULL);
        indicator_data->refcount++;

        return indicator_data;
}



int _iodefv2_indicator_data_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_indicator_data_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:
                *childptr = &ptr->indicator_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_indicator_data_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_indicator_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_indicator_data_new_indicator(ptr, (iodefv2_indicator_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->indicator_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->indicator_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_indicator_data_new_indicator(ptr, (iodefv2_indicator_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_indicator_data_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_indicator_data_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
    
                case 0: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->indicator_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_indicator_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->indicator_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_indicator_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_indicator_data_destroy_internal(iodefv2_indicator_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_indicator_t *entry;

                libiodefv2_list_for_each_safe(&ptr->indicator_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_indicator_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}


/**
 * iodefv2_indicator_data_destroy:
 * @ptr: pointer to a #iodefv2_indicator_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_indicator_data_destroy(iodefv2_indicator_data_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_indicator_data_destroy_internal(ptr);
        free(ptr);
}






/**
 * iodefv2_indicator_data_get_next_indicator:
 * @indicator_data: pointer to a #iodefv2_indicator_data_t object.
 * @indicator_cur: pointer to a #iodefv2_indicator_t object.
 *
 * Get the next #iodefv2_indicator_t object listed in @ptr.
 * When iterating over the iodefv2_indicator_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_indicator_t object.
 *
 * Returns: the next #iodefv2_indicator_t in the list.
 */
iodefv2_indicator_t *iodefv2_indicator_data_get_next_indicator(iodefv2_indicator_data_t *indicator_data, iodefv2_indicator_t *indicator_cur)
{
        libiodefv2_list_t *tmp = (indicator_cur) ? &((libiodefv2_linked_object_t *) indicator_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(indicator_data, NULL);

        libiodefv2_list_for_each_continue(&indicator_data->indicator_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_indicator_data_set_indicator:
 * @ptr: pointer to a #iodefv2_indicator_data_t object.
 * @object: pointer to a #iodefv2_indicator_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_indicator_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_indicator_data_set_indicator(iodefv2_indicator_data_t *ptr, iodefv2_indicator_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->indicator_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_indicator_data_new_indicator:
 *  @ptr: pointer to a #iodefv2_indicator_data_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_indicator_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_indicator_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_indicator_t object. The created #iodefv2_indicator_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_indicator_data_new_indicator(iodefv2_indicator_data_t *ptr, iodefv2_indicator_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_indicator_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->indicator_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_indicator_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_indicator_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_indicator_data_copy(const iodefv2_indicator_data_t *src, iodefv2_indicator_data_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_indicator_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->indicator_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_indicator_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->indicator_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_indicator_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->indicator_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_indicator_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_indicator_data_clone(iodefv2_indicator_data_t *src, iodefv2_indicator_data_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_indicator_data_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_indicator_data_copy(src, *dst);
}


/**
 * iodefv2_indicator_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_indicator_data_compare(const iodefv2_indicator_data_t *obj1, const iodefv2_indicator_data_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_indicator_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->indicator_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->indicator_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_indicator_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}


        



/**
 * iodefv2_incident_new:
 * @ret: Pointer where to store the created #iodefv2_incident_t object.
 *
 * Create a new #iodefv2_incident_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_incident_new(iodefv2_incident_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_INCIDENT;



        libiodefv2_list_init(&((libiodefv2_linked_object_t *) (*ret))->_list);

        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);


        libiodefv2_list_init(&(*ret)->contact_list);


        libiodefv2_list_init(&(*ret)->assessment_list);


        libiodefv2_list_init(&(*ret)->method_list);


        libiodefv2_list_init(&(*ret)->discovery_list);


        libiodefv2_list_init(&(*ret)->event_data_list);









































            return 0;
}


/**
 * iodefv2_incident_ref:
 * @incident: pointer to a #iodefv2_incident_t object.
 *
 * Increase @incident reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @incident.
 */
iodefv2_incident_t *iodefv2_incident_ref(iodefv2_incident_t *incident)
{
        libiodefv2_return_val_if_fail(incident, NULL);
        incident->refcount++;

        return incident;
}



int _iodefv2_incident_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_incident_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_INCIDENT_STATUS , ptr->status);

            case 1:

                    if ( ! ptr->lang_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_INCIDENT_LANG , ptr->lang);


            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_purpose, TRUE);


            case 3:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_INCIDENT_PURPOSE , ptr->purpose);


            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->ext_status, TRUE);


            case 5:

                    if ( ! ptr->restriction_is_set )
                        return 0;


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_INCIDENT_RESTRICTION , ptr->restriction);


            case 6:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->observable_id, TRUE);


            case 7:
                *childptr = &ptr->additional_data_list;
                return 0;


            case 8:
                *childptr = ptr->history;
                return 0;


            case 9:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->start_time, TRUE);



            case 10:
                *childptr = ptr->alternative_id;
                return 0;

            case 11:
                *childptr = &ptr->contact_list;
                return 0;


            case 12:
                *childptr = ptr->related_activity;
                return 0;


            case 13:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->end_time, TRUE);



            case 14:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->generation_time, TRUE);


            case 15:
                *childptr = &ptr->assessment_list;
                return 0;

            case 16:
                *childptr = &ptr->method_list;
                return 0;


            case 17:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->recovery_time, TRUE);


            case 18:
                *childptr = &ptr->discovery_list;
                return 0;


            case 19:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->detect_time, TRUE);



            case 20:

                return get_value_from_time((iodefv2_value_t **) childptr,  ptr->report_time, TRUE);



            case 21:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->description, TRUE);



            case 22:
                *childptr = ptr->indicator_data;
                return 0;

            case 23:
                *childptr = &ptr->event_data_list;
                return 0;


            case 24:
                *childptr = ptr->incident_id;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_incident_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_incident_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_incident_new_status(ptr, (iodefv2_incident_status_t **) ret);

                case 1:
                    return iodefv2_incident_new_lang(ptr, (iodefv2_incident_lang_t **) ret);

                case 2:
                    return iodefv2_incident_new_ext_purpose(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_incident_new_purpose(ptr, (iodefv2_incident_purpose_t **) ret);

                case 4:
                    return iodefv2_incident_new_ext_status(ptr, (libiodefv2_string_t **) ret);

                case 5:
                    return iodefv2_incident_new_restriction(ptr, (iodefv2_incident_restriction_t **) ret);

                case 6:
                    return iodefv2_incident_new_observable_id(ptr, (libiodefv2_string_t **) ret);

                case 7: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_incident_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_incident_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 8:
                    return iodefv2_incident_new_history(ptr, (iodefv2_history_t **) ret);

                case 9:
                    return iodefv2_incident_new_start_time(ptr, (iodefv2_time_t **) ret);

                case 10:
                    return iodefv2_incident_new_alternative_id(ptr, (iodefv2_alternative_id_t **) ret);

                case 11: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_incident_new_contact(ptr, (iodefv2_contact_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->contact_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->contact_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_incident_new_contact(ptr, (iodefv2_contact_t **) ret, n);
                }

                case 12:
                    return iodefv2_incident_new_related_activity(ptr, (iodefv2_related_activity_t **) ret);

                case 13:
                    return iodefv2_incident_new_end_time(ptr, (iodefv2_time_t **) ret);

                case 14:
                    return iodefv2_incident_new_generation_time(ptr, (iodefv2_time_t **) ret);

                case 15: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_incident_new_assessment(ptr, (iodefv2_assessment_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->assessment_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->assessment_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_incident_new_assessment(ptr, (iodefv2_assessment_t **) ret, n);
                }

                case 16: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_incident_new_method(ptr, (iodefv2_method_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->method_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->method_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_incident_new_method(ptr, (iodefv2_method_t **) ret, n);
                }

                case 17:
                    return iodefv2_incident_new_recovery_time(ptr, (iodefv2_time_t **) ret);

                case 18: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_incident_new_discovery(ptr, (iodefv2_discovery_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->discovery_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->discovery_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_incident_new_discovery(ptr, (iodefv2_discovery_t **) ret, n);
                }

                case 19:
                    return iodefv2_incident_new_detect_time(ptr, (iodefv2_time_t **) ret);

                case 20:
                    return iodefv2_incident_new_report_time(ptr, (iodefv2_time_t **) ret);

                case 21:
                    return iodefv2_incident_new_description(ptr, (libiodefv2_string_t **) ret);

                case 22:
                    return iodefv2_incident_new_indicator_data(ptr, (iodefv2_indicator_data_t **) ret);

                case 23: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_incident_new_event_data(ptr, (iodefv2_event_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->event_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->event_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_incident_new_event_data(ptr, (iodefv2_event_data_t **) ret, n);
                }

                case 24:
                    return iodefv2_incident_new_incident_id(ptr, (iodefv2_incident_id_t **) ret);

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_incident_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_incident_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->status = 0;
                    return 0;

                case 1:
                        ptr->lang_is_set = 0;
                        return 0;




                case 2:
                        if ( ptr->ext_purpose ) {
                                libiodefv2_string_destroy(ptr->ext_purpose);
                                ptr->ext_purpose = NULL;
                        }

                        return 0;




                case 3:
                    ptr->purpose = 0;
                    return 0;




                case 4:
                        if ( ptr->ext_status ) {
                                libiodefv2_string_destroy(ptr->ext_status);
                                ptr->ext_status = NULL;
                        }

                        return 0;

                case 5:
                        ptr->restriction_is_set = 0;
                        return 0;




                case 6:
                        if ( ptr->observable_id ) {
                                libiodefv2_string_destroy(ptr->observable_id);
                                ptr->observable_id = NULL;
                        }

                        return 0;

    
                case 7: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 8:
                        if ( ptr->history ) {
                                iodefv2_history_destroy(ptr->history);
                                ptr->history = NULL;
                        }

                        return 0;




                case 9:
                        if ( ptr->start_time ) {
                                iodefv2_time_destroy(ptr->start_time);
                                ptr->start_time = NULL;
                        }

                        return 0;




                case 10:
                        if ( ptr->alternative_id ) {
                                iodefv2_alternative_id_destroy(ptr->alternative_id);
                                ptr->alternative_id = NULL;
                        }

                        return 0;

    
                case 11: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->contact_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_contact_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->contact_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_contact_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 12:
                        if ( ptr->related_activity ) {
                                iodefv2_related_activity_destroy(ptr->related_activity);
                                ptr->related_activity = NULL;
                        }

                        return 0;




                case 13:
                        if ( ptr->end_time ) {
                                iodefv2_time_destroy(ptr->end_time);
                                ptr->end_time = NULL;
                        }

                        return 0;




                case 14:
                        if ( ptr->generation_time ) {
                                iodefv2_time_destroy(ptr->generation_time);
                                ptr->generation_time = NULL;
                        }

                        return 0;

    
                case 15: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->assessment_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_assessment_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->assessment_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_assessment_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 16: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->method_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_method_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->method_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_method_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 17:
                        if ( ptr->recovery_time ) {
                                iodefv2_time_destroy(ptr->recovery_time);
                                ptr->recovery_time = NULL;
                        }

                        return 0;

    
                case 18: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->discovery_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_discovery_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->discovery_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_discovery_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 19:
                        if ( ptr->detect_time ) {
                                iodefv2_time_destroy(ptr->detect_time);
                                ptr->detect_time = NULL;
                        }

                        return 0;




                case 20:
                        if ( ptr->report_time ) {
                                iodefv2_time_destroy(ptr->report_time);
                                ptr->report_time = NULL;
                        }

                        return 0;




                case 21:
                        if ( ptr->description ) {
                                libiodefv2_string_destroy(ptr->description);
                                ptr->description = NULL;
                        }

                        return 0;




                case 22:
                        if ( ptr->indicator_data ) {
                                iodefv2_indicator_data_destroy(ptr->indicator_data);
                                ptr->indicator_data = NULL;
                        }

                        return 0;

    
                case 23: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->event_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_event_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->event_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_event_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }




                case 24:
                        if ( ptr->incident_id ) {
                                iodefv2_incident_id_destroy(ptr->incident_id);
                                ptr->incident_id = NULL;
                        }

                        return 0;

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_incident_destroy_internal(iodefv2_incident_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *)ptr)->_list) )
               libiodefv2_list_del_init(&((libiodefv2_linked_object_t *)ptr)->_list);





        if ( ptr->ext_purpose ) {
                libiodefv2_string_destroy(ptr->ext_purpose);
                ptr->ext_purpose = NULL;
        }





        if ( ptr->ext_status ) {
                libiodefv2_string_destroy(ptr->ext_status);
                ptr->ext_status = NULL;
        }





        if ( ptr->observable_id ) {
                libiodefv2_string_destroy(ptr->observable_id);
                ptr->observable_id = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }


        if ( ptr->history ) {
                iodefv2_history_destroy(ptr->history);
                ptr->history = NULL;
        }



        if ( ptr->start_time ) {
                iodefv2_time_destroy(ptr->start_time);
                ptr->start_time = NULL;
        }




        if ( ptr->alternative_id ) {
                iodefv2_alternative_id_destroy(ptr->alternative_id);
                ptr->alternative_id = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_contact_t *entry;

                libiodefv2_list_for_each_safe(&ptr->contact_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_contact_destroy(entry);
                }
        }


        if ( ptr->related_activity ) {
                iodefv2_related_activity_destroy(ptr->related_activity);
                ptr->related_activity = NULL;
        }



        if ( ptr->end_time ) {
                iodefv2_time_destroy(ptr->end_time);
                ptr->end_time = NULL;
        }



        if ( ptr->generation_time ) {
                iodefv2_time_destroy(ptr->generation_time);
                ptr->generation_time = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_assessment_t *entry;

                libiodefv2_list_for_each_safe(&ptr->assessment_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_assessment_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_method_t *entry;

                libiodefv2_list_for_each_safe(&ptr->method_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_method_destroy(entry);
                }
        }

        if ( ptr->recovery_time ) {
                iodefv2_time_destroy(ptr->recovery_time);
                ptr->recovery_time = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_discovery_t *entry;

                libiodefv2_list_for_each_safe(&ptr->discovery_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_discovery_destroy(entry);
                }
        }

        if ( ptr->detect_time ) {
                iodefv2_time_destroy(ptr->detect_time);
                ptr->detect_time = NULL;
        }



        if ( ptr->report_time ) {
                iodefv2_time_destroy(ptr->report_time);
                ptr->report_time = NULL;
        }



        if ( ptr->description ) {
                libiodefv2_string_destroy(ptr->description);
                ptr->description = NULL;
        }




        if ( ptr->indicator_data ) {
                iodefv2_indicator_data_destroy(ptr->indicator_data);
                ptr->indicator_data = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_event_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->event_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_event_data_destroy(entry);
                }
        }


        if ( ptr->incident_id ) {
                iodefv2_incident_id_destroy(ptr->incident_id);
                ptr->incident_id = NULL;
        }


        /* free() should be done by the caller */
}


/**
 * iodefv2_incident_destroy:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_incident_destroy(iodefv2_incident_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_incident_destroy_internal(ptr);
        free(ptr);
}




/**
 * iodefv2_incident_get_status:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get status children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a iodefv2_incident_status_t object, or NULL if the children object is not set.
 */
iodefv2_incident_status_t iodefv2_incident_get_status(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->status;

}


/**
 * iodefv2_incident_set_status:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @status: pointer to a #iodefv2_incident_status_t object.
 *
 * Set @status object as a children of @ptr.
 * if @ptr already contain an @status object, then it is destroyed,
 * and updated to point to the provided @status object.
 */
void iodefv2_incident_set_status(iodefv2_incident_t *ptr, iodefv2_incident_status_t status)
{
        libiodefv2_return_if_fail(ptr);
        ptr->status = status;
}
/**
 * iodefv2_incident_new_status:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #iodefv2_incident_status_t object.
 *
 * Create a new status object, children of #iodefv2_incident_t.
 * If @ptr already contain a #iodefv2_incident_status_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_status(iodefv2_incident_t *ptr, iodefv2_incident_status_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->status;
        return 0;
}




/**
 * iodefv2_incident_get_lang:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get lang children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a iodefv2_incident_lang_t object, or NULL if the children object is not set.
 */
iodefv2_incident_lang_t *iodefv2_incident_get_lang(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->lang_is_set ? &ptr->lang : NULL;


}


/**
 * iodefv2_incident_set_lang:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @lang: pointer to a #iodefv2_incident_lang_t object.
 *
 * Set @lang object as a children of @ptr.
 * if @ptr already contain an @lang object, then it is destroyed,
 * and updated to point to the provided @lang object.
 */
void iodefv2_incident_set_lang(iodefv2_incident_t *ptr, iodefv2_incident_lang_t lang)
{
        libiodefv2_return_if_fail(ptr);
        ptr->lang = lang;
        ptr->lang_is_set = 1;
}

void iodefv2_incident_unset_lang(iodefv2_incident_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->lang_is_set = 0;
}
/**
 * iodefv2_incident_new_lang:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #iodefv2_incident_lang_t object.
 *
 * Create a new lang object, children of #iodefv2_incident_t.
 * If @ptr already contain a #iodefv2_incident_lang_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_lang(iodefv2_incident_t *ptr, iodefv2_incident_lang_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->lang_is_set = 1;



        *ret = &ptr->lang;
        return 0;
}




/**
 * iodefv2_incident_get_ext_purpose:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get ext_purpose children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_incident_get_ext_purpose(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_purpose;

}


/**
 * iodefv2_incident_set_ext_purpose:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ext_purpose: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_purpose object as a children of @ptr.
 * if @ptr already contain an @ext_purpose object, then it is destroyed,
 * and updated to point to the provided @ext_purpose object.
 */

void iodefv2_incident_set_ext_purpose(iodefv2_incident_t *ptr, libiodefv2_string_t *ext_purpose)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_purpose )
                libiodefv2_string_destroy(ptr->ext_purpose);

        ptr->ext_purpose = ext_purpose;
}
/**
 * iodefv2_incident_new_ext_purpose:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_purpose object, children of #iodefv2_incident_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_ext_purpose(iodefv2_incident_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_purpose ) {
                retval = libiodefv2_string_new(&ptr->ext_purpose);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_purpose;
        return 0;
}



/**
 * iodefv2_incident_get_purpose:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get purpose children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a iodefv2_incident_purpose_t object, or NULL if the children object is not set.
 */
iodefv2_incident_purpose_t iodefv2_incident_get_purpose(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->purpose;

}


/**
 * iodefv2_incident_set_purpose:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @purpose: pointer to a #iodefv2_incident_purpose_t object.
 *
 * Set @purpose object as a children of @ptr.
 * if @ptr already contain an @purpose object, then it is destroyed,
 * and updated to point to the provided @purpose object.
 */
void iodefv2_incident_set_purpose(iodefv2_incident_t *ptr, iodefv2_incident_purpose_t purpose)
{
        libiodefv2_return_if_fail(ptr);
        ptr->purpose = purpose;
}
/**
 * iodefv2_incident_new_purpose:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #iodefv2_incident_purpose_t object.
 *
 * Create a new purpose object, children of #iodefv2_incident_t.
 * If @ptr already contain a #iodefv2_incident_purpose_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_purpose(iodefv2_incident_t *ptr, iodefv2_incident_purpose_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->purpose;
        return 0;
}




/**
 * iodefv2_incident_get_ext_status:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get ext_status children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_incident_get_ext_status(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->ext_status;

}


/**
 * iodefv2_incident_set_ext_status:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ext_status: pointer to a #libiodefv2_string_t object.
 *
 * Set @ext_status object as a children of @ptr.
 * if @ptr already contain an @ext_status object, then it is destroyed,
 * and updated to point to the provided @ext_status object.
 */

void iodefv2_incident_set_ext_status(iodefv2_incident_t *ptr, libiodefv2_string_t *ext_status)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->ext_status )
                libiodefv2_string_destroy(ptr->ext_status);

        ptr->ext_status = ext_status;
}
/**
 * iodefv2_incident_new_ext_status:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new ext_status object, children of #iodefv2_incident_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_ext_status(iodefv2_incident_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->ext_status ) {
                retval = libiodefv2_string_new(&ptr->ext_status);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->ext_status;
        return 0;
}




/**
 * iodefv2_incident_get_restriction:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get restriction children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a iodefv2_incident_restriction_t object, or NULL if the children object is not set.
 */
iodefv2_incident_restriction_t *iodefv2_incident_get_restriction(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->restriction_is_set ? &ptr->restriction : NULL;


}


/**
 * iodefv2_incident_set_restriction:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @restriction: pointer to a #iodefv2_incident_restriction_t object.
 *
 * Set @restriction object as a children of @ptr.
 * if @ptr already contain an @restriction object, then it is destroyed,
 * and updated to point to the provided @restriction object.
 */
void iodefv2_incident_set_restriction(iodefv2_incident_t *ptr, iodefv2_incident_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}

void iodefv2_incident_unset_restriction(iodefv2_incident_t *ptr)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction_is_set = 0;
}
/**
 * iodefv2_incident_new_restriction:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #iodefv2_incident_restriction_t object.
 *
 * Create a new restriction object, children of #iodefv2_incident_t.
 * If @ptr already contain a #iodefv2_incident_restriction_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_restriction(iodefv2_incident_t *ptr, iodefv2_incident_restriction_t **ret)
{


        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        ptr->restriction_is_set = 1;



        *ret = &ptr->restriction;
        return 0;
}




/**
 * iodefv2_incident_get_observable_id:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get observable_id children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_incident_get_observable_id(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->observable_id;

}


/**
 * iodefv2_incident_set_observable_id:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @observable_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @observable_id object as a children of @ptr.
 * if @ptr already contain an @observable_id object, then it is destroyed,
 * and updated to point to the provided @observable_id object.
 */

void iodefv2_incident_set_observable_id(iodefv2_incident_t *ptr, libiodefv2_string_t *observable_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->observable_id )
                libiodefv2_string_destroy(ptr->observable_id);

        ptr->observable_id = observable_id;
}
/**
 * iodefv2_incident_new_observable_id:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new observable_id object, children of #iodefv2_incident_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_observable_id(iodefv2_incident_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->observable_id ) {
                retval = libiodefv2_string_new(&ptr->observable_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->observable_id;
        return 0;
}





/**
 * iodefv2_incident_get_next_additional_data:
 * @incident: pointer to a #iodefv2_incident_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_incident_get_next_additional_data(iodefv2_incident_t *incident, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(incident, NULL);

        libiodefv2_list_for_each_continue(&incident->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_incident_set_additional_data:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_incident_set_additional_data(iodefv2_incident_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_incident_new_additional_data:
 *  @ptr: pointer to a #iodefv2_incident_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_additional_data(iodefv2_incident_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_incident_get_history:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get history children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a iodefv2_history_t object, or NULL if the children object is not set.
 */
iodefv2_history_t *iodefv2_incident_get_history(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->history;

}


/**
 * iodefv2_incident_set_history:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @history: pointer to a #iodefv2_history_t object.
 *
 * Set @history object as a children of @ptr.
 * if @ptr already contain an @history object, then it is destroyed,
 * and updated to point to the provided @history object.
 */

void iodefv2_incident_set_history(iodefv2_incident_t *ptr, iodefv2_history_t *history)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->history )
                iodefv2_history_destroy(ptr->history);

        ptr->history = history;
}
/**
 * iodefv2_incident_new_history:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #iodefv2_history_t object.
 *
 * Create a new history object, children of #iodefv2_incident_t.
 * If @ptr already contain a #iodefv2_history_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_history(iodefv2_incident_t *ptr, iodefv2_history_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->history ) {
                retval = iodefv2_history_new(&ptr->history);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->history;
        return 0;
}




/**
 * iodefv2_incident_get_start_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get start_time children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_incident_get_start_time(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->start_time;

}


/**
 * iodefv2_incident_set_start_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @start_time: pointer to a #iodefv2_time_t object.
 *
 * Set @start_time object as a children of @ptr.
 * if @ptr already contain an @start_time object, then it is destroyed,
 * and updated to point to the provided @start_time object.
 */

void iodefv2_incident_set_start_time(iodefv2_incident_t *ptr, iodefv2_time_t *start_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->start_time )
                iodefv2_time_destroy(ptr->start_time);

        ptr->start_time = start_time;
}
/**
 * iodefv2_incident_new_start_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new start_time object, children of #iodefv2_incident_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_start_time(iodefv2_incident_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->start_time ) {
                retval = iodefv2_time_new(&ptr->start_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->start_time;
        return 0;
}




/**
 * iodefv2_incident_get_alternative_id:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get alternative_id children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a iodefv2_alternative_id_t object, or NULL if the children object is not set.
 */
iodefv2_alternative_id_t *iodefv2_incident_get_alternative_id(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->alternative_id;

}


/**
 * iodefv2_incident_set_alternative_id:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @alternative_id: pointer to a #iodefv2_alternative_id_t object.
 *
 * Set @alternative_id object as a children of @ptr.
 * if @ptr already contain an @alternative_id object, then it is destroyed,
 * and updated to point to the provided @alternative_id object.
 */

void iodefv2_incident_set_alternative_id(iodefv2_incident_t *ptr, iodefv2_alternative_id_t *alternative_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->alternative_id )
                iodefv2_alternative_id_destroy(ptr->alternative_id);

        ptr->alternative_id = alternative_id;
}
/**
 * iodefv2_incident_new_alternative_id:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #iodefv2_alternative_id_t object.
 *
 * Create a new alternative_id object, children of #iodefv2_incident_t.
 * If @ptr already contain a #iodefv2_alternative_id_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_alternative_id(iodefv2_incident_t *ptr, iodefv2_alternative_id_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->alternative_id ) {
                retval = iodefv2_alternative_id_new(&ptr->alternative_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->alternative_id;
        return 0;
}





/**
 * iodefv2_incident_get_next_contact:
 * @incident: pointer to a #iodefv2_incident_t object.
 * @contact_cur: pointer to a #iodefv2_contact_t object.
 *
 * Get the next #iodefv2_contact_t object listed in @ptr.
 * When iterating over the iodefv2_contact_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_contact_t object.
 *
 * Returns: the next #iodefv2_contact_t in the list.
 */
iodefv2_contact_t *iodefv2_incident_get_next_contact(iodefv2_incident_t *incident, iodefv2_contact_t *contact_cur)
{
        libiodefv2_list_t *tmp = (contact_cur) ? &((libiodefv2_linked_object_t *) contact_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(incident, NULL);

        libiodefv2_list_for_each_continue(&incident->contact_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_incident_set_contact:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @object: pointer to a #iodefv2_contact_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_contact_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_incident_set_contact(iodefv2_incident_t *ptr, iodefv2_contact_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->contact_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_incident_new_contact:
 *  @ptr: pointer to a #iodefv2_incident_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_contact_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_contact_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_contact_t object. The created #iodefv2_contact_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_contact(iodefv2_incident_t *ptr, iodefv2_contact_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_contact_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->contact_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_incident_get_related_activity:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get related_activity children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a iodefv2_related_activity_t object, or NULL if the children object is not set.
 */
iodefv2_related_activity_t *iodefv2_incident_get_related_activity(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->related_activity;

}


/**
 * iodefv2_incident_set_related_activity:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @related_activity: pointer to a #iodefv2_related_activity_t object.
 *
 * Set @related_activity object as a children of @ptr.
 * if @ptr already contain an @related_activity object, then it is destroyed,
 * and updated to point to the provided @related_activity object.
 */

void iodefv2_incident_set_related_activity(iodefv2_incident_t *ptr, iodefv2_related_activity_t *related_activity)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->related_activity )
                iodefv2_related_activity_destroy(ptr->related_activity);

        ptr->related_activity = related_activity;
}
/**
 * iodefv2_incident_new_related_activity:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #iodefv2_related_activity_t object.
 *
 * Create a new related_activity object, children of #iodefv2_incident_t.
 * If @ptr already contain a #iodefv2_related_activity_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_related_activity(iodefv2_incident_t *ptr, iodefv2_related_activity_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->related_activity ) {
                retval = iodefv2_related_activity_new(&ptr->related_activity);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->related_activity;
        return 0;
}




/**
 * iodefv2_incident_get_end_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get end_time children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_incident_get_end_time(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->end_time;

}


/**
 * iodefv2_incident_set_end_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @end_time: pointer to a #iodefv2_time_t object.
 *
 * Set @end_time object as a children of @ptr.
 * if @ptr already contain an @end_time object, then it is destroyed,
 * and updated to point to the provided @end_time object.
 */

void iodefv2_incident_set_end_time(iodefv2_incident_t *ptr, iodefv2_time_t *end_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->end_time )
                iodefv2_time_destroy(ptr->end_time);

        ptr->end_time = end_time;
}
/**
 * iodefv2_incident_new_end_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new end_time object, children of #iodefv2_incident_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_end_time(iodefv2_incident_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->end_time ) {
                retval = iodefv2_time_new(&ptr->end_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->end_time;
        return 0;
}




/**
 * iodefv2_incident_get_generation_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get generation_time children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_incident_get_generation_time(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->generation_time;

}


/**
 * iodefv2_incident_set_generation_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @generation_time: pointer to a #iodefv2_time_t object.
 *
 * Set @generation_time object as a children of @ptr.
 * if @ptr already contain an @generation_time object, then it is destroyed,
 * and updated to point to the provided @generation_time object.
 */

void iodefv2_incident_set_generation_time(iodefv2_incident_t *ptr, iodefv2_time_t *generation_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->generation_time )
                iodefv2_time_destroy(ptr->generation_time);

        ptr->generation_time = generation_time;
}
/**
 * iodefv2_incident_new_generation_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new generation_time object, children of #iodefv2_incident_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_generation_time(iodefv2_incident_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->generation_time ) {
                retval = iodefv2_time_new(&ptr->generation_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->generation_time;
        return 0;
}





/**
 * iodefv2_incident_get_next_assessment:
 * @incident: pointer to a #iodefv2_incident_t object.
 * @assessment_cur: pointer to a #iodefv2_assessment_t object.
 *
 * Get the next #iodefv2_assessment_t object listed in @ptr.
 * When iterating over the iodefv2_assessment_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_assessment_t object.
 *
 * Returns: the next #iodefv2_assessment_t in the list.
 */
iodefv2_assessment_t *iodefv2_incident_get_next_assessment(iodefv2_incident_t *incident, iodefv2_assessment_t *assessment_cur)
{
        libiodefv2_list_t *tmp = (assessment_cur) ? &((libiodefv2_linked_object_t *) assessment_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(incident, NULL);

        libiodefv2_list_for_each_continue(&incident->assessment_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_incident_set_assessment:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @object: pointer to a #iodefv2_assessment_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_assessment_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_incident_set_assessment(iodefv2_incident_t *ptr, iodefv2_assessment_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->assessment_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_incident_new_assessment:
 *  @ptr: pointer to a #iodefv2_incident_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_assessment_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_assessment_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_assessment_t object. The created #iodefv2_assessment_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_assessment(iodefv2_incident_t *ptr, iodefv2_assessment_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_assessment_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->assessment_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_incident_get_next_method:
 * @incident: pointer to a #iodefv2_incident_t object.
 * @method_cur: pointer to a #iodefv2_method_t object.
 *
 * Get the next #iodefv2_method_t object listed in @ptr.
 * When iterating over the iodefv2_method_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_method_t object.
 *
 * Returns: the next #iodefv2_method_t in the list.
 */
iodefv2_method_t *iodefv2_incident_get_next_method(iodefv2_incident_t *incident, iodefv2_method_t *method_cur)
{
        libiodefv2_list_t *tmp = (method_cur) ? &((libiodefv2_linked_object_t *) method_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(incident, NULL);

        libiodefv2_list_for_each_continue(&incident->method_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_incident_set_method:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @object: pointer to a #iodefv2_method_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_method_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_incident_set_method(iodefv2_incident_t *ptr, iodefv2_method_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->method_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_incident_new_method:
 *  @ptr: pointer to a #iodefv2_incident_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_method_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_method_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_method_t object. The created #iodefv2_method_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_method(iodefv2_incident_t *ptr, iodefv2_method_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_method_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->method_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_incident_get_recovery_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get recovery_time children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_incident_get_recovery_time(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->recovery_time;

}


/**
 * iodefv2_incident_set_recovery_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @recovery_time: pointer to a #iodefv2_time_t object.
 *
 * Set @recovery_time object as a children of @ptr.
 * if @ptr already contain an @recovery_time object, then it is destroyed,
 * and updated to point to the provided @recovery_time object.
 */

void iodefv2_incident_set_recovery_time(iodefv2_incident_t *ptr, iodefv2_time_t *recovery_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->recovery_time )
                iodefv2_time_destroy(ptr->recovery_time);

        ptr->recovery_time = recovery_time;
}
/**
 * iodefv2_incident_new_recovery_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new recovery_time object, children of #iodefv2_incident_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_recovery_time(iodefv2_incident_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->recovery_time ) {
                retval = iodefv2_time_new(&ptr->recovery_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->recovery_time;
        return 0;
}





/**
 * iodefv2_incident_get_next_discovery:
 * @incident: pointer to a #iodefv2_incident_t object.
 * @discovery_cur: pointer to a #iodefv2_discovery_t object.
 *
 * Get the next #iodefv2_discovery_t object listed in @ptr.
 * When iterating over the iodefv2_discovery_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_discovery_t object.
 *
 * Returns: the next #iodefv2_discovery_t in the list.
 */
iodefv2_discovery_t *iodefv2_incident_get_next_discovery(iodefv2_incident_t *incident, iodefv2_discovery_t *discovery_cur)
{
        libiodefv2_list_t *tmp = (discovery_cur) ? &((libiodefv2_linked_object_t *) discovery_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(incident, NULL);

        libiodefv2_list_for_each_continue(&incident->discovery_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_incident_set_discovery:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @object: pointer to a #iodefv2_discovery_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_discovery_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_incident_set_discovery(iodefv2_incident_t *ptr, iodefv2_discovery_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->discovery_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_incident_new_discovery:
 *  @ptr: pointer to a #iodefv2_incident_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_discovery_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_discovery_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_discovery_t object. The created #iodefv2_discovery_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_discovery(iodefv2_incident_t *ptr, iodefv2_discovery_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_discovery_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->discovery_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_incident_get_detect_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get detect_time children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_incident_get_detect_time(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->detect_time;

}


/**
 * iodefv2_incident_set_detect_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @detect_time: pointer to a #iodefv2_time_t object.
 *
 * Set @detect_time object as a children of @ptr.
 * if @ptr already contain an @detect_time object, then it is destroyed,
 * and updated to point to the provided @detect_time object.
 */

void iodefv2_incident_set_detect_time(iodefv2_incident_t *ptr, iodefv2_time_t *detect_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->detect_time )
                iodefv2_time_destroy(ptr->detect_time);

        ptr->detect_time = detect_time;
}
/**
 * iodefv2_incident_new_detect_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new detect_time object, children of #iodefv2_incident_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_detect_time(iodefv2_incident_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->detect_time ) {
                retval = iodefv2_time_new(&ptr->detect_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->detect_time;
        return 0;
}




/**
 * iodefv2_incident_get_report_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get report_time children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a iodefv2_time_t object, or NULL if the children object is not set.
 */
iodefv2_time_t *iodefv2_incident_get_report_time(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->report_time;

}


/**
 * iodefv2_incident_set_report_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @report_time: pointer to a #iodefv2_time_t object.
 *
 * Set @report_time object as a children of @ptr.
 * if @ptr already contain an @report_time object, then it is destroyed,
 * and updated to point to the provided @report_time object.
 */

void iodefv2_incident_set_report_time(iodefv2_incident_t *ptr, iodefv2_time_t *report_time)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->report_time )
                iodefv2_time_destroy(ptr->report_time);

        ptr->report_time = report_time;
}
/**
 * iodefv2_incident_new_report_time:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #iodefv2_time_t object.
 *
 * Create a new report_time object, children of #iodefv2_incident_t.
 * If @ptr already contain a #iodefv2_time_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_report_time(iodefv2_incident_t *ptr, iodefv2_time_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->report_time ) {
                retval = iodefv2_time_new(&ptr->report_time);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->report_time;
        return 0;
}




/**
 * iodefv2_incident_get_description:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get description children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_incident_get_description(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->description;

}


/**
 * iodefv2_incident_set_description:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @description: pointer to a #libiodefv2_string_t object.
 *
 * Set @description object as a children of @ptr.
 * if @ptr already contain an @description object, then it is destroyed,
 * and updated to point to the provided @description object.
 */

void iodefv2_incident_set_description(iodefv2_incident_t *ptr, libiodefv2_string_t *description)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->description )
                libiodefv2_string_destroy(ptr->description);

        ptr->description = description;
}
/**
 * iodefv2_incident_new_description:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new description object, children of #iodefv2_incident_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_description(iodefv2_incident_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->description ) {
                retval = libiodefv2_string_new(&ptr->description);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->description;
        return 0;
}




/**
 * iodefv2_incident_get_indicator_data:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get indicator_data children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a iodefv2_indicator_data_t object, or NULL if the children object is not set.
 */
iodefv2_indicator_data_t *iodefv2_incident_get_indicator_data(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->indicator_data;

}


/**
 * iodefv2_incident_set_indicator_data:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @indicator_data: pointer to a #iodefv2_indicator_data_t object.
 *
 * Set @indicator_data object as a children of @ptr.
 * if @ptr already contain an @indicator_data object, then it is destroyed,
 * and updated to point to the provided @indicator_data object.
 */

void iodefv2_incident_set_indicator_data(iodefv2_incident_t *ptr, iodefv2_indicator_data_t *indicator_data)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->indicator_data )
                iodefv2_indicator_data_destroy(ptr->indicator_data);

        ptr->indicator_data = indicator_data;
}
/**
 * iodefv2_incident_new_indicator_data:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #iodefv2_indicator_data_t object.
 *
 * Create a new indicator_data object, children of #iodefv2_incident_t.
 * If @ptr already contain a #iodefv2_indicator_data_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_indicator_data(iodefv2_incident_t *ptr, iodefv2_indicator_data_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->indicator_data ) {
                retval = iodefv2_indicator_data_new(&ptr->indicator_data);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->indicator_data;
        return 0;
}





/**
 * iodefv2_incident_get_next_event_data:
 * @incident: pointer to a #iodefv2_incident_t object.
 * @event_data_cur: pointer to a #iodefv2_event_data_t object.
 *
 * Get the next #iodefv2_event_data_t object listed in @ptr.
 * When iterating over the iodefv2_event_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_event_data_t object.
 *
 * Returns: the next #iodefv2_event_data_t in the list.
 */
iodefv2_event_data_t *iodefv2_incident_get_next_event_data(iodefv2_incident_t *incident, iodefv2_event_data_t *event_data_cur)
{
        libiodefv2_list_t *tmp = (event_data_cur) ? &((libiodefv2_linked_object_t *) event_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(incident, NULL);

        libiodefv2_list_for_each_continue(&incident->event_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_incident_set_event_data:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @object: pointer to a #iodefv2_event_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_event_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_incident_set_event_data(iodefv2_incident_t *ptr, iodefv2_event_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->event_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_incident_new_event_data:
 *  @ptr: pointer to a #iodefv2_incident_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_event_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_event_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_event_data_t object. The created #iodefv2_event_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_event_data(iodefv2_incident_t *ptr, iodefv2_event_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_event_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->event_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}




/**
 * iodefv2_incident_get_incident_id:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Get incident_id children of the #iodefv2_incident_t object.
 *
 * Returns: a pointer to a iodefv2_incident_id_t object, or NULL if the children object is not set.
 */
iodefv2_incident_id_t *iodefv2_incident_get_incident_id(iodefv2_incident_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->incident_id;

}


/**
 * iodefv2_incident_set_incident_id:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @incident_id: pointer to a #iodefv2_incident_id_t object.
 *
 * Set @incident_id object as a children of @ptr.
 * if @ptr already contain an @incident_id object, then it is destroyed,
 * and updated to point to the provided @incident_id object.
 */

void iodefv2_incident_set_incident_id(iodefv2_incident_t *ptr, iodefv2_incident_id_t *incident_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->incident_id )
                iodefv2_incident_id_destroy(ptr->incident_id);

        ptr->incident_id = incident_id;
}
/**
 * iodefv2_incident_new_incident_id:
 * @ptr: pointer to a #iodefv2_incident_t object.
 * @ret: pointer to an address where to store the created #iodefv2_incident_id_t object.
 *
 * Create a new incident_id object, children of #iodefv2_incident_t.
 * If @ptr already contain a #iodefv2_incident_id_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_incident_new_incident_id(iodefv2_incident_t *ptr, iodefv2_incident_id_t **ret)
{


        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->incident_id ) {
                retval = iodefv2_incident_id_new(&ptr->incident_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->incident_id;
        return 0;
}



/**
 * iodefv2_incident_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_incident_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_incident_copy(const iodefv2_incident_t *src, iodefv2_incident_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->status = src->status;



        dst->lang_is_set = src->lang_is_set;
        dst->lang = src->lang;



        if ( dst->ext_purpose ) {
                libiodefv2_string_destroy(dst->ext_purpose);
                dst->ext_purpose = NULL;
        }

        if ( src->ext_purpose ) {
                ret = libiodefv2_string_clone(src->ext_purpose, &dst->ext_purpose);
                if ( ret < 0 )
                        return ret;
        }




        dst->purpose = src->purpose;



        if ( dst->ext_status ) {
                libiodefv2_string_destroy(dst->ext_status);
                dst->ext_status = NULL;
        }

        if ( src->ext_status ) {
                ret = libiodefv2_string_clone(src->ext_status, &dst->ext_status);
                if ( ret < 0 )
                        return ret;
        }




        dst->restriction_is_set = src->restriction_is_set;
        dst->restriction = src->restriction;



        if ( dst->observable_id ) {
                libiodefv2_string_destroy(dst->observable_id);
                dst->observable_id = NULL;
        }

        if ( src->observable_id ) {
                ret = libiodefv2_string_clone(src->observable_id, &dst->observable_id);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->history ) {
                iodefv2_history_destroy(dst->history);
                dst->history = NULL;
        }

        if ( src->history ) {
                ret = iodefv2_history_clone(src->history, &dst->history);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->start_time ) {
                iodefv2_time_destroy(dst->start_time);
                dst->start_time = NULL;
        }

        if ( src->start_time ) {
                ret = iodefv2_time_clone(src->start_time, &dst->start_time);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->alternative_id ) {
                iodefv2_alternative_id_destroy(dst->alternative_id);
                dst->alternative_id = NULL;
        }

        if ( src->alternative_id ) {
                ret = iodefv2_alternative_id_clone(src->alternative_id, &dst->alternative_id);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_contact_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->contact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_contact_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->contact_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_contact_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->contact_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->related_activity ) {
                iodefv2_related_activity_destroy(dst->related_activity);
                dst->related_activity = NULL;
        }

        if ( src->related_activity ) {
                ret = iodefv2_related_activity_clone(src->related_activity, &dst->related_activity);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->end_time ) {
                iodefv2_time_destroy(dst->end_time);
                dst->end_time = NULL;
        }

        if ( src->end_time ) {
                ret = iodefv2_time_clone(src->end_time, &dst->end_time);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->generation_time ) {
                iodefv2_time_destroy(dst->generation_time);
                dst->generation_time = NULL;
        }

        if ( src->generation_time ) {
                ret = iodefv2_time_clone(src->generation_time, &dst->generation_time);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_assessment_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->assessment_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_assessment_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->assessment_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_assessment_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->assessment_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_method_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->method_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_method_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->method_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_method_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->method_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->recovery_time ) {
                iodefv2_time_destroy(dst->recovery_time);
                dst->recovery_time = NULL;
        }

        if ( src->recovery_time ) {
                ret = iodefv2_time_clone(src->recovery_time, &dst->recovery_time);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_discovery_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->discovery_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_discovery_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->discovery_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_discovery_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->discovery_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



        if ( dst->detect_time ) {
                iodefv2_time_destroy(dst->detect_time);
                dst->detect_time = NULL;
        }

        if ( src->detect_time ) {
                ret = iodefv2_time_clone(src->detect_time, &dst->detect_time);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->report_time ) {
                iodefv2_time_destroy(dst->report_time);
                dst->report_time = NULL;
        }

        if ( src->report_time ) {
                ret = iodefv2_time_clone(src->report_time, &dst->report_time);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->description ) {
                libiodefv2_string_destroy(dst->description);
                dst->description = NULL;
        }

        if ( src->description ) {
                ret = libiodefv2_string_clone(src->description, &dst->description);
                if ( ret < 0 )
                        return ret;
        }





        if ( dst->indicator_data ) {
                iodefv2_indicator_data_destroy(dst->indicator_data);
                dst->indicator_data = NULL;
        }

        if ( src->indicator_data ) {
                ret = iodefv2_indicator_data_clone(src->indicator_data, &dst->indicator_data);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_event_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->event_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_event_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->event_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_event_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->event_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }




        if ( dst->incident_id ) {
                iodefv2_incident_id_destroy(dst->incident_id);
                dst->incident_id = NULL;
        }

        if ( src->incident_id ) {
                ret = iodefv2_incident_id_clone(src->incident_id, &dst->incident_id);
                if ( ret < 0 )
                        return ret;
        }

    return 0 ;
}


/**
 * iodefv2_incident_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_incident_clone(iodefv2_incident_t *src, iodefv2_incident_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_incident_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_incident_copy(src, *dst);
}


/**
 * iodefv2_incident_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_incident_compare(const iodefv2_incident_t *obj1, const iodefv2_incident_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->status != obj2->status )
                return -1;


        if ( obj1->lang_is_set != obj2->lang_is_set )
                return -1;

        if ( obj1->lang_is_set && obj1->lang != obj2->lang )
                return -1;


        ret = libiodefv2_string_compare(obj1->ext_purpose, obj2->ext_purpose);
        if ( ret != 0 )
                return ret;


        if ( obj1->purpose != obj2->purpose )
                return -1;

        ret = libiodefv2_string_compare(obj1->ext_status, obj2->ext_status);
        if ( ret != 0 )
                return ret;


        if ( obj1->restriction_is_set != obj2->restriction_is_set )
                return -1;

        if ( obj1->restriction_is_set && obj1->restriction != obj2->restriction )
                return -1;


        ret = libiodefv2_string_compare(obj1->observable_id, obj2->observable_id);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_history_compare(obj1->history, obj2->history);
        if ( ret != 0 )
                return ret;

        ret = iodefv2_time_compare(obj1->start_time, obj2->start_time);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_alternative_id_compare(obj1->alternative_id, obj2->alternative_id);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_contact_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->contact_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->contact_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_contact_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_related_activity_compare(obj1->related_activity, obj2->related_activity);
        if ( ret != 0 )
                return ret;

        ret = iodefv2_time_compare(obj1->end_time, obj2->end_time);
        if ( ret != 0 )
                return ret;

        ret = iodefv2_time_compare(obj1->generation_time, obj2->generation_time);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_assessment_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->assessment_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->assessment_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_assessment_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_method_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->method_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->method_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_method_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = iodefv2_time_compare(obj1->recovery_time, obj2->recovery_time);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_discovery_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->discovery_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->discovery_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_discovery_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }

        ret = iodefv2_time_compare(obj1->detect_time, obj2->detect_time);
        if ( ret != 0 )
                return ret;

        ret = iodefv2_time_compare(obj1->report_time, obj2->report_time);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->description, obj2->description);
        if ( ret != 0 )
                return ret;


        ret = iodefv2_indicator_data_compare(obj1->indicator_data, obj2->indicator_data);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_event_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->event_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->event_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_event_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        ret = iodefv2_incident_id_compare(obj1->incident_id, obj2->incident_id);
        if ( ret != 0 )
                return ret;
        return ret;
}


        



/**
 * iodefv2_document_new:
 * @ret: Pointer where to store the created #iodefv2_document_t object.
 *
 * Create a new #iodefv2_document_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_document_new(iodefv2_document_t **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return libiodefv2_error_from_errno(errno);

        (*ret)->_iodefv2_object_id = IODEFV2_CLASS_ID_DOCUMENT;


        (*ret)->refcount = 1;

        libiodefv2_list_init(&(*ret)->additional_data_list);


        libiodefv2_list_init(&(*ret)->incident_list);





        {
            int retval = libiodefv2_string_new(&(*ret)->version);

            if ( retval < 0 ) {
                    iodefv2_document_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }






            return 0;
}


/**
 * iodefv2_document_ref:
 * @document: pointer to a #iodefv2_document_t object.
 *
 * Increase @document reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @document.
 */
iodefv2_document_t *iodefv2_document_ref(iodefv2_document_t *document)
{
        libiodefv2_return_val_if_fail(document, NULL);
        document->refcount++;

        return document;
}



int _iodefv2_document_get_child(void *p, iodefv2_class_child_id_t child, void **childptr)
{
    iodefv2_document_t *ptr = p;

    libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
            case 0:


                         return iodefv2_value_new_enum_from_numeric((iodefv2_value_t **) childptr,
                                                                IODEFV2_CLASS_ID_DOCUMENT_LANG , ptr->lang);


            case 1:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->formatid, TRUE);



            case 2:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->version, TRUE);



            case 3:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->private_enum_name, TRUE);



            case 4:

                         return get_value_from_string((iodefv2_value_t **) childptr,  ptr->private_enum_id, TRUE);


            case 5:
                *childptr = &ptr->additional_data_list;
                return 0;

            case 6:
                *childptr = &ptr->incident_list;
                return 0;

            default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_document_new_child(void *p, iodefv2_class_child_id_t child, int n, void **ret)
{
        iodefv2_document_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {
                case 0:
                    return iodefv2_document_new_lang(ptr, (iodefv2_document_lang_t **) ret);

                case 1:
                    return iodefv2_document_new_formatid(ptr, (libiodefv2_string_t **) ret);

                case 2:
                    return iodefv2_document_new_version(ptr, (libiodefv2_string_t **) ret);

                case 3:
                    return iodefv2_document_new_private_enum_name(ptr, (libiodefv2_string_t **) ret);

                case 4:
                    return iodefv2_document_new_private_enum_id(ptr, (libiodefv2_string_t **) ret);

                case 5: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_document_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_document_new_additional_data(ptr, (iodefv2_additional_data_t **) ret, n);
                }

                case 6: {
                        int i = 0;
                        libiodefv2_list_t *tmp;

                        if ( n == IODEFV2_LIST_APPEND || n == IODEFV2_LIST_PREPEND )
                               return iodefv2_document_new_incident(ptr, (iodefv2_incident_t **) ret, n);

                        if ( n >= 0 ) {
                               libiodefv2_list_for_each(&ptr->incident_list, tmp) {
                                       if ( i++ == n ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               libiodefv2_list_for_each_reversed(&ptr->incident_list, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = libiodefv2_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }

                        return iodefv2_document_new_incident(ptr, (iodefv2_incident_t **) ret, n);
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



int _iodefv2_document_destroy_child(void *p, iodefv2_class_child_id_t child, int n)
{
        iodefv2_document_t *ptr = p;
        libiodefv2_return_val_if_fail(p, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        switch ( child ) {



                case 0:
                    ptr->lang = 0;
                    return 0;




                case 1:
                        if ( ptr->formatid ) {
                                libiodefv2_string_destroy(ptr->formatid);
                                ptr->formatid = NULL;
                        }

                        return 0;




                case 2:
                        if ( ptr->version ) {
                                libiodefv2_string_destroy(ptr->version);
                                ptr->version = NULL;
                        }

                        return 0;




                case 3:
                        if ( ptr->private_enum_name ) {
                                libiodefv2_string_destroy(ptr->private_enum_name);
                                ptr->private_enum_name = NULL;
                        }

                        return 0;




                case 4:
                        if ( ptr->private_enum_id ) {
                                libiodefv2_string_destroy(ptr->private_enum_id);
                                ptr->private_enum_id = NULL;
                        }

                        return 0;

    
                case 5: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->additional_data_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_additional_data_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->additional_data_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_additional_data_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

    
                case 6: {
                    int i = 0;
                    libiodefv2_list_t *tmp;

                    if ( n >= 0 ) {
                            libiodefv2_list_for_each(&ptr->incident_list, tmp) {
                                    if ( i++ == n ) {
                                            void *b = libiodefv2_linked_object_get_object(tmp);
                                            iodefv2_incident_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            libiodefv2_list_for_each_reversed(&ptr->incident_list, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = libiodefv2_linked_object_get_object(tmp);
                                        iodefv2_incident_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_TREE_INDEX_UNDEFINED);
                        }
                }

                default:
                    return libiodefv2_error(LIBIODEFV2_ERROR_IODEFV2_CLASS_UNKNOWN_CHILD);
        }
}



static void iodefv2_document_destroy_internal(iodefv2_document_t *ptr)
{
        libiodefv2_return_if_fail(ptr);



        if ( ptr->formatid ) {
                libiodefv2_string_destroy(ptr->formatid);
                ptr->formatid = NULL;
        }



        if ( ptr->version ) {
                libiodefv2_string_destroy(ptr->version);
                ptr->version = NULL;
        }



        if ( ptr->private_enum_name ) {
                libiodefv2_string_destroy(ptr->private_enum_name);
                ptr->private_enum_name = NULL;
        }



        if ( ptr->private_enum_id ) {
                libiodefv2_string_destroy(ptr->private_enum_id);
                ptr->private_enum_id = NULL;
        }




        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry;

                libiodefv2_list_for_each_safe(&ptr->additional_data_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_additional_data_destroy(entry);
                }
        }


        {
                libiodefv2_list_t *n, *tmp;
                iodefv2_incident_t *entry;

                libiodefv2_list_for_each_safe(&ptr->incident_list, tmp, n) {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        libiodefv2_list_del_init(tmp);
                        iodefv2_incident_destroy(entry);
                }
        }
        /* free() should be done by the caller */
}






/**
 * iodefv2_document_get_lang:
 * @ptr: pointer to a #iodefv2_document_t object.
 *
 * Get lang children of the #iodefv2_document_t object.
 *
 * Returns: a pointer to a iodefv2_document_lang_t object, or NULL if the children object is not set.
 */
iodefv2_document_lang_t iodefv2_document_get_lang(iodefv2_document_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->lang;

}


/**
 * iodefv2_document_set_lang:
 * @ptr: pointer to a #iodefv2_document_t object.
 * @lang: pointer to a #iodefv2_document_lang_t object.
 *
 * Set @lang object as a children of @ptr.
 * if @ptr already contain an @lang object, then it is destroyed,
 * and updated to point to the provided @lang object.
 */
void iodefv2_document_set_lang(iodefv2_document_t *ptr, iodefv2_document_lang_t lang)
{
        libiodefv2_return_if_fail(ptr);
        ptr->lang = lang;
}
/**
 * iodefv2_document_new_lang:
 * @ptr: pointer to a #iodefv2_document_t object.
 * @ret: pointer to an address where to store the created #iodefv2_document_lang_t object.
 *
 * Create a new lang object, children of #iodefv2_document_t.
 * If @ptr already contain a #iodefv2_document_lang_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_document_new_lang(iodefv2_document_t *ptr, iodefv2_document_lang_t **ret)
{



        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        *ret = &ptr->lang;
        return 0;
}




/**
 * iodefv2_document_get_formatid:
 * @ptr: pointer to a #iodefv2_document_t object.
 *
 * Get formatid children of the #iodefv2_document_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_document_get_formatid(iodefv2_document_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->formatid;

}


/**
 * iodefv2_document_set_formatid:
 * @ptr: pointer to a #iodefv2_document_t object.
 * @formatid: pointer to a #libiodefv2_string_t object.
 *
 * Set @formatid object as a children of @ptr.
 * if @ptr already contain an @formatid object, then it is destroyed,
 * and updated to point to the provided @formatid object.
 */

void iodefv2_document_set_formatid(iodefv2_document_t *ptr, libiodefv2_string_t *formatid)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->formatid )
                libiodefv2_string_destroy(ptr->formatid);

        ptr->formatid = formatid;
}
/**
 * iodefv2_document_new_formatid:
 * @ptr: pointer to a #iodefv2_document_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new formatid object, children of #iodefv2_document_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_document_new_formatid(iodefv2_document_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->formatid ) {
                retval = libiodefv2_string_new(&ptr->formatid);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->formatid;
        return 0;
}




/**
 * iodefv2_document_get_version:
 * @ptr: pointer to a #iodefv2_document_t object.
 *
 * Get version children of the #iodefv2_document_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_document_get_version(iodefv2_document_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->version;

}


/**
 * iodefv2_document_set_version:
 * @ptr: pointer to a #iodefv2_document_t object.
 * @version: pointer to a #libiodefv2_string_t object.
 *
 * Set @version object as a children of @ptr.
 * if @ptr already contain an @version object, then it is destroyed,
 * and updated to point to the provided @version object.
 */

void iodefv2_document_set_version(iodefv2_document_t *ptr, libiodefv2_string_t *version)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->version )
                libiodefv2_string_destroy(ptr->version);

        ptr->version = version;
}
/**
 * iodefv2_document_new_version:
 * @ptr: pointer to a #iodefv2_document_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new version object, children of #iodefv2_document_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_document_new_version(iodefv2_document_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->version ) {
                retval = libiodefv2_string_new(&ptr->version);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->version;
        return 0;
}




/**
 * iodefv2_document_get_private_enum_name:
 * @ptr: pointer to a #iodefv2_document_t object.
 *
 * Get private_enum_name children of the #iodefv2_document_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_document_get_private_enum_name(iodefv2_document_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->private_enum_name;

}


/**
 * iodefv2_document_set_private_enum_name:
 * @ptr: pointer to a #iodefv2_document_t object.
 * @private_enum_name: pointer to a #libiodefv2_string_t object.
 *
 * Set @private_enum_name object as a children of @ptr.
 * if @ptr already contain an @private_enum_name object, then it is destroyed,
 * and updated to point to the provided @private_enum_name object.
 */

void iodefv2_document_set_private_enum_name(iodefv2_document_t *ptr, libiodefv2_string_t *private_enum_name)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->private_enum_name )
                libiodefv2_string_destroy(ptr->private_enum_name);

        ptr->private_enum_name = private_enum_name;
}
/**
 * iodefv2_document_new_private_enum_name:
 * @ptr: pointer to a #iodefv2_document_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new private_enum_name object, children of #iodefv2_document_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_document_new_private_enum_name(iodefv2_document_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->private_enum_name ) {
                retval = libiodefv2_string_new(&ptr->private_enum_name);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->private_enum_name;
        return 0;
}




/**
 * iodefv2_document_get_private_enum_id:
 * @ptr: pointer to a #iodefv2_document_t object.
 *
 * Get private_enum_id children of the #iodefv2_document_t object.
 *
 * Returns: a pointer to a libiodefv2_string_t object, or NULL if the children object is not set.
 */
libiodefv2_string_t *iodefv2_document_get_private_enum_id(iodefv2_document_t *ptr)
{
        libiodefv2_return_val_if_fail(ptr, 0); /* FIXME */

        return ptr->private_enum_id;

}


/**
 * iodefv2_document_set_private_enum_id:
 * @ptr: pointer to a #iodefv2_document_t object.
 * @private_enum_id: pointer to a #libiodefv2_string_t object.
 *
 * Set @private_enum_id object as a children of @ptr.
 * if @ptr already contain an @private_enum_id object, then it is destroyed,
 * and updated to point to the provided @private_enum_id object.
 */

void iodefv2_document_set_private_enum_id(iodefv2_document_t *ptr, libiodefv2_string_t *private_enum_id)
{
        libiodefv2_return_if_fail(ptr);
        if ( ptr->private_enum_id )
                libiodefv2_string_destroy(ptr->private_enum_id);

        ptr->private_enum_id = private_enum_id;
}
/**
 * iodefv2_document_new_private_enum_id:
 * @ptr: pointer to a #iodefv2_document_t object.
 * @ret: pointer to an address where to store the created #libiodefv2_string_t object.
 *
 * Create a new private_enum_id object, children of #iodefv2_document_t.
 * If @ptr already contain a #libiodefv2_string_t object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_document_new_private_enum_id(iodefv2_document_t *ptr, libiodefv2_string_t **ret)
{





        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        if ( ! ptr->private_enum_id ) {
                retval = libiodefv2_string_new(&ptr->private_enum_id);
                if ( retval < 0 )
                        return retval;
        }


        *ret = ptr->private_enum_id;
        return 0;
}





/**
 * iodefv2_document_get_next_additional_data:
 * @document: pointer to a #iodefv2_document_t object.
 * @additional_data_cur: pointer to a #iodefv2_additional_data_t object.
 *
 * Get the next #iodefv2_additional_data_t object listed in @ptr.
 * When iterating over the iodefv2_additional_data_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_additional_data_t object.
 *
 * Returns: the next #iodefv2_additional_data_t in the list.
 */
iodefv2_additional_data_t *iodefv2_document_get_next_additional_data(iodefv2_document_t *document, iodefv2_additional_data_t *additional_data_cur)
{
        libiodefv2_list_t *tmp = (additional_data_cur) ? &((libiodefv2_linked_object_t *) additional_data_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(document, NULL);

        libiodefv2_list_for_each_continue(&document->additional_data_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_document_set_additional_data:
 * @ptr: pointer to a #iodefv2_document_t object.
 * @object: pointer to a #iodefv2_additional_data_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_additional_data_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_document_set_additional_data(iodefv2_document_t *ptr, iodefv2_additional_data_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_document_new_additional_data:
 *  @ptr: pointer to a #iodefv2_document_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_additional_data_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_additional_data_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_additional_data_t object. The created #iodefv2_additional_data_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_document_new_additional_data(iodefv2_document_t *ptr, iodefv2_additional_data_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_additional_data_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->additional_data_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}





/**
 * iodefv2_document_get_next_incident:
 * @document: pointer to a #iodefv2_document_t object.
 * @incident_cur: pointer to a #iodefv2_incident_t object.
 *
 * Get the next #iodefv2_incident_t object listed in @ptr.
 * When iterating over the iodefv2_incident_t object listed in @ptr,
 * @object should be set to the latest returned #iodefv2_incident_t object.
 *
 * Returns: the next #iodefv2_incident_t in the list.
 */
iodefv2_incident_t *iodefv2_document_get_next_incident(iodefv2_document_t *document, iodefv2_incident_t *incident_cur)
{
        libiodefv2_list_t *tmp = (incident_cur) ? &((libiodefv2_linked_object_t *) incident_cur)->_list : NULL;

        libiodefv2_return_val_if_fail(document, NULL);

        libiodefv2_list_for_each_continue(&document->incident_list, tmp)
                return libiodefv2_linked_object_get_object(tmp);

        return NULL;
}


/**
 * iodefv2_document_set_incident:
 * @ptr: pointer to a #iodefv2_document_t object.
 * @object: pointer to a #iodefv2_incident_t object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #iodefv2_incident_t object.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void iodefv2_document_set_incident(iodefv2_document_t *ptr, iodefv2_incident_t *object, int pos)
{
        libiodefv2_return_if_fail(ptr);
        libiodefv2_return_if_fail(object);

        if ( ! libiodefv2_list_is_empty(&((libiodefv2_linked_object_t *) object)->_list) )
                libiodefv2_list_del_init(&((libiodefv2_linked_object_t *) object)->_list);

        list_insert(&ptr->incident_list, &((libiodefv2_linked_object_t *) object)->_list, pos);
}


/**
 * iodefv2_document_new_incident:
 *  @ptr: pointer to a #iodefv2_document_t object.
 *  @ret: pointer to an address where to store the created #iodefv2_incident_t object.
 *  @pos: position in the list.
 *
 * Create a new #iodefv2_incident_t children of @ptr, and add it to position @pos of
 * @ptr list of #iodefv2_incident_t object. The created #iodefv2_incident_t object is
 * stored in @ret.
 *
 * If @pos is #IODEFV2_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #IODEFV2_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int iodefv2_document_new_incident(iodefv2_document_t *ptr, iodefv2_incident_t **ret, int pos)
{
        int retval;

        libiodefv2_return_val_if_fail(ptr, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        retval = iodefv2_incident_new(ret);
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->incident_list, &((libiodefv2_linked_object_t *)(*ret))->_list, pos);

        return 0;
}



/**
 * iodefv2_document_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_document_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_document_copy(const iodefv2_document_t *src, iodefv2_document_t *dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));
        libiodefv2_return_val_if_fail(dst, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = 0;



        dst->lang = src->lang;



        if ( dst->formatid ) {
                libiodefv2_string_destroy(dst->formatid);
                dst->formatid = NULL;
        }

        if ( src->formatid ) {
                ret = libiodefv2_string_clone(src->formatid, &dst->formatid);
                if ( ret < 0 )
                        return ret;
        }



        if ( src->version ) {
                ret = libiodefv2_string_copy(src->version, dst->version);
                if ( ret < 0 )
                        return ret;
        }



        if ( dst->private_enum_name ) {
                libiodefv2_string_destroy(dst->private_enum_name);
                dst->private_enum_name = NULL;
        }

        if ( src->private_enum_name ) {
                ret = libiodefv2_string_clone(src->private_enum_name, &dst->private_enum_name);
                if ( ret < 0 )
                        return ret;
        }




        if ( dst->private_enum_id ) {
                libiodefv2_string_destroy(dst->private_enum_id);
                dst->private_enum_id = NULL;
        }

        if ( src->private_enum_id ) {
                ret = libiodefv2_string_clone(src->private_enum_id, &dst->private_enum_id);
                if ( ret < 0 )
                        return ret;
        }




         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_additional_data_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->additional_data_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_additional_data_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->additional_data_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }



         {
                libiodefv2_list_t *n, *tmp;
                iodefv2_incident_t *entry, *new;
                libiodefv2_list_for_each_safe(&dst->incident_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_incident_destroy(entry);
                 }

                libiodefv2_list_for_each_safe(&src->incident_list, tmp, n)  {
                        entry = libiodefv2_linked_object_get_object(tmp);
                        iodefv2_incident_clone(entry, &new);
                        libiodefv2_list_add_tail(&dst->incident_list, &((libiodefv2_linked_object_t *) new)->_list);
                 }

 }
    return 0 ;
}


/**
 * iodefv2_document_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int iodefv2_document_clone(iodefv2_document_t *src, iodefv2_document_t **dst)
{
        int ret;

        libiodefv2_return_val_if_fail(src, libiodefv2_error(LIBIODEFV2_ERROR_ASSERTION));

        ret = iodefv2_document_new(dst);
        if ( ret < 0 )
                return ret;

        return iodefv2_document_copy(src, *dst);
}


/**
 * iodefv2_document_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int iodefv2_document_compare(const iodefv2_document_t *obj1, const iodefv2_document_t *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;


        if ( obj1->lang != obj2->lang )
                return -1;

        ret = libiodefv2_string_compare(obj1->formatid, obj2->formatid);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->version, obj2->version);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->private_enum_name, obj2->private_enum_name);
        if ( ret != 0 )
                return ret;

        ret = libiodefv2_string_compare(obj1->private_enum_id, obj2->private_enum_id);
        if ( ret != 0 )
                return ret;


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_additional_data_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->additional_data_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->additional_data_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_additional_data_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }


        {
            libiodefv2_list_t *tmp1, *tmp2;
            iodefv2_incident_t *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        libiodefv2_list_for_each_continue(&obj1->incident_list, tmp1) {
                                entry1 = libiodefv2_linked_object_get_object(tmp1);
                                break;
                         }

                        libiodefv2_list_for_each_continue(&obj2->incident_list, tmp2)  {
                                entry2 = libiodefv2_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = iodefv2_incident_compare(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
        return ret;
}



int _iodefv2_additional_data_type_is_set(iodefv2_additional_data_t *ad)
{
        return ad->_type_is_set;
}

/**
 * iodefv2_document_destroy:
 * @ptr: pointer to a #iodefv2_document_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void iodefv2_document_destroy(iodefv2_document_t *ptr)
{
        libiodefv2_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        iodefv2_document_destroy_internal(ptr);


        free(ptr);
}


