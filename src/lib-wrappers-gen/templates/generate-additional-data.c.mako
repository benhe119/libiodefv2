<%!
import sys
sys.path.append('../')
from field import Struct, Union, DataType, Multiplicity, Field, EnumField, PreDeclared
string_ad_type_list = []
%>
/*****
*
* Copyright (C) 2004-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@prelude-ids.com>
*
* This file is part of the ${prefix.capitalize()} library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/*
 * This file was automatically generated by our generator, version ${generator_version}
 *
 * Do not make changes to this file unless you know what you are doing.
 * modify the template interface file instead.
 * ${name_lib.upper()} version : ${lib_version}
 * Template file: generate-additional-data.c.mako
 *
 */

<%
type_map = {
     name_lib.upper() + '_ADDITIONAL_DATA_TYPE_BYTE':        {"dtype": name_lib.upper() + "_DATA_TYPE_BYTE", "dsize": "sizeof(uint8_t)", "ctype": "uint8_t"                          },
     name_lib.upper() + '_ADDITIONAL_DATA_TYPE_CHARACTER':   {"dtype": name_lib.upper() + "_DATA_TYPE_CHAR", "dsize": "sizeof(char)", "ctype": "char"                                },
     name_lib.upper() + '_ADDITIONAL_DATA_TYPE_INTEGER':     {"dtype": name_lib.upper() + "_DATA_TYPE_INT", "dsize": "sizeof(uint64_t)", "ctype": "uint32_t"                         },
     name_lib.upper() + '_ADDITIONAL_DATA_TYPE_NTPSTAMP':    {"dtype": name_lib.upper() + "_DATA_TYPE_INT", "dsize": "sizeof(uint64_t)", "ctype": "uint64_t"                         },
     name_lib.upper() + '_ADDITIONAL_DATA_TYPE_REAL':        {"dtype": name_lib.upper() + "_DATA_TYPE_FLOAT", "dsize": "sizeof(float)", "ctype": "float"                             },
     name_lib.upper() + '_ADDITIONAL_DATA_TYPE_BYTE_STRING': {"dtype": name_lib.upper() + "_DATA_TYPE_BYTE_STRING", "dsize": "0", "ctype": "uint8_t"                                 },
     name_lib.upper() + '_ADDITIONAL_DATA_TYPE_DATE_TIME':   {"dtype": name_lib.upper() + "_DATA_TYPE_TIME", "dsize": "0", "ctype": "uint8_t"                                        },
     name_lib.upper() + '_ADDITIONAL_DATA_TYPE_BOOLEAN':     {"dtype": name_lib.upper() + "_DATA_TYPE_BYTE", "dsize": "sizeof(%s_bool_t)" % (prefix), "ctype":"%s_bool_t" % (prefix) }
}
def get_dtype(adtype):
    ret = type_map.get(adtype, {"dtype": name_lib.upper() + "_DATA_TYPE_CHAR_STRING", "dsize": "0", "ctype": "string"}).get("dtype")
    if ret == name_lib.upper() + "_DATA_TYPE_CHAR_STRING":
        if adtype not in string_ad_type_list:
            string_ad_type_list.append(adtype)

    return ret

def get_dsize(adtype):
    return type_map.get(adtype, {"dtype": name_lib.upper() + "_DATA_TYPE_CHAR_STRING", "dsize": "0", "ctype": "string"}).get("dsize")

def get_ctype(adtype):
    return type_map.get(adtype, {"dtype": name_lib.upper() + "_DATA_TYPE_CHAR_STRING", "dsize": "0", "ctype": "string"}).get("ctype")
%>
#include "libmissing.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <netinet/in.h>

#include "${prefix}-log.h"
#include "${prefix}-string.h"
#include "${prefix}-error.h"
#include "${prefix}-inttypes.h"
#include "${name_lib}.h"
#include "${name_lib}-tree-wrap.h"
#include "${name_lib}-additional-data.h"
#include "${name_lib}-document-id.h"

#define ${name_lib.upper()}_ADDITIONAL_DATA_ACCESSOR(name, type)                                                             <%text>\</%text>
int ${name_lib}_additional_data_new_ <%text>##</%text> name <%text>##</%text> _ref_fast(${name_lib}_additional_data_t **ad, const char *data, size_t len)<%text>\</%text>
{                                                                                                              <%text>\</%text>
        return ${name_lib}_additional_data_new_ptr_ref_fast(ad, ${name_lib.upper()}_ADDITIONAL_DATA_TYPE_ <%text>##</%text> type, data, len + 1);        <%text>\</%text>
}                                                                                                                                                        <%text>\</%text>
                                                                                                                                                         <%text>\</%text>
int ${name_lib}_additional_data_new_ <%text>##</%text> name <%text>##</%text> _ref(${name_lib}_additional_data_t **ad, const char *data)                 <%text>\</%text>
{                                                                                                                                                        <%text>\</%text>
        return ${name_lib}_additional_data_new_ <%text>##</%text> name <%text>##</%text> _ref_fast(ad, data, strlen(data));                              <%text>\</%text>
}                                                                                                                                                        <%text>\</%text>
                                                                                                                                                         <%text>\</%text>
int ${name_lib}_additional_data_set_ <%text>##</%text> name <%text>##</%text> _ref_fast(${name_lib}_additional_data_t *ad, const char *data, size_t len) <%text>\</%text>
{                                                                                                                                                        <%text>\</%text>
        return ${name_lib}_additional_data_set_ptr_ref_fast(ad, ${name_lib.upper()}_ADDITIONAL_DATA_TYPE_ <%text>##</%text> type, data, len + 1);        <%text>\</%text>
}                                                                                                                                                        <%text>\</%text>
                                                                                                                                                         <%text>\</%text>
int ${name_lib}_additional_data_set_ <%text>##</%text> name <%text>##</%text> _ref(${name_lib}_additional_data_t *ad, const char *data)                  <%text>\</%text>
{                                                                                                                                                        <%text>\</%text>
        return ${name_lib}_additional_data_set_ <%text>##</%text> name <%text>##</%text> _ref_fast(ad, data, strlen(data));                              <%text>\</%text>
}                                                                                                                                                        <%text>\</%text>
                                                                                                                                                         <%text>\</%text>
int ${name_lib}_additional_data_new_ <%text>##</%text> name <%text>##</%text> _dup_fast(${name_lib}_additional_data_t **ad, const char *data, size_t len)<%text>\</%text>
{                                                                                                                                                        <%text>\</%text>
        return ${name_lib}_additional_data_new_ptr_dup_fast(ad, ${name_lib.upper()}_ADDITIONAL_DATA_TYPE_ <%text>##</%text> type, data, len + 1);        <%text>\</%text>
}                                                                                                                                                       <%text>\</%text>
                                                                                                               <%text>\</%text>
int ${name_lib}_additional_data_new_ <%text>##</%text> name <%text>##</%text> _dup(${name_lib}_additional_data_t **ad, const char *data)                 <%text>\</%text>
{                                                                                                              <%text>\</%text>
        return ${name_lib}_additional_data_new_ <%text>##</%text> name <%text>##</%text> _dup_fast(ad, data, strlen(data));                        <%text>\</%text>
}                                                                                                              <%text>\</%text>
                                                                                                               <%text>\</%text>
int ${name_lib}_additional_data_set_ <%text>##</%text> name <%text>##</%text> _dup_fast(${name_lib}_additional_data_t *ad, const char *data, size_t len) <%text>\</%text>
{                                                                                                              <%text>\</%text>
        return ${name_lib}_additional_data_set_ptr_dup_fast(ad, ${name_lib.upper()}_ADDITIONAL_DATA_TYPE_ <%text>##</%text> type, data, len + 1); <%text>\</%text>
}                                                                                                              <%text>\</%text>
                                                                                                               <%text>\</%text>
int ${name_lib}_additional_data_set_ <%text>##</%text> name <%text>##</%text> _dup(${name_lib}_additional_data_t *ad, const char *data)                  <%text>\</%text>
{                                                                                                                                                   <%text>\</%text>
        return ${name_lib}_additional_data_set_ <%text>##</%text> name <%text>##</%text> _dup_fast(ad, data, strlen(data));                        <%text>\</%text>
}                                                                                                              <%text>\</%text>
                                                                                                               <%text>\</%text>
int ${name_lib}_additional_data_new_ <%text>##</%text> name <%text>##</%text> _nodup_fast(${name_lib}_additional_data_t **ad, char *data, size_t len)    <%text>\</%text>
{                                                                                                                   <%text>\</%text>
        return ${name_lib}_additional_data_new_ptr_nodup_fast(ad, ${name_lib.upper()}_ADDITIONAL_DATA_TYPE_ <%text>##</%text> type, data, len + 1);<%text>\</%text>
}                                                                                                              <%text>\</%text>
                                                                                                               <%text>\</%text>
int ${name_lib}_additional_data_new_ <%text>##</%text> name <%text>##</%text> _nodup(${name_lib}_additional_data_t **ad, char *data)                     <%text>\</%text>
{                                                                                                              <%text>\</%text>
        return ${name_lib}_additional_data_new_ <%text>##</%text> name <%text>##</%text> _nodup_fast(ad, data, strlen(data));                      <%text>\</%text>
}                                                                                                              <%text>\</%text>
                                                                                                               <%text>\</%text>
int ${name_lib}_additional_data_set_ <%text>##</%text> name <%text>##</%text> _nodup_fast(${name_lib}_additional_data_t *ad, char *data, size_t len)     <%text>\</%text>
{                                                                                                              <%text>\</%text>
        return ${name_lib}_additional_data_set_ptr_nodup_fast(ad, ${name_lib.upper()}_ADDITIONAL_DATA_TYPE_ <%text>##</%text> type, data, len + 1);<%text>\</%text>
}                                                                                                              <%text>\</%text>
                                                                                                               <%text>\</%text>
int ${name_lib}_additional_data_set_ <%text>##</%text> name <%text>##</%text> _nodup(${name_lib}_additional_data_t *ad, char *data)                      <%text>\</%text>
{                                                                                                              <%text>\</%text>
        return ${name_lib}_additional_data_set_ <%text>##</%text> name <%text>##</%text> _nodup_fast(ad, data, strlen(data));                      <%text>\</%text>
}


#define ${name_lib.upper()}_ADDITIONAL_DATA_SIMPLE(d_type, d_name, ad_type, c_type, name)                          <%text>\</%text>
int ${name_lib}_additional_data_new_ <%text>##</%text> name(${name_lib}_additional_data_t **ret, c_type val)       <%text>\</%text>
{                                                                                                                   <%text>\</%text>
        int retval;                                                                                                 <%text>\</%text>
                                                                                                                    <%text>\</%text>
        retval = ${name_lib}_additional_data_new(ret);                                                               <%text>\</%text>
        if ( retval < 0 )                                                                                             <%text>\</%text>
                return retval;                                                               <%text>\</%text>
                                                                                       <%text>\</%text>
        ${name_lib}_additional_data_set_type(*ret, ad_type);                                       <%text>\</%text>
        ${name_lib}_data_set_ <%text>##</%text> d_name(${name_lib}_additional_data_get_data(*ret), val);               <%text>\</%text>
                                                                                       <%text>\</%text>
        return retval;                                                                       <%text>\</%text>
}                                                                                       <%text>\</%text>
                                                                                       <%text>\</%text>
void ${name_lib}_additional_data_set_ <%text>##</%text> name(${name_lib}_additional_data_t *ptr, c_type val)       <%text>\</%text>
{                                                                                       <%text>\</%text>
        ${name_lib}_additional_data_set_type(ptr, ad_type);                                       <%text>\</%text>
        ${name_lib}_data_set_ <%text>##</%text> d_name(${name_lib}_additional_data_get_data(ptr), val);               <%text>\</%text>
}                                                                                       <%text>\</%text>
                                                                                       <%text>\</%text>
c_type ${name_lib}_additional_data_get_ <%text>##</%text> name(${name_lib}_additional_data_t *ptr)                       <%text>\</%text>
{                                                                                       <%text>\</%text>
        return ${name_lib}_data_get_ <%text>##</%text> d_name(${name_lib}_additional_data_get_data(ptr));               <%text>\</%text>
}



/*
 * Backward compatibility stuff, remove once 0.9.0 is released.
 */
int ${name_lib}_additional_data_new_ptr_ref_fast(${name_lib}_additional_data_t **nd,
                                           ${name_lib}_additional_data_type_t type,
                                           const void *ptr, size_t len);

int ${name_lib}_additional_data_new_ptr_dup_fast(${name_lib}_additional_data_t **nd,
                                           ${name_lib}_additional_data_type_t type,
                                           const void *ptr, size_t len);

int ${name_lib}_additional_data_new_ptr_nodup_fast(${name_lib}_additional_data_t **nd,
                                             ${name_lib}_additional_data_type_t type,
                                             void *ptr, size_t len);

int ${name_lib}_additional_data_set_ptr_ref_fast(${name_lib}_additional_data_t *data,
                                           ${name_lib}_additional_data_type_t type, const void *ptr, size_t len);

int ${name_lib}_additional_data_set_ptr_dup_fast(${name_lib}_additional_data_t *data,
                                           ${name_lib}_additional_data_type_t type, const void *ptr, size_t len);

int ${name_lib}_additional_data_set_ptr_nodup_fast(${name_lib}_additional_data_t *data,
                                             ${name_lib}_additional_data_type_t type, void *ptr, size_t len);



static const struct {
        ${name_lib}_additional_data_type_t ad_type;
        ${name_lib}_data_type_t d_type;
        size_t len;
} ${name_lib}_additional_data_type_table[] = {
% for obj in lib_classes.obj_list:
% if obj.short_type_name == "additional_data":
% for field in obj.enum_list:
% if field.short_type_name == "additional_data_type":
% for member in field.enum_members[:-1]:
        { ${member.name}, ${get_dtype(member.name)}, ${get_dsize(member.name)} },
%endfor
        { ${field.enum_members[-1].name}, ${get_dtype(field.enum_members[-1].name)}, ${get_dtype(field.enum_members[-1].name)} }
};
% endif
% endfor
% endif
% endfor

static int check_type(${name_lib}_additional_data_type_t type, const unsigned char *buf, size_t len)
{
        if ( type < 0 || (size_t) type >= sizeof(${name_lib}_additional_data_type_table) / sizeof(*${name_lib}_additional_data_type_table) )
                return ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "Invalid ${name_lib.upper()}AdditionalData type specified");

        if ( ${name_lib}_additional_data_type_table[type].len != 0 &&
             len > ${name_lib}_additional_data_type_table[type].len )
                return ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "Provided value length does not match specified type length");

        if ( ${name_lib}_additional_data_type_table[type].len == 0 && len < 1 )
                return ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "Invalid value length for this type");
<%
exp_ad_type = ""
for ad_type in string_ad_type_list[:-1]:
    exp_ad_type += ("type == %s || \n                " % (ad_type))
exp_ad_type += string_ad_type_list[-1]
%>
        if ( ${exp_ad_type} )
                return buf[len - 1] == '\0' ? 0 : ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "String is not nul terminated");

        return 0;
}



static ${name_lib}_data_type_t ${name_lib}_additional_data_type_to_data_type(${name_lib}_additional_data_type_t type)
{
        if ( type < 0 || (size_t) type >= sizeof(${name_lib}_additional_data_type_table) / sizeof(*${name_lib}_additional_data_type_table) )
                return ${name_lib.upper()}_DATA_TYPE_UNKNOWN;

        return ${name_lib}_additional_data_type_table[type].d_type;
}



int ${name_lib}_additional_data_new_ptr_ref_fast(${name_lib}_additional_data_t **nd,
                                           ${name_lib}_additional_data_type_t type,
                                           const void *ptr, size_t len)
{
        int ret;
        ${name_lib}_data_type_t dtype;

        ret = check_type(type, ptr, len);
        if ( ret < 0 )
                return ret;

        ret = ${name_lib}_additional_data_new(nd);
        if ( ret < 0 )
                return ret;

        ${name_lib}_additional_data_set_type(*nd, type);
        dtype = ${name_lib}_additional_data_type_to_data_type(type);

        ret = ${name_lib}_data_set_ptr_ref_fast(${name_lib}_additional_data_get_data(*nd), dtype, ptr, len);
        if ( ret < 0 ) {
                ${name_lib}_additional_data_destroy(*nd);
                return ret;
        }

        return 0;
}



int ${name_lib}_additional_data_new_ptr_dup_fast(${name_lib}_additional_data_t **nd,
                                           ${name_lib}_additional_data_type_t type,
                                           const void *ptr, size_t len)
{
        int ret;
        ${name_lib}_data_type_t dtype;

        ret = check_type(type, ptr, len);
        if ( ret < 0 )
                return ret;

        ret = ${name_lib}_additional_data_new(nd);
        if ( ret < 0 )
                return ret;

        ${name_lib}_additional_data_set_type(*nd, type);
        dtype = ${name_lib}_additional_data_type_to_data_type(type);

        ret = ${name_lib}_data_set_ptr_dup_fast(${name_lib}_additional_data_get_data(*nd), dtype, ptr, len);
        if ( ret < 0 ) {
                ${name_lib}_additional_data_destroy(*nd);
                return ret;
        }

        return 0;
}



int ${name_lib}_additional_data_new_ptr_nodup_fast(${name_lib}_additional_data_t **nd,
                                             ${name_lib}_additional_data_type_t type,
                                             void *ptr, size_t len)
{
        int ret;
        ${name_lib}_data_type_t dtype;

        ret = check_type(type, ptr, len);
        if ( ret < 0 )
                return ret;

        ret = ${name_lib}_additional_data_new(nd);
        if ( ret < 0 )
                return ret;

        ${name_lib}_additional_data_set_type(*nd, type);
        dtype = ${name_lib}_additional_data_type_to_data_type(type);

        ret = ${name_lib}_data_set_ptr_nodup_fast(${name_lib}_additional_data_get_data(*nd), dtype, ptr, len);
        if ( ret < 0 ) {
                ${name_lib}_additional_data_destroy(*nd);
                return ret;
        }

        return ret;
}



int ${name_lib}_additional_data_set_ptr_ref_fast(${name_lib}_additional_data_t *data,
                                           ${name_lib}_additional_data_type_t type, const void *ptr, size_t len)
{
        int ret;

        ret = check_type(type, ptr, len);
        if ( ret < 0 )
                return ret;

        ${name_lib}_additional_data_set_type(data, type);

        return ${name_lib}_data_set_ptr_ref_fast(${name_lib}_additional_data_get_data(data),
                                           ${name_lib}_additional_data_type_to_data_type(type), ptr, len);
}



int ${name_lib}_additional_data_set_ptr_dup_fast(${name_lib}_additional_data_t *data,
                                           ${name_lib}_additional_data_type_t type, const void *ptr, size_t len)
{
        int ret;

        ret = check_type(type, ptr, len);
        if ( ret < 0 )
                return ret;

        ${name_lib}_additional_data_set_type(data, type);

        return ${name_lib}_data_set_ptr_dup_fast(${name_lib}_additional_data_get_data(data),
                                           ${name_lib}_additional_data_type_to_data_type(type), ptr, len);
}


int ${name_lib}_additional_data_set_ptr_nodup_fast(${name_lib}_additional_data_t *data,
                                             ${name_lib}_additional_data_type_t type, void *ptr, size_t len)
{
        int ret;

        ret = check_type(type, ptr, len);
        if ( ret < 0 )
                return ret;

        ${name_lib}_additional_data_set_type(data, type);

        return ${name_lib}_data_set_ptr_nodup_fast(${name_lib}_additional_data_get_data(data),
                                             ${name_lib}_additional_data_type_to_data_type(type), ptr, len);
}
/*
 * Declare stuff
 */
% for obj in lib_classes.obj_list:
% if obj.short_type_name == "additional_data":
% for field in obj.enum_list:
% if field.short_type_name == "additional_data_type":
% for member in field.enum_members:
% if member.short_name in ['real','byte','integer','boolean','character', "ntpstamp"]:
${name_lib.upper()}_ADDITIONAL_DATA_SIMPLE(${get_dtype(member.name.upper())}, ${get_dtype(member.name).split("_")[-1].lower()}, ${member.name}, ${get_ctype(member.name)}, ${member.short_name})
% else:
${name_lib.upper()}_ADDITIONAL_DATA_ACCESSOR(${member.short_name}, ${member.short_name.upper()})
% endif
%endfor
% endif
% endfor
% endif
% endfor
/*
 * just make a pointer copy of the embedded data
 */
int ${name_lib}_additional_data_copy_ref(${name_lib}_additional_data_t *src, ${name_lib}_additional_data_t *dst)
{
        int ret;

        ret = ${prefix}_string_copy_ref(${name_lib}_additional_data_get_meaning(src), ${name_lib}_additional_data_get_meaning(dst));
        if ( ret < 0 )
                return ret;

        ${name_lib}_additional_data_set_type(dst, ${name_lib}_additional_data_get_type(src));

        return ${name_lib}_data_copy_ref(${name_lib}_additional_data_get_data(src), ${name_lib}_additional_data_get_data(dst));
}


/*
 * also copy the content of the embedded data
 */
int ${name_lib}_additional_data_copy_dup(${name_lib}_additional_data_t *src, ${name_lib}_additional_data_t *dst)
{
        int ret;

        ret = ${prefix}_string_copy_dup(${name_lib}_additional_data_get_meaning(src), ${name_lib}_additional_data_get_meaning(dst));
        if ( ret < 0 )
                return ret;

        ${name_lib}_additional_data_set_type(dst, ${name_lib}_additional_data_get_type(src));

        return ${name_lib}_data_copy_dup(${name_lib}_additional_data_get_data(src), ${name_lib}_additional_data_get_data(dst));
}


size_t ${name_lib}_additional_data_get_len(${name_lib}_additional_data_t *data)
{
        return ${name_lib}_data_get_len(${name_lib}_additional_data_get_data(data));
}



${prefix}_bool_t ${name_lib}_additional_data_is_empty(${name_lib}_additional_data_t *data)
{
        return ${name_lib}_data_is_empty(${name_lib}_additional_data_get_data(data));
}




int ${name_lib}_additional_data_data_to_string(${name_lib}_additional_data_t *ad, ${prefix}_string_t *out)
{
        int ret;
        uint64_t i;
        ${name_lib}_data_t *data;

        data = ${name_lib}_additional_data_get_data(ad);
        if ( ${name_lib}_data_is_empty(data) )
                return 0;
% for obj in lib_classes.obj_list:
% if obj.short_type_name == "additional_data":
% for field in obj.enum_list:
% if field.short_type_name == "additional_data_type":
<% ntpstamp = False %>
% for member in field.enum_members:
% if member.short_name == "ntpstamp":
    <% ntpstamp = True %>
% endif
% endfor
% endif
% endfor
% endif
% endfor
% if ntpstamp:
    switch ( ${name_lib}_additional_data_get_type(ad) ) {

        case ${name_lib.upper()}_ADDITIONAL_DATA_TYPE_NTPSTAMP:
                i = ${name_lib}_data_get_int(data);
                ret = ${prefix}_string_sprintf(out, <%text>"0x%"</%text> ${prefix.upper()}_PRIx32 <%text>".0x%"</%text> ${prefix.upper()}_PRIx32, (uint32_t) (i >> 32), (uint32_t) i);
                break;

        default:
                ret = ${name_lib}_data_to_string(data, out);
                break;
        }
% else:
        ret = ${name_lib}_data_to_string(data, out);
% endif
        return ret;

}
% for obj in lib_classes.obj_list:
% if obj.short_type_name == "additional_data":
% for field in obj.enum_list:
% if field.short_type_name == "additional_data_type":
% if field.vtype_members["byte[]"] != []:
/*
 * byte-string specific stuff
 */

int ${name_lib}_additional_data_new_byte_string_ref(${name_lib}_additional_data_t **ad, const unsigned char *data, size_t len)
{
        return ${name_lib}_additional_data_new_ptr_ref_fast(ad, ${field.vtype_members["byte[]"][0]}, data, len);
}

int ${name_lib}_additional_data_set_byte_string_ref(${name_lib}_additional_data_t *ad, const unsigned char *data, size_t len)
{
         return ${name_lib}_additional_data_set_ptr_ref_fast(ad, ${field.vtype_members["byte[]"][0]}, data, len);
}

int ${name_lib}_additional_data_new_byte_string_dup(${name_lib}_additional_data_t **ad, const unsigned char *data, size_t len)
{
        return ${name_lib}_additional_data_new_ptr_dup_fast(ad, ${field.vtype_members["byte[]"][0]}, data, len);
}

int ${name_lib}_additional_data_set_byte_string_dup(${name_lib}_additional_data_t *ad, const unsigned char *data, size_t len)
{
        return ${name_lib}_additional_data_set_ptr_dup_fast(ad, ${field.vtype_members["byte[]"][0]}, data, len);
}

int ${name_lib}_additional_data_new_byte_string_nodup(${name_lib}_additional_data_t **ad, unsigned char *data, size_t len)
{
        return ${name_lib}_additional_data_new_ptr_nodup_fast(ad, ${field.vtype_members["byte[]"][0]}, data, len);
}

int ${name_lib}_additional_data_set_byte_string_nodup(${name_lib}_additional_data_t *ad, unsigned char *data, size_t len)
{
        return ${name_lib}_additional_data_set_ptr_nodup_fast(ad, ${field.vtype_members["byte[]"][0]}, data, len);
}
% endif
% endif
% endfor
% endif
% endfor
