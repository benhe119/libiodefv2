<%!
import sys
sys.path.append('../')
from field import Struct, EnumField, Union, DataType, Field, PreDeclared
%>
<%def name="header()">
/*****
*
* Copyright (C) 2001-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@prelude-ids.com>
* Author: Nicolas Delon <nicolas.delon@prelude-ids.com>
*
* This file is part of the ${prefix.capitalize()} library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/*
 * This file was automatically generated by our generator, version ${generator_version}
 *
 * Do not make changes to this file unless you know what you are doing.
 * modify the template interface file instead.
 * ${name_lib.upper()} version : ${lib_version}
 * Template file: generate-tree-wrap.c.mako
 *
 */

#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/types.h>

#include "${prefix}-inttypes.h"
#include "${prefix}-list.h"
#include "${prefix}-string.h"

#define ${prefix.upper()}_ERROR_SOURCE_DEFAULT ${prefix.upper()}_ERROR_SOURCE_${name_lib.upper()}_TREE_WRAP
#include "${prefix}-error.h"

#include "${name_lib}-time.h"
#include "${name_lib}-data.h"
#include "${name_lib}-class.h"
#include "${name_lib}-value.h"
#include "${name_lib}-object-prv.h"

#include "${name_lib}-tree-wrap.h"
#include "libmissing.h"
#include "common.h"

#ifdef WIN32
# undef interface
#endif


#define LISTED_OBJECT(name, type) ${prefix}_list_t name
#define KEYLISTED_OBJECT(name, type) ${prefix}_list_t name

#define IS_KEY_LISTED(keyfield) ${name_lib.upper()}_LINKED_OBJECT; ${prefix}_string_t *keyfield

#define UNION(type, var) type var; union

#define UNION_MEMBER(value, type, name) type name

#define ENUM(...) typedef enum

#define PRE_DECLARE(type, class)

#define TYPE_ID(type, id) type

#define PRIMITIVE_TYPE(type)
#define PRIMITIVE_TYPE_STRUCT(type)

#define HIDE(type, name) type name

#define REFCOUNT int refcount
#define REQUIRED(type, name) type name
#define IGNORED(type, name) type name

#define DYNAMIC_IDENT(x) uint64_t x

#define OPTIONAL_INT(type, name) type name; unsigned int name ## _is_set:1

#define IDENT(name) uint64_t name


#define ${name_lib}_data_copy ${name_lib}_data_copy_dup

#ifndef ABS
# define ABS(x) (((x) < 0) ? -(x) : (x))
#endif


/*
 * If we subtract the integer representations of two floats then that
 * will tell us how close they are. If the difference is zero, they are
 * identical. If the difference is one, they are adjacent floats.
 * In general, if the difference is n then there are n-1 floats between
 * them.
 *
 * http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm
 */
static int float_compare(float a, float b)
{
        union {
                float fval;
                int32_t ival;
        } au, bu;

        au.fval = a;
        bu.fval = b;

        /* Make aInt lexicographically ordered as a twos-complement int */
        if ( au.ival < 0 )
                au.ival = 0x80000000 - au.ival;

        /* Make bInt lexicographically ordered as a twos-complement int */
        if ( bu.ival < 0 )
                bu.ival = 0x80000000 - bu.ival;

        return (ABS(au.ival - bu.ival) <= 0) ? 0 : -1;
}



static int ${prefix}_string_copy(const ${prefix}_string_t *src, ${prefix}_string_t *dst)
{
        ${prefix}_return_val_if_fail(src, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));
        ${prefix}_return_val_if_fail(dst, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));

        if ( ! ${prefix}_string_is_empty(src) )
               return ${prefix}_string_copy_dup(src, dst);

        return 0;
}



static int get_value_from_string(${name_lib}_value_t **value, ${prefix}_string_t *str, ${prefix}_bool_t is_ptr)
{
        int ret;

        if ( ! str ) {
                *value = NULL;
                return 0;
        }

        if ( ! is_ptr ) {
                ret = ${prefix}_string_clone(str, &str);
                if ( ret < 0 )
                        return ret;
        }

        ret = ${name_lib}_value_new_string(value, str);
        if ( ret < 0 ) {
                ${prefix}_string_destroy(str);
                return ret;
        }

        if ( is_ptr )
                ${prefix}_string_ref(str);

        return 0;
}



static int get_value_from_data(${name_lib}_value_t **value, ${name_lib}_data_t *data, ${prefix}_bool_t is_ptr)
{
        int ret;

        if ( ! data ) {
                *value = NULL;
                return 0;
        }

        if ( ! is_ptr ) {
                ret = ${name_lib}_data_clone(data, &data);
                if ( ret < 0 )
                        return ret;
        }

        ret = ${name_lib}_value_new_data(value, data);
        if ( ret < 0 ) {
                ${name_lib}_data_destroy(data);
                return ret;
        }

        if ( is_ptr )
                ${name_lib}_data_ref(data);

        return 0;
}


static int get_value_from_time(${name_lib}_value_t **value, ${name_lib}_time_t *time, ${prefix}_bool_t is_ptr)
{
        int ret;

        if ( ! time ) {
                *value = NULL;
                return 0;
        }

        if ( ! is_ptr ) {
                ret = ${name_lib}_time_clone(time, &time);
                if ( ret < 0 )
                        return ret;
        }

        ret = ${name_lib}_value_new_time(value, time);
        if ( ret < 0 ) {
                ${name_lib}_time_destroy(time);
                return ret;
        }

        if ( is_ptr )
                ${name_lib}_time_ref(time);
        return 0;
}


static void list_insert(${prefix}_list_t *head, ${prefix}_list_t *item, int pos)
{
        int i = 0;
        ${prefix}_list_t *tmp;

        if ( pos == ${name_lib.upper()}_LIST_APPEND )
                ${prefix}_list_add_tail(head, item);

        else if ( pos == ${name_lib.upper()}_LIST_PREPEND )
                ${prefix}_list_add(head, item);

        else if ( pos >= 0 ) {
                ${prefix}_list_for_each(head, tmp) {
                        if ( i == pos )
                                break;
                        i++;
                }

                ${prefix}_list_add_tail(tmp, item);
        }

        else if ( pos < 0 ) {
                pos = -pos;
                pos--;

                ${prefix}_list_for_each_reversed(head, tmp) {
                        if ( i == pos )
                                break;
                        i++;
                }

                ${prefix}_list_add(tmp, item);
        }
}
</%def>
<%def name="description(struct)">
<%include file="struct-description.mako" args="struct=struct"/>
</%def>
<%def name="struct_constructor(struct)">
<% maj = (struct.short_type_name).upper() %>

/**
 * ${name_lib}_${struct.short_type_name}_new:
 * @ret: Pointer where to store the created #${struct.type_name} object.
 *
 * Create a new #${struct.type_name} object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int ${name_lib}_${struct.short_type_name}_new(${struct.type_name} **ret)
{
        *ret = calloc(1, sizeof(**ret));
        if ( ! *ret )
                return ${prefix}_error_from_errno(errno);

        (*ret)->_${name_lib}_object_id = ${name_lib.upper()}_CLASS_ID_${maj};


% if struct.struct_listed:

        ${prefix}_list_init(&((${prefix}_linked_object_t *) (*ret))->_list);

% endif
% if ( struct.refcount ):
        (*ret)->refcount = 1;
% endif
% for field in struct.fields_list:
% if field.listed:

        ${prefix}_list_init(&(*ret)->${field.name});

% endif
% endfor
% for field in struct.fields_list:
<% prefix_struct = "" %>
%if field.type_name != prefix + "_string_t" and  field.data_type != DataType.PRIMITIVE and field.data_type != DataType.PRIMITIVE_STRUCT:
<% prefix_struct = name_lib + "_" %>
% endif
% if field.required and field.unique and (field.data_type == DataType.STRUCT or field.data_type == DataType.PRIMITIVE_STRUCT):
        {
            int retval = ${prefix_struct}${field.short_type_name}_new(&(*ret)->${field.name});

            if ( retval < 0 ) {
                    ${name_lib}_${struct.short_type_name}_destroy(*ret);
                    *ret = NULL;
                    return retval;
                }
        }
% if field.type_name == name_lib + "_time_t" and (field.name == "create_time" or field.name == "report_time") and (struct.short_type_name == "incident" or struct.short_type_name == "alert" or struct.short_type_name == "heartbeat" ):
          ${name_lib}_time_set_from_gettimeofday((*ret)->${field.name});
% endif
% endif
% endfor
            return 0;
}
</%def>
<%def name="struct_get_child(struct)">
<% n = 0 %>
int _${name_lib}_${struct.short_type_name}_get_child(void *p, ${name_lib}_class_child_id_t child, void **childptr)
{
    ${struct.type_name} *ptr = p;

    ${prefix}_return_val_if_fail(p, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));
    *childptr = NULL;

    switch ( child ) {
% for  field in struct.fields_list:
%if  field.listed:
            case ${n}:
                *childptr = &ptr->${field.name};
                return 0;
## <% n = n + 1 %>
%elif field.data_type == DataType.UNION:
% for  member in field.list_member:
            case ${n}:
                *childptr = ( ptr->${field.var} == ${member.value} ) ? ptr->${field.name}.${member.name} : NULL;
                return 0;
<% n = n + 1 %>
% endfor
%elif field.data_type == DataType.ENUM:
            case ${n}:

%if  field.is_op_int:
                    if ( ! ptr->${field.name}_is_set )
                        return 0;

% endif
<% maj = field.short_type_name.upper() %>
                         return ${name_lib}_value_new_enum_from_numeric((${name_lib}_value_t **) childptr,
                                                                ${name_lib.upper()}_CLASS_ID_${maj} , ptr->${field.short_name});
%elif  field.is_op_int:
            case ${n}:
                         return (ptr->${field.name}_is_set) ? ${name_lib}_value_new_${field.value_type}((${name_lib}_value_t **) childptr, ptr->${field.name}) : 0;
%elif field.data_type == DataType.PRIMITIVE or field.data_type == DataType.PRIMITIVE_STRUCT:
<% indice = 0 %>
            case ${n}:
%if  field.is_op_int:
                if ( ! ptr->${field.name}_is_set )
                         return 0;
% endif
% if field.type_name == prefix + "_string_t" :
<%
    indice = indice + 1
    refer = "" if(field.ptr == 1) else "&"
    owned = "TRUE" if(field.ptr == 1) else "FALSE"
%>
                         return get_value_from_string((${name_lib}_value_t **) childptr, ${refer} ptr->${field.name}, ${owned});

% endif
% if field.type_name == name_lib + "_data_t" :
<%
    indice = indice + 1
    refer = "" if(field.ptr == 1) else "&"
    owned = "TRUE" if(field.ptr == 1) else "FALSE"
%>
                return get_value_from_data((${name_lib}_value_t **) childptr, ${refer} ptr->${field.name}, ${owned});

% elif field.type_name == name_lib + "_time_t" :
<%
    indice = indice + 1
    refer = "" if(field.ptr == 1) else "&"
    owned = "TRUE" if(field.ptr == 1) else "FALSE"
%>
                return get_value_from_time((${name_lib}_value_t **) childptr, ${refer} ptr->${field.name}, ${owned});

% elif indice == 0:
                return ${name_lib}_value_new_${field.value_type}((${name_lib}_value_t **) childptr, ptr->${field.name});
% elif indice != 0 and field.type_name != name_lib + "_time_t" and field.type_name != prefix + "_string_t" and field.type_name != name_lib + "_data_t":
<%
    refer = "" if field.ptr == 1 else "&"
%>
            case ${n}:
                *childptr = ${refer}ptr->${field.name};

                return 0;
%endif
% else:
<% refer = "" if(field.ptr == 1) else "&" %>
            case ${n}:
                *childptr = ${refer}ptr->${field.name};
                return 0;
% endif
<% n = n + 1 %>
% endfor
            default:
                    return ${prefix}_error(${prefix.upper()}_ERROR_${name_lib.upper()}_CLASS_UNKNOWN_CHILD);
        }
}
</%def>
<%def name="struct_destroy_child(struct)">
<% n = 0 %>
int _${name_lib}_${struct.short_type_name}_destroy_child(void *p, ${name_lib}_class_child_id_t child, int n)
{
        ${struct.type_name} *ptr = p;
        ${prefix}_return_val_if_fail(p, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));

        switch ( child ) {
% for field in struct.fields_list:
% if field.listed:
% if field.type_name == name_lib + "_time_t" or field.type_name == name_lib + "_data_t" or field.type_name == prefix + "_string_t":
<% type = field.short_type_name %>
% else:
    <% type = name_lib + "_" + field.short_type_name %>
% endif
                case ${n}: {
                    int i = 0;
                    ${prefix}_list_t *tmp;

                    if ( n >= 0 ) {
                            ${prefix}_list_for_each(&ptr->${field.name}, tmp) {
                                    if ( i++ == n ) {
                                            void *b = ${prefix}_linked_object_get_object(tmp);
                                            ${type}_destroy(b);
                                            return 0;
                                    }
                            }

                            if ( i != n )
                                return ${prefix}_error(${prefix.upper()}_ERROR_${name_lib.upper()}_TREE_INDEX_UNDEFINED);
                    } else {
                            int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                            ${prefix}_list_for_each_reversed(&ptr->${field.name}, tmp) {
                                    if ( i++ == pos ) {
                                        void *b = ${prefix}_linked_object_get_object(tmp);
                                        ${type}_destroy(b);
                                        return 0;
                                }
                            }

                            if ( i != pos )
                                return ${prefix}_error(${prefix.upper()}_ERROR_${name_lib.upper()}_TREE_INDEX_UNDEFINED);
                        }
                }
%elif field.data_type == DataType.UNION:

% for  member in field.list_member :
                case ${n}:
                        if (  ptr->${field.var} != ${member.value} )
                                return 0;
                        ${name_lib}_${member.short_type_name}_destroy(ptr->${field.name}.${member.name});
                        ptr->${field.name}.${member.name} = NULL;
                        ptr->${field.var} = 0;
                        return 0;
<% n = n + 1 %>
% endfor

%elif  field.data_type != DataType.UNION and not field.listed:
%if field.is_op_int:
                case ${n}:
                        ptr->${field.name}_is_set = 0;
                        return 0;
% elif  field.ptr == 1 :
<% type = "" %>
%if  field.type_name == name_lib + "_time_t" or field.type_name == name_lib + "_data_t" or field.type_name == prefix + "_string_t" :
<% type = field.short_type_name %>
% else :
<% type = name_lib + "_"+field.short_type_name %>
% endif

                case ${n}:
                        if ( ptr->${field.name} ) {
                                ${type}_destroy(ptr->${field.name});
                                ptr->${field.name} = NULL;
                        }

                        return 0;
% else :
<% code = "" %>

%if field.data_type == DataType.ENUM:
<% code = "ptr->"+field.name+" = 0" %>
%elif field.data_type != DataType.STRUCT and field.data_type != DataType.PRIMITIVE_STRUCT:
<%
    n = n + 1
    continue
%>
% elif ( field.type_name == name_lib + "_time_t" or field.type_name == name_lib + "_data_t" or field.type_name == prefix + "_string_t" ):
<% code = field.short_type_name+"_destroy_internal(&ptr->"+field.name+")" %>
else :
<% code = name_lib + "_+"+field.short_type_name+"_destroy_internal(&ptr->"+field.name+")" %>
% endif
                case ${n}:
                    ${code};
                    return 0;
% endif
% endif
<% n = n + 1 %>
% endfor
                default:
                    return ${prefix}_error(${prefix.upper()}_ERROR_${name_lib.upper()}_CLASS_UNKNOWN_CHILD);
        }
}

</%def>
<%def name="struct_new_child(struct)">
<% n = 0 %>
int _${name_lib}_${struct.short_type_name}_new_child(void *p, ${name_lib}_class_child_id_t child, int n, void **ret)
{
        ${struct.type_name} *ptr = p;
        ${prefix}_return_val_if_fail(p, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));

        switch ( child ) {
% for field in struct.fields_list:
%if  field.listed:
                case ${n}: {
                        int i = 0;
                        ${prefix}_list_t *tmp;

                        if ( n == ${name_lib.upper()}_LIST_APPEND || n == ${name_lib.upper()}_LIST_PREPEND )
                               return ${name_lib}_${struct.short_type_name}_new_${field.short_name}(ptr, (${field.type_name} **) ret, n);

                        if ( n >= 0 ) {
                               ${prefix}_list_for_each(&ptr->${field.name}, tmp) {
                                       if ( i++ == n ) {
                                               *ret = ${prefix}_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != n )
                                       return ${prefix}_error(${prefix.upper()}_ERROR_${name_lib.upper()}_TREE_INDEX_UNDEFINED);
                        } else {
                               int pos = (-n) - 1; /* With negative value, -1 is the base, translate to 0 */

                               ${prefix}_list_for_each_reversed(&ptr->${field.name}, tmp) {
                                       if ( i++ == pos ) {
                                               *ret = ${prefix}_linked_object_get_object(tmp);
                                               return 0;
                                       }
                               }

                               if ( i != pos )
                                       return ${prefix}_error(${prefix.upper()}_ERROR_${name_lib.upper()}_TREE_INDEX_UNDEFINED);
                        }

                        return ${name_lib}_${struct.short_type_name}_new_${field.short_name}(ptr, (${field.type_name} **) ret, n);
                }
%elif field.data_type == DataType.UNION:
% for  member in field.list_member:
                case ${n}:
                    return ${name_lib}_${struct.short_type_name}_new_${member.name}(ptr, (${member.type_name} **) ret);

<% n = n + 1 %>
% endfor
%else:
                case ${n}:
                    return ${name_lib}_${struct.short_type_name}_new_${field.name}(ptr, (${field.type_name} **) ret);
% endif
<% n = n + 1 %>
% endfor
                default:
                    return ${prefix}_error(${prefix.upper()}_ERROR_${name_lib.upper()}_CLASS_UNKNOWN_CHILD);
        }
}
</%def>
<%def name="struct_copy(struct)">
/**
 * ${name_lib}_${struct.short_type_name}_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #${struct.type_name} object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int ${name_lib}_${struct.short_type_name}_copy(const ${struct.type_name} *src, ${struct.type_name} *dst)
{
        int ret;

        ${prefix}_return_val_if_fail(src, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));
        ${prefix}_return_val_if_fail(dst, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));

        ret = 0;
% for field in struct.fields_list:
<%
    clone_func = field.short_type_name+"_clone"
    copy_func = field.short_type_name+"_copy"
    destroy_func = field.short_type_name+"_destroy"
%>

%if field.data_type != DataType.PRIMITIVE and field.data_type != DataType.PRIMITIVE_STRUCT:
<%
    clone_func = name_lib + "_"+clone_func
    copy_func = name_lib + "_"+copy_func
    destroy_func = name_lib + "_"+destroy_func
%>
% endif
%if  field.listed:
         {
                ${prefix}_list_t *n, *tmp;
                ${field.type_name} *entry, *new;
                ${prefix}_list_for_each_safe(&dst->${field.name}, tmp, n)  {
                        entry = ${prefix}_linked_object_get_object(tmp);
                        ${destroy_func}(entry);
                 }

                ${prefix}_list_for_each_safe(&src->${field.name}, tmp, n)  {
                        entry = ${prefix}_linked_object_get_object(tmp);
                        ${clone_func}(entry, &new);
                        ${prefix}_list_add_tail(&dst->${field.name}, &((${prefix}_linked_object_t *) new)->_list);
                 }

 }
%elif field.data_type == DataType.UNION:
<%doc>
        switch ( dst->${field.var} ) {
%for member in field.list_member:
                case ${member.value}:
                        ${name_lib}_${member.short_type_name}_destroy(dst->${field.name}.${member.name});
                        break;
% endfor
                default:
                        break;
        }
</%doc>
        switch ( src->${field.var} ) {
%for member in field.list_member :
                case ${member.value}:
                        ret = ${name_lib}_${member.short_type_name}_clone(src->${field.name}.${member.name}, &dst->${field.name}.${member.name});
                        break;
% endfor
                default:
                        break;
        }

        if ( ret < 0 )
               return ret;

        dst->${field.var} = src->${field.var};
%elif field.data_type == DataType.STRUCT or field.data_type == DataType.PRIMITIVE_STRUCT:
% if field.required and field.unique:
        if ( src->${field.name} ) {
                ret = ${copy_func}(src->${field.name}, dst->${field.name});
                if ( ret < 0 )
                        return ret;
        }
% elif ( field.ptr == 1 ) :

        if ( dst->${field.name} ) {
                ${destroy_func}(dst->${field.name});
                dst->${field.name} = NULL;
        }

        if ( src->${field.name} ) {
                ret = ${clone_func}(src->${field.name}, &dst->${field.name});
                if ( ret < 0 )
                        return ret;
        }

% else:
        ret = ${copy_func}(&src->${field.name}, &dst->${field.name});
        if ( ret < 0 )
                return ret;

% endif
% else:
%if  field.is_op_int:
        dst->${field.name}_is_set = src->${field.name}_is_set;
% endif
        dst->${field.name} = src->${field.name};
% endif
% endfor
    return 0 ;
}
</%def>
<%def name="struct_clone(struct)">
/**
 * ${name_lib}_${struct.short_type_name}_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int ${name_lib}_${struct.short_type_name}_clone(${struct.type_name} *src, ${struct.type_name} **dst)
{
        int ret;

        ${prefix}_return_val_if_fail(src, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));

        ret = ${name_lib}_${struct.short_type_name}_new(dst);
        if ( ret < 0 )
                return ret;

        return ${name_lib}_${struct.short_type_name}_copy(src, *dst);
}
</%def>
<%def name="struct_cmp(struct)">
/**
 * ${name_lib}_${struct.short_type_name}_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int ${name_lib}_${struct.short_type_name}_compare(const ${struct.type_name} *obj1, const ${struct.type_name} *obj2)
{
        int ret = 0;

        if ( obj1 == NULL && obj2 == NULL )
                return 0;

        else if ( obj1 == NULL || obj2 == NULL )

                return -1;
% for field in struct.fields_list :
<% compare_func = field.short_type_name+"_compare" %>
%if  field.data_type != DataType.PRIMITIVE and field.data_type != DataType.PRIMITIVE_STRUCT:
<% compare_func = name_lib + "_" + compare_func %>
% endif
%if  field.listed:
        {
            ${prefix}_list_t *tmp1, *tmp2;
            ${field.type_name} *entry1, *entry2;

            tmp1 = tmp2 = NULL;
                do  {
                        entry1 = entry2 = NULL;

                        ${prefix}_list_for_each_continue(&obj1->${field.name}, tmp1) {
                                entry1 = ${prefix}_linked_object_get_object(tmp1);
                                break;
                         }

                        ${prefix}_list_for_each_continue(&obj2->${field.name}, tmp2)  {
                                entry2 = ${prefix}_linked_object_get_object(tmp2);
                                break;
                         }

                        ret = ${compare_func}(entry1, entry2);
                        if ( ret != 0 )
                                return ret;

                 } while ( entry1 && entry2 );
         }
%elif field.data_type == DataType.UNION:
        if ( obj1->${field.var} != obj2->${field.var} )
                return -1;

        switch ( obj1->${field.var} ) {
% for member in field.list_member :
                case ${member.value}:
                        ret = ${name_lib}_${member.short_type_name}_compare(obj1->${field.name}.${member.name}, obj2->${field.name}.${member.name});
                        break;
% endfor
                default:
                        break;
        }
%elif field.data_type == DataType.STRUCT or field.data_type == DataType.PRIMITIVE_STRUCT:
% if  field.ptr == 1 :
        ret = ${compare_func}(obj1->${field.name}, obj2->${field.name});
        if ( ret != 0 )
                return ret;
% else:
        ret = ${compare_func}(obj1->${field.name}, obj2->${field.name});
        if ( ret != 0 )
                return ret;
% endif
% else :
%if  field.is_op_int:
        if ( obj1->${field.name}_is_set != obj2->${field.name}_is_set )
                return -1;

        if ( obj1->${field.name}_is_set && obj1->${field.name} != obj2->${field.name} )
                return -1;

% else:
% if ( field.type_name == "float" ):
        ret = float_compare(obj1->${field.name}, obj2->${field.name});
%else:
        if ( obj1->${field.name} != obj2->${field.name} )
                return -1;
% endif
% endif
% endif
% endfor
        return ret;
}
</%def>
<%def name="struct_destroy_internal(struct)">
static void ${name_lib}_${struct.short_type_name}_destroy_internal(${struct.type_name} *ptr)
{
        ${prefix}_return_if_fail(ptr);
% if ( struct.struct_listed ) :
        if ( ! ${prefix}_list_is_empty(&((${prefix}_linked_object_t *)ptr)->_list) )
               ${prefix}_list_del_init(&((${prefix}_linked_object_t *)ptr)->_list);
% endif
%for field  in struct.fields_list:
<%
    destroy_func = field.short_type_name+"_destroy"
    destroy_internal_func = destroy_func+"_internal";
%>
%if field.data_type != DataType.PRIMITIVE and field.data_type != DataType.PRIMITIVE_STRUCT:
<%
            destroy_func = name_lib + "_"+destroy_func
            destroy_internal_func = name_lib + "_"+destroy_internal_func
%>
% endif
%if  field.listed:
        {
                ${prefix}_list_t *n, *tmp;
                ${field.type_name} *entry;

                ${prefix}_list_for_each_safe(&ptr->${field.name}, tmp, n) {
                        entry = ${prefix}_linked_object_get_object(tmp);
                        ${prefix}_list_del_init(tmp);
                        ${destroy_func}(entry);
                }
        }
%elif field.data_type == DataType.UNION:
        switch ( ptr->${field.var} ) {
% for member in field.list_member :
                case ${member.value}:
                        ${name_lib}_${member.short_type_name}_destroy(ptr->${field.name}.${member.name});
                        ptr->${field.name}.${member.name} = NULL;
                        break;
% endfor
                default:
                        break;
        }
%elif field.data_type == DataType.STRUCT or field.data_type == DataType.PRIMITIVE_STRUCT:
% if ( field.ptr == 1 ):
        if ( ptr->${field.name} ) {
                ${destroy_func}(ptr->${field.name});
                ptr->${field.name} = NULL;
        }

%else :
        ${destroy_internal_func}(&ptr->${field.name});
% endif

%elif field.data_type == DataType.PRIMITIVE or field.data_type == DataType.PRIMITIVE_STRUCT:

% if field.ptr == 1:
        if ( ptr->${field.name} )
                free(ptr->${field.name});
% endif
% endif
% endfor
        /* free() should be done by the caller */
}
</%def>
<%def name="struct_destroy(struct)">
% if struct.top_level != 1 :
/**
 * ${name_lib}_${struct.short_type_name}_destroy:
 * @ptr: pointer to a #${struct.type_name} object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
% if struct.refcount == 1 :
void ${name_lib}_${struct.short_type_name}_destroy(${struct.type_name} *ptr)
{
        ${prefix}_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        ${name_lib}_${struct.short_type_name}_destroy_internal(ptr);
        free(ptr);
}
% else :
void ${name_lib}_${struct.short_type_name}_destroy(${struct.type_name} *ptr)
{
        ${prefix}_return_if_fail(ptr);

        ${name_lib}_${struct.short_type_name}_destroy_internal(ptr);
        free(ptr);
}
% endif
% endif
</%def>
<%def name="struct_ref(struct)">
% if struct.refcount == 1 :
/**
 * ${name_lib}_${struct.short_type_name}_ref:
 * @${struct.short_type_name}: pointer to a #${struct.type_name} object.
 *
 * Increase @${struct.short_type_name} reference count, so that it can be referenced
 * multiple time.
 *
 * Returns: a pointer to @${struct.short_type_name}.
 */
${struct.type_name} *${name_lib}_${struct.short_type_name}_ref(${struct.type_name} *${struct.short_type_name})
{
        ${prefix}_return_val_if_fail(${struct.short_type_name}, NULL);
        ${struct.short_type_name}->refcount++;

        return ${struct.short_type_name};
}
% endif
</%def>
<%def name="struct_field_normal(classes, struct, field, nam=None)" >
<%
    name = nam if nam != None else field.name
    ptr = ""
    refer = ""
%>
% if  field.ptr == 1 :
% if field.data_type == DataType.STRUCT or field.data_type == DataType.PRIMITIVE_STRUCT:
<% ptr = "*" %>
% else :
<% refer = "*" %>
% endif
%else :
%if field.data_type == DataType.STRUCT or field.data_type == DataType.PRIMITIVE_STRUCT or field.is_op_int:
<%
    ptr = "*"
    refer = "&"
%>
% endif
% endif
/**
 * ${name_lib}_${struct.short_type_name}_get_${name}:
 * @ptr: pointer to a #${struct.type_name} object.
 *
 * Get ${name} children of the #${struct.type_name} object.
 *
 * Returns: a pointer to a ${field.type_name} object, or NULL if the children object is not set.
 */
${field.type_name} ${ptr}${name_lib}_${struct.short_type_name}_get_${name}(${struct.type_name} *ptr)
{
        ${prefix}_return_val_if_fail(ptr, 0); /* FIXME */

%if  field.is_op_int:
        return ptr->${field.name}_is_set ? &ptr->${field.name} : NULL;

% elif (field.data_type == DataType.PRIMITIVE) and (field.data_type != DataType.PRIMITIVE_STRUCT) and (field.ptr == 1):
        return ptr->${field.name} ? *ptr->${field.name} : (${field.type_name}) 0;
% else :
        return ${refer}ptr->${field.name};
% endif

}

<%
if field.name == "class":
    field_name = "class_str"
elif field.name == "virtual":
    field_name = "virtual_sys"
elif field.name == "operator":
    field_name = "operator_indic"
else:
    field_name = field.name
%>
/**
 * ${name_lib}_${struct.short_type_name}_set_${field.name}:
 * @ptr: pointer to a #${struct.type_name} object.
 * @${field_name}: pointer to a #${field.type_name} object.
 *
 * Set @${field_name} object as a children of @ptr.
 * if @ptr already contain an @${field_name} object, then it is destroyed,
 * and updated to point to the provided @${field_name} object.
 */
%if  field.is_op_int:
void ${name_lib}_${struct.short_type_name}_set_${field.name}(${struct.type_name} *ptr, ${field.type_name} ${field_name})
{
        ${prefix}_return_if_fail(ptr);
        ptr->${field.name} = ${field_name};
        ptr->${field.name}_is_set = 1;
}

void ${name_lib}_${struct.short_type_name}_unset_${field.name}(${struct.type_name} *ptr)
{
        ${prefix}_return_if_fail(ptr);
        ptr->${field.name}_is_set = 0;
}
% elif field.data_type == DataType.STRUCT or field.data_type == DataType.PRIMITIVE_STRUCT:
% if field.ptr == 1:
<%
    destroy_func = field.short_type_name+"_destroy"
    if field.data_type != DataType.PRIMITIVE_STRUCT:
        destroy_func = name_lib + "_"+destroy_func
%>
void ${name_lib}_${struct.short_type_name}_set_${field.name}(${struct.type_name} *ptr, ${field.type_name} *${field_name})
{
        ${prefix}_return_if_fail(ptr);
        if ( ptr->${field.name} )
                ${destroy_func}(ptr->${field.name});

        ptr->${field.name} = ${field_name};
}
% else:
<%
    destroy_internal_func = field.short_type_name+"_destroy_internal"
    if field.data_type != DataType.PRIMITIVE and field.data_type != DataType.PRIMITIVE_STRUCT:
        destroy_internal_func = name_lib + "_"+destroy_internal_func
%>
void ${name_lib}_${struct.short_type_name}_set_${field.name}(${struct.type_name} *ptr, ${field.type_name} *${field_name})
{
        ${prefix}_return_if_fail(ptr);

        ${destroy_internal_func}(&ptr->${field.name});
        if ( ${field_name} ) {
                memcpy(&ptr->${field.name}, ${field_name}, sizeof(ptr->${field.name}));
                free(${field.name});
        }
}

% endif
% else:
void ${name_lib}_${struct.short_type_name}_set_${field.name}(${struct.type_name} *ptr, ${field.type_name} ${field_name})
{
        ${prefix}_return_if_fail(ptr);
        ptr->${field.name} = ${field_name};
% if struct.type_name == name_lib + "_additional_data_t" and (name == "type" or name == "dtype"):
        ptr->_type_is_set = TRUE;

% endif
}
% endif
/**
 * ${name_lib}_${struct.short_type_name}_new_${name}:
 * @ptr: pointer to a #${struct.type_name} object.
 * @ret: pointer to an address where to store the created #${field.type_name} object.
 *
 * Create a new ${name} object, children of #${struct.type_name}.
 * If @ptr already contain a #${field.type_name} object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int ${name_lib}_${struct.short_type_name}_new_${name}(${struct.type_name} *ptr, ${field.type_name} **ret)
{
<% need_check = 1 %>
%if  field.is_op_int:
<% need_check = 0 %>
        ${prefix}_return_val_if_fail(ptr, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));
        ptr->${field.name}_is_set = 1;

%elif field.data_type == DataType.PRIMITIVE or field.data_type == DataType.PRIMITIVE_STRUCT:

%if field.data_type == DataType.PRIMITIVE_STRUCT:

% if ( field.ptr == 1 ) :
<% need_check = 0 %>

        int retval;

        ${prefix}_return_val_if_fail(ptr, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));

        if ( ! ptr->${field.name} ) {
                retval = ${field.short_type_name}_new(&ptr->${field.name});
                if ( retval < 0 )
                        return retval;
        }
% endif
% endif
% else:
%if field.data_type == DataType.STRUCT:
%if field.ptr == 1:
<% need_check = 0 %>
        int retval;

        ${prefix}_return_val_if_fail(ptr, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));

        if ( ! ptr->${field.name} ) {
                retval = ${name_lib}_${field.short_type_name}_new(&ptr->${field.name});
                if ( retval < 0 )
                        return retval;
        }
% else :
% if classes.objs[field.type_name].struct_listed == 1 :
<% need_check = 0 %>
        ${prefix}_return_val_if_fail(ptr, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));
        ${prefix}_list_init(&ptr->${field.name}._list);
% endif
% endif
% endif
% endif
<% refer = "" if (field.ptr == 1 ) else "&" %>

%if ( need_check != 0 ):
        ${prefix}_return_val_if_fail(ptr, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));
% endif
% if (field.type_name == name_lib + "_additional_data_type_t" or field.type_name == name_lib + "_additional_data_dtype_t") and (field.name == "type" or field.name == "dtype" ):
        ptr->_type_is_set = TRUE;
% endif
        *ret = ${refer}ptr->${field.name};
        return 0;
}
</%def>
<%def name="struct_field_union(struct, field)">
/**
 * ${name_lib}_${struct.short_type_name}_get_${field.var}:
 * @ptr: pointer to a #${struct.type_name} object.
 *
 * Access the ${field.var} children of @ptr.
 *
 * Returns: a pointer to the #${field.type_name} children, or NULL if it is not set.
 */
${field.type_name} ${name_lib}_${struct.short_type_name}_get_${field.var}(${struct.type_name} *ptr)
{
        ${prefix}_return_val_if_fail(ptr, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));
        return ptr->${field.var};
}
% for member in field.list_member:
/**
 * ${name_lib}_${struct.short_type_name}_get_${member.name}:
 * @ptr: pointer to a #${struct.type_name} object.
 *
 * Access the ${member.name} children of @ptr.
 *
 * Returns: a pointer to the #${member.type_name} children, or NULL if it is not set.
 */
${member.type_name} *${name_lib}_${struct.short_type_name}_get_${member.name}(${struct.type_name} *ptr)
{
        ${prefix}_return_val_if_fail(ptr, NULL);
        return (ptr->${field.var} == ${member.value}) ? ptr->${field.name}.${member.name} : NULL;
}

/**
 * ${name_lib}_${struct.short_type_name}_set_${member.name}:
 * @ptr: pointer to a #${struct.type_name} object.
 * @${member.name}: pointer to a #${member.type_name} object.
 *
 * Set @${member.name} object as a children of @ptr.
 * if @ptr already contain a @${member.name} object, then it is destroyed,
 * and updated to point to the provided @${member.name} object.
 */
void ${name_lib}_${struct.short_type_name}_set_${member.name}(${struct.type_name} *ptr, ${member.type_name} *${member.name})
{
        ${prefix}_return_if_fail(ptr);

        switch ( ptr->${field.var} ) {
% for element in field.list_member:
                case ${element.value}:
                        ${name_lib}_${element.short_type_name}_destroy(ptr->${field.name}.${element.name});
                        break;
% endfor
                default:
                        break;
        }
        ptr->${field.name}.${member.name} = ${member.name};
        ptr->${field.var} = (${member.name}) ? ${member.value} : 0;
}
/**
 * ${name_lib}_${struct.short_type_name}_new_${member.name}:
 * @ptr: pointer to a #${struct.type_name} object.
 * @ret: pointer where to store the created #${member.type_name} object.
 *
 * Create a new ${member.type_name} object, children of #${struct.type_name}.
 * If @ptr already contain a #${member.type_name} object, then it is destroyed.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int ${name_lib}_${struct.short_type_name}_new_${member.name}(${struct.type_name} *ptr, ${member.type_name} **ret)
{
        int retval;

        ${prefix}_return_val_if_fail(ptr, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));

        switch ( ptr->${field.var} ) {

% for other_member in field.list_member :
% if other_member == member :
                case ${member.value}:
                        *ret = ptr->${field.name}.${member.name};
                        return 0;
% else:
                case ${other_member.value}:
                        ${name_lib}_${other_member.short_type_name}_destroy(ptr->${field.name}.${other_member.name});
                        break;
% endif
% endfor

                default:
                        break;
        }

        retval = ${name_lib}_${member.short_type_name}_new(ret);
        if ( retval < 0 )
                return retval;

        ptr->${field.var} = ${member.value};
        ptr->${field.name}.${member.name} = *ret;

        return 0;
}
% endfor
</%def>
<%def name="struct_field_list(struct, field)">

<% new_field_function = field.short_type_name+"_new(ret)" %>
%if field.data_type != DataType.PRIMITIVE and field.data_type != DataType.PRIMITIVE_STRUCT:
<% new_field_function = name_lib + "_"+new_field_function %>
%endif
/**
 * ${name_lib}_${struct.short_type_name}_get_next_${field.short_name}:
 * @${struct.short_type_name}: pointer to a #${struct.type_name} object.
 * @${field.short_type_name}_cur: pointer to a #${field.type_name} object.
 *
 * Get the next #${field.type_name} object listed in @ptr.
 * When iterating over the ${field.type_name} object listed in @ptr,
 * @object should be set to the latest returned #${field.type_name} object.
 *
 * Returns: the next #${field.type_name} in the list.
 */
${field.type_name} *${name_lib}_${struct.short_type_name}_get_next_${field.short_name}(${struct.type_name} *${struct.short_type_name}, ${field.type_name} *${field.short_type_name}_cur)
{
        ${prefix}_list_t *tmp = (${field.short_type_name}_cur) ? &((${prefix}_linked_object_t *) ${field.short_type_name}_cur)->_list : NULL;

        ${prefix}_return_val_if_fail(${struct.short_type_name}, NULL);

        ${prefix}_list_for_each_continue(&${struct.short_type_name}->${field.name}, tmp)
                return ${prefix}_linked_object_get_object(tmp);

        return NULL;
}


/**
 * ${name_lib}_${struct.short_type_name}_set_${field.short_name}:
 * @ptr: pointer to a #${struct.type_name} object.
 * @object: pointer to a #${field.type_name} object.
 * @pos: Position in the list.
 *
 * Add @object to position @pos of @ptr list of #${field.type_name} object.
 *
 * If @pos is #${name_lib.upper()}_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #${name_lib.upper()}_LIST_PREPEND, @object will be inserted at the head of the list.
 */
void ${name_lib}_${struct.short_type_name}_set_${field.short_name}(${struct.type_name} *ptr, ${field.type_name} *object, int pos)
{
        ${prefix}_return_if_fail(ptr);
        ${prefix}_return_if_fail(object);

        if ( ! ${prefix}_list_is_empty(&((${prefix}_linked_object_t *) object)->_list) )
                ${prefix}_list_del_init(&((${prefix}_linked_object_t *) object)->_list);

        list_insert(&ptr->${field.name}, &((${prefix}_linked_object_t *) object)->_list, pos);
}


/**
 * ${name_lib}_${struct.short_type_name}_new_${field.short_name}:
 *  @ptr: pointer to a #${struct.type_name} object.
 *  @ret: pointer to an address where to store the created #${field.type_name} object.
 *  @pos: position in the list.
 *
 * Create a new #${field.type_name} children of @ptr, and add it to position @pos of
 * @ptr list of #${field.type_name} object. The created #${field.type_name} object is
 * stored in @ret.
 *
 * If @pos is #${name_lib.upper()}_LIST_APPEND, @object will be inserted at the tail of the list.
 * If @pos is #${name_lib.upper()}_LIST_PREPEND, @object will be inserted at the head of the list.
 *
 * Returns: 0 on success, or a negative value if an error occured.
 */
int ${name_lib}_${struct.short_type_name}_new_${field.short_name}(${struct.type_name} *ptr, ${field.type_name} **ret, int pos)
{
        int retval;

        ${prefix}_return_val_if_fail(ptr, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));

        retval = ${new_field_function};
        if ( retval < 0 )
                return retval;

        list_insert(&ptr->${field.name}, &((${prefix}_linked_object_t *)(*ret))->_list, pos);

        return 0;
}
</%def>
<%def name="struct_fields(classes, struct)">
% for field in struct.fields_list:
% if field.listed:
${struct_field_list(struct, field)}
% elif field.data_type == DataType.UNION:
${struct_field_union(struct, field)}
% else:
${struct_field_normal(classes, struct, field)}
% endif
% endfor
</%def>
<%def name="struct(struct)">
${description(struct)}
</%def>
<%def name="struct_func(classes, struct)">
${struct_constructor(struct)}
${struct_ref(struct)}
${struct_get_child(struct)}
${struct_new_child(struct)}
${struct_destroy_child(struct)}
${struct_destroy_internal(struct)}
${struct_destroy(struct)}
${struct_fields(classes, struct)}
${struct_copy(struct)}
${struct_clone(struct)}
${struct_cmp(struct)}
</%def>
<%def name="enums(enum)">
/**
 * ${name_lib}_${enum.short_type_name}_to_numeric:
 * @name: pointer to an ${name_lib.upper()} string representation of a #${enum.type_name} value.
 *
 * Returns: the numeric equivalent of @name, or -1 if @name is not valid.
 */
${enum.type_name} ${name_lib}_${enum.short_type_name}_to_numeric(const char *name)
{
<% cnt = 0 %>       size_t i;
        const struct {
              ${enum.type_name} val;
              const char *name;
        } tbl[] = {
% for field in enum.enum_members:
% if str(field.value) == "-1":
<% continue %>
% endif
## % if cnt == 0 and str(field.value) != "0":
## { 0, NULL },
## % endif
% if field.text:
<% fieldname = field.text; cnt = cnt + 1; %>
% else:
<%
    fieldname = (field.keyword.replace("_","-"))
    if enum.short_type_name != "checksum_algorithm":
        fieldname = fieldname.lower()
    cnt = cnt + 1
%>
% endif
            { ${field.name}, "${fieldname}" },

% endfor
        };

        ${prefix}_return_val_if_fail(name, ${prefix}_error(${prefix.upper()}_ERROR_ASSERTION));

        for ( i = 0; i < sizeof(tbl) / sizeof(*tbl); i++ ) {
                if ( strcasecmp(name, tbl[i].name) == 0 )
                        return tbl[i].val;
        }

        return ${prefix}_error_verbose(${prefix.upper()}_ERROR_${name_lib.upper()}_UNKNOWN_ENUM_STRING, "Unknown enumeration value '%s' for ${enum.short_type_name}", name);

}
/**
 * ${name_lib}_${enum.short_type_name}_to_string:
 * @val: an enumeration value for #${enum.type_name}.
 *
 * Return the ${name_lib.upper()} string equivalent of @val provided #${enum.type_name} value.
 *
 * Returns: a pointer to the string describing @val, or NULL if @val is invalid.
 */
const char *${name_lib}_${enum.short_type_name}_to_string(${enum.type_name} val)
{
<% cnt = 0 %>
        const struct {
              ${enum.type_name} val;
              const char *name;
        } tbl[] = {
% for field in enum.enum_members :
% if field.value == -1:
<% continue ;%>
% endif
% if cnt == 0 and field.value != 0:
            { 0, NULL },
% endif
% if field.text :
<% fieldname = field.text %>
% else:
<%
    fieldname = (field.keyword.replace("_","-"))
    if enum.short_type_name != "checksum_algorithm":
        fieldname = fieldname.lower()
    cnt = cnt + 1
%>
% endif
            { ${field.name}, "${fieldname}" },
% endfor
        };

        if ( val < 0 || (size_t) val >= (sizeof(tbl) / sizeof(*tbl)) )
                return NULL;

        return tbl[val].name;

}
</%def>
<%def name="footer()">
int _${name_lib}_additional_data_type_is_set(${name_lib}_additional_data_t *ad)
{
        return ad->_type_is_set;
}
<%doc>

void ${name_lib}_message_set_pmsg(${name_lib}_message_t *message, ${prefix}_msg_t *msg)
{
        ${prefix}_return_if_fail(message);
        message->pmsg = msg;
}


${prefix}_msg_t *${name_lib}_message_get_pmsg(${name_lib}_message_t *message)
{
        ${prefix}_return_val_if_fail(message, NULL);
        return message->pmsg;
}
</%doc>
##void ${name_lib}_${top_class}_destroy(${name_lib}_${top_class}_t*);
/**
 * ${name_lib}_${top_class}_destroy:
 * @ptr: pointer to a #${name_lib}_${top_class}_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void ${name_lib}_${top_class}_destroy(${name_lib}_${top_class}_t *ptr)
{
        ${prefix}_return_if_fail(ptr);

        if ( --ptr->refcount )
                return;

        ${name_lib}_${top_class}_destroy_internal(ptr);

##        if ( ptr->pmsg )
##                ${prefix}_msg_destroy(ptr->pmsg);

        free(ptr);
}
</%def>

<%def name="generateFile(classes)">
${header()}
% for obj in classes.obj_list:
    % if isinstance(obj, Struct):
        ${struct(obj)}
    % elif isinstance(obj, EnumField):
        ${enums(obj)}
    % endif
% endfor
% for obj in classes.obj_list :
    % if isinstance(obj, Struct):
        ${struct_func(classes, obj)}
    % endif
% endfor
${footer()}
</%def>
${generateFile(lib_classes)}
