<%!
import sys
sys.path.append('../')
from field import Struct, Union, DataType, Multiplicity, Field, PreDeclared, EnumField
%>
<%
max_id = 0
prev_id = {}
prev_id_rev = {}


def gen_new_id(id_min):
    i = id_min
    while prev_id_rev.get(i) :
        i += 1
    prev_id_rev[i] = 1
    return i

def get_prev_id(tag):
    return prev_id.get(tag)

def keys_to_remove(key_list, the_dict):
    for key in key_list:
        if key in the_dict:
            del the_dict[key]
%>
/*****
*
* Copyright (C) 2004-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@prelude-ids.com>
*
* This file is part of the ${prefix.capitalize()} library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/*
 * This file was automatically generated by our generator, version ${generator_version}
 *
 * Do not make changes to this file unless you know what you are doing.
 * modify the template interface file instead.
 * ${name_lib.upper()} version : ${lib_version}
 * Template file: generate-top-level-class-id.h.mako
 *
 */

#ifndef _${prefix.upper()}_${name_lib.upper()}_${top_class.upper()}_ID_H
#define _${prefix.upper()}_${name_lib.upper()}_${top_class.upper()}_ID_H

/*
 * Misc value
 */

#define ${name_lib.upper()}_MSG_OWN_FORMAT                                 253
#define ${name_lib.upper()}_MSG_END_OF_TAG                                 254

/*
 * Tag value
 */

% for struct in lib_classes.struct_list :
% if struct.top_level == 0 :
<%
    id = get_prev_id(name_lib.upper() + "_MSG_" + (struct.short_type_name).upper() + "_TAG");
    if id == None :
        id = gen_new_id(max_id)
    max_id = max(id + 1, max_id)
    prev_id[name_lib.upper() + "_MSG_" + struct.short_type_name.upper() + "_TAG"] = id
    prev_id_rev[id] = 1
%>
#define ${name_lib.upper()}_MSG_${struct.short_type_name.upper()}_TAG ${id}
% endif ##top_level
% endfor ## end struct_list
% for struct in lib_classes.struct_list :
/*
 * ${name_lib.upper()} ${struct.short_type_name.capitalize()}
 */
<% key_list = [] %>
% for field in struct.fields_list:
% if field.data_type != DataType.STRUCT and field.data_type != DataType.UNION:
<%

    tag = name_lib.upper() + "_MSG_" + struct.short_type_name.upper() + "_" + field.short_name.upper()
    id = get_prev_id(tag)
    if field.is_key_listed:
        id = 40
        prev_id_rev[id] = 1
    if id == None :
        id = gen_new_id(max_id)
    prev_id[tag] = id
    key_list.append(id)
%>
#define ${tag} ${id}
% endif
% endfor ##fields_list end
<% keys_to_remove(key_list, prev_id_rev) %>
% endfor ## struct_list end
#endif /* _${prefix.upper()}_${name_lib.upper()}_${top_class.upper()}_ID_H */
