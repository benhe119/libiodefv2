<%!
import sys
sys.path.append('../')
from field import Struct, EnumField, Union, DataType, Field, PreDeclared, Multiplicity
%>
/*****
*
* Copyright (C) 2001-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@prelude-ids.com>
* Author: Nicolas Delon <nicolas.delon@prelude-ids.com>
*
* This file is part of the ${prefix.capitalize()} library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/*
 * This file was automatically generated by our generator, version ${generator_version}
 *
 * Do not make changes to this file unless you know what you are doing.
 * modify the template interface file instead.
 * ${name_lib.upper()} version : ${lib_version}
 * Template file: generate-top-level-class-read.c.mako
 *
 */

#include "config.h"

#include <stdio.h>
#include <unistd.h>

#define ${prefix.upper()}_ERROR_SOURCE_DEFAULT ${prefix.upper()}_ERROR_SOURCE_${name_lib.upper()}_MESSAGE_READ
#include "${prefix}-error.h"
#include "${prefix}-inttypes.h"
#include "${prefix}-list.h"
#include "${prefix}-extract.h"
#include "${prefix}-io.h"
#include "${name_lib}-message-id.h"
#include "${name_lib}.h"
#include "${name_lib}-tree-wrap.h"

#include "${name_lib}-message-read.h"

#define ${prefix}_extract_string_safe(out, buf, len, msg) extract_string_safe_f(__FUNCTION__, __LINE__, out, buf, len)

static inline int extract_string_safe_f(const char *f, int line, ${prefix}_string_t **out, char *buf, size_t len)
{
        int ret;

        /*
         * we use len - 1 since len is supposed to include \0 to avoid making a dup.
         */
        ret = ${prefix}_string_new_ref_fast(out, buf, len - 1);
        if ( ret < 0 )
                ret = ${prefix}_error_verbose(${prefix}_error_get_code(ret), "%s:%d could not extract ${name_lib.upper()} string: %s", f, line, ${prefix}_strerror(ret));

        return ret;
}


static inline int ${prefix}_extract_time_safe(${name_lib}_time_t **out, void *buf, size_t len, ${prefix}_msg_t *msg)
{
        int ret;

        /*
         * sizeof(sec) + sizeof(usec) + sizeof(gmt offset).
         */
        if ( len != 12 )
                return ${prefix}_error_make(${prefix.upper()}_ERROR_SOURCE_EXTRACT, ${prefix.upper()}_ERROR_INVAL_${name_lib.upper()}_TIME);

        ret = ${name_lib}_time_new(out);
        if ( ret < 0 )
                return ret;

        ${name_lib}_time_set_sec(*out, ${prefix}_extract_uint32(buf));
        ${name_lib}_time_set_usec(*out, ${prefix}_extract_uint32((unsigned char *) buf + 4));
        ${name_lib}_time_set_gmt_offset(*out, ${prefix}_extract_int32((unsigned char *) buf + 8));

        return 0;
}


static inline int ${prefix}_extract_data_safe(${name_lib}_data_t **out, void *buf, uint32_t len, ${prefix}_msg_t *msg)
{
        int ret;
        uint8_t tag;
        ${name_lib}_data_type_t type = 0;

        ret = ${prefix}_extract_uint32_safe(&type, buf, len);
        if ( ret < 0 )
                return ret;

        ret = ${prefix}_msg_get(msg, &tag, &len, &buf);
        if ( ret < 0 )
                return ret;

        *out = NULL;

        switch ( type ) {
        case ${name_lib.upper()}_DATA_TYPE_CHAR: {
                uint8_t tmp = 0;

                ret = ${prefix}_extract_uint8_safe(&tmp, buf, len);
                if ( ret < 0 )
                        return ret;

                ret = ${name_lib}_data_new_char(out, (char) tmp);
                break;
        }

        case ${name_lib.upper()}_DATA_TYPE_BYTE: {
                uint8_t tmp = 0;

                ret = ${prefix}_extract_uint8_safe(&tmp, buf, len);
                if ( ret < 0 )
                        return ret;

                ret = ${name_lib}_data_new_byte(out, tmp);
                break;
        }

        case ${name_lib.upper()}_DATA_TYPE_UINT32: {
                uint32_t tmp = 0;

                ret = ${prefix}_extract_uint32_safe(&tmp, buf, len);
                if ( ret < 0 )
                        return ret;

                ret = ${name_lib}_data_new_int(out, tmp);
                break;
        }

        case ${name_lib.upper()}_DATA_TYPE_INT: {
                uint64_t tmp = 0;

                ret = ${prefix}_extract_uint64_safe(&tmp, buf, len);
                if ( ret < 0 )
                        return ret;

                ret = ${name_lib}_data_new_int(out, tmp);
                break;
        }

        case ${name_lib.upper()}_DATA_TYPE_FLOAT: {
                float tmp = 0;

                ret = ${prefix}_extract_float_safe(&tmp, buf, len);
                if ( ret < 0 )
                        return ret;

                ret = ${name_lib}_data_new_float(out, tmp);
                break;
        }

        case ${name_lib.upper()}_DATA_TYPE_BYTE_STRING: {
                ret = ${name_lib}_data_new_ptr_ref_fast(out, type, buf, len);
                break;
        }

        case ${name_lib.upper()}_DATA_TYPE_CHAR_STRING: {
                const char *tmp = NULL;

                ret = ${prefix}_extract_characters_safe(&tmp, buf, len);
                if ( ret < 0 )
                        return ret;

                ret = ${name_lib}_data_new_ptr_ref_fast(out, type, tmp, len);
                break;
        }

        case ${name_lib.upper()}_DATA_TYPE_TIME: {
                ${name_lib}_time_t *time;

                ret = ${prefix}_extract_time_safe(&time, buf, len, msg);
                if ( ret < 0 )
                        return ret;

                ret = ${name_lib}_data_new_time(out, time);
                break;
        }

        case ${name_lib.upper()}_DATA_TYPE_UNKNOWN:
                /* nop */;
        }

        return ret;
}

% for obj in lib_classes.obj_list :
% if isinstance(obj, Struct):
/**
 * ${name_lib}_${obj.short_type_name}_read:
 * @${obj.short_type_name}: Pointer to a #${obj.type_name} object.
 * @msg: Pointer to a #${prefix}_msg_t object, containing a message.
 *
 * Read an ${name_lib}_${obj.short_type_name} from the @msg message, and
 * store it into @${obj.short_type_name}.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int ${name_lib}_${obj.short_type_name}_read(${obj.type_name} *${obj.short_type_name}, ${prefix}_msg_t *msg)
{
        int ret;
        void *buf;
        uint8_t tag;
        uint32_t len;

        while ( 1 ) {
                ret = ${prefix}_msg_get(msg, &tag, &len, &buf);
                if ( ret < 0 )
                        return ret;

                switch ( tag ) {
<% i = 0 %>
% for field in obj.fields_list :
%if field.listed:
%if field.data_type == DataType.PRIMITIVE or field.data_type == DataType.PRIMITIVE_STRUCT:
<%
    ptr = "*" if (field.data_type  == DataType.STRUCT or  field.data_type == DataType.PRIMITIVE_STRUCT or field.listed) else ""
    init = "NULL" if (field.data_type  == DataType.STRUCT or  field.data_type == DataType.PRIMITIVE_STRUCT or field.listed) else "0"
    extra_msg = ", msg" if (field.data_type  == DataType.STRUCT or  field.data_type == DataType.PRIMITIVE_STRUCT or field.listed) else ""
    type = field.value_type
    var_type = field.type_name
%>
                        case ${name_lib.upper()}_MSG_${obj.short_type_name.upper()}_${field.short_name.upper()} : {
                                ${var_type} ${ptr}tmp = ${init};

                                ret = ${prefix}_extract_${type}_safe(&tmp, buf, len${extra_msg});
                                if ( ret < 0 )
                                        return ret;
%if field.listed:
                                ${name_lib}_${obj.short_type_name}_set_${field.short_name}(${obj.short_type_name}, tmp, -1);
                                break;
                        }
% else :
                                ${name_lib}_${obj.short_type_name}_set_${field.short_name}(${obj.short_type_name}, tmp);
                                break;
                        }
% endif

% else : ## struct_field_struct field.short_name
<% name = field.short_name %>
                        case ${name_lib.upper()}_MSG_${field.short_type_name.upper()}_TAG: {
                                int ret;
                                ${field.type_name} *tmp = NULL;
%if field.listed:
                                ret = ${name_lib}_${obj.short_type_name}_new_${name}(${obj.short_type_name}, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;
% else :
                                ret = ${name_lib}_${obj.short_type_name}_new_${name}(${obj.short_type_name}, &tmp);
                                if ( ret < 0 )
                                        return ret;
% endif


                                ret = ${name_lib}_${field.short_type_name}_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }
% endif
%elif  field.data_type == DataType.UNION:
% for member in field.list_member :
<% name = member.name %>
                        case ${name_lib.upper()}_MSG_${member.short_type_name.upper()}_TAG: {
                                int ret;
                                ${member.type_name} *tmp = NULL;
%if  member.multiplicity.listed:
                                ret = ${name_lib}_${obj.short_type_name}_new_${name}(${obj.short_type_name}, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;
% else :
                                ret = ${name_lib}_${obj.short_type_name}_new_${name}(${obj.short_type_name}, &tmp);
                                if ( ret < 0 )
                                        return ret;
% endif


                                ret = ${name_lib}_${member.short_type_name}_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }
% endfor ## member
%else:  ## normal
%if  field.data_type == DataType.PRIMITIVE or field.data_type == DataType.PRIMITIVE_STRUCT:
<%
    ptr = "*" if (field.data_type  == DataType.STRUCT or  field.data_type == DataType.PRIMITIVE_STRUCT or field.listed) else ""
    init = "NULL" if (field.data_type  == DataType.STRUCT or  field.data_type == DataType.PRIMITIVE_STRUCT or field.listed) else "0"
    extra_msg = ", msg" if (field.data_type  == DataType.STRUCT or  field.data_type == DataType.PRIMITIVE_STRUCT or field.listed) else ""
    type = field.value_type
    var_type = field.type_name
%>

                        case ${name_lib.upper()}_MSG_${obj.short_type_name.upper()}_${field.short_name.upper()} : {
                                ${var_type} ${ptr}tmp = ${init};

                                ret = ${prefix}_extract_${type}_safe(&tmp, buf, len${extra_msg});
                                if ( ret < 0 )
                                        return ret;
%if field.listed:
                                ${name_lib}_${obj.short_type_name}_set_${field.short_name}(${obj.short_type_name}, tmp, -1);
                                break;
                        }
% else :
                                ${name_lib}_${obj.short_type_name}_set_${field.short_name}(${obj.short_type_name}, tmp);
                                break;
                        }
% endif
% elif field.data_type == DataType.ENUM:
<%
    ptr = "*" if (field.data_type  == DataType.STRUCT or  field.data_type == DataType.PRIMITIVE_STRUCT or field.listed) else ""
    init = "NULL" if (field.data_type  == DataType.STRUCT or  field.data_type == DataType.PRIMITIVE_STRUCT or field.listed) else "0"
    extra_msg = ", msg" if (field.data_type  == DataType.STRUCT or  field.data_type == DataType.PRIMITIVE_STRUCT or field.listed) else ""
    type = "int32"
    var_type = "int32_t"
%>
                        case ${name_lib.upper()}_MSG_${obj.short_type_name.upper()}_${field.short_name.upper()} : {
                                ${var_type} ${ptr}tmp = ${init};

                                ret = ${prefix}_extract_${type}_safe(&tmp, buf, len${extra_msg});
                                if ( ret < 0 )
                                        return ret;
%if  field.listed:
                                ${name_lib}_${obj.short_type_name}_set_${field.short_name}(${obj.short_type_name}, tmp, -1);
                                break;
                        }
% else :
                                ${name_lib}_${obj.short_type_name}_set_${field.short_name}(${obj.short_type_name}, tmp);
                                break;
                        }
% endif

% else :## struct_field_struct
<% name = field.name %>
                        case ${name_lib.upper()}_MSG_${field.short_type_name.upper()}_TAG: {
                                int ret;
                                ${field.type_name} *tmp = NULL;
%if field.listed:
                                ret = ${name_lib}_${obj.short_type_name}_new_${name}(${obj.short_type_name}, &tmp, -1);
                                if ( ret < 0 )
                                        return ret;
% else:
                                ret = ${name_lib}_${obj.short_type_name}_new_${name}(${obj.short_type_name}, &tmp);
                                if ( ret < 0 )
                                        return ret;
% endif


                                ret = ${name_lib}_${field.short_type_name}_read(tmp, msg);
                                if ( ret < 0 )
                                        return ret;

                                break;
                        }
% endif ##primitve

% endif ## normal
% endfor ## field_end
                        case ${name_lib.upper()}_MSG_END_OF_TAG:
                                return 0;

                        default:
                                return ${prefix}_error_verbose(${prefix.upper()}_ERROR_${name_lib.upper()}_UNKNOWN_TAG, "Unknown tag while reading${obj.type_name}: '%u'", tag);
                }

        }

        return 0;
}
% endif ##if_struct
% endfor ##for_obj_list
