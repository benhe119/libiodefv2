<%!
import sys
sys.path.append('../')
from field import Struct, Union, DataType, Multiplicity, Field, EnumField, PreDeclared
%>
/*****
*
* Copyright (C) 2004-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@prelude-ids.com>
*
* This file is part of the ${prefix.capitalize()} library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/*
 * This file was automatically generated by our generator, version ${generator_version}
 *
 * Do not make changes to this file unless you know what you are doing.
 * modify the template interface file instead.
 * ${name_lib.upper()} version : ${lib_version}
 * Template file: generate-additional-data.h.mako
 *
 */


#ifndef _${prefix.upper()}_${name_lib.upper()}_ADDITIONAL_DATA_H
#define _${prefix.upper()}_${name_lib.upper()}_ADDITIONAL_DATA_H

#ifdef __cplusplus
 extern "C" {
#endif

/*
 * basic type
 */
int ${name_lib}_additional_data_new_real(${name_lib}_additional_data_t **ret, float data);
int ${name_lib}_additional_data_new_byte(${name_lib}_additional_data_t **ret, uint8_t byte);
int ${name_lib}_additional_data_new_integer(${name_lib}_additional_data_t **ret, uint32_t data);
int ${name_lib}_additional_data_new_boolean(${name_lib}_additional_data_t **ret, ${prefix}_bool_t data);
int ${name_lib}_additional_data_new_character(${name_lib}_additional_data_t **ret, char data);

void ${name_lib}_additional_data_set_real(${name_lib}_additional_data_t *ptr, float data);
void ${name_lib}_additional_data_set_byte(${name_lib}_additional_data_t *ptr, uint8_t byte);
void ${name_lib}_additional_data_set_integer(${name_lib}_additional_data_t *ptr, uint32_t data);
void ${name_lib}_additional_data_set_boolean(${name_lib}_additional_data_t *ptr, ${prefix}_bool_t data);
void ${name_lib}_additional_data_set_character(${name_lib}_additional_data_t *ptr, char data);


#define _${name_lib.upper()}_ADDITIONAL_DATA_DECL(name)<%text>\</%text>
int ${name_lib}_additional_data_new_<%text>##</%text> name<%text>##</%text> _ref_fast(${name_lib}_additional_data_t **ad, const char *data, size_t len);<%text>\</%text>
int ${name_lib}_additional_data_new_<%text>##</%text> name<%text>##</%text> _ref(${name_lib}_additional_data_t **ad, const char *data);<%text>\</%text>
int ${name_lib}_additional_data_set_<%text>##</%text> name<%text>##</%text> _ref_fast(${name_lib}_additional_data_t *ad, const char *data, size_t len);<%text>\</%text>
int ${name_lib}_additional_data_set_<%text>##</%text> name<%text>##</%text> _ref(${name_lib}_additional_data_t *ad, const char *data);<%text>\</%text>
int ${name_lib}_additional_data_new_<%text>##</%text> name<%text>##</%text> _dup_fast(${name_lib}_additional_data_t **ad, const char *data, size_t len);<%text>\</%text>
int ${name_lib}_additional_data_new_<%text>##</%text> name<%text>##</%text> _dup(${name_lib}_additional_data_t **ad, const char *data);<%text>\</%text>
int ${name_lib}_additional_data_set_<%text>##</%text> name<%text>##</%text> _dup_fast(${name_lib}_additional_data_t *ad, const char *data, size_t len);<%text>\</%text>
int ${name_lib}_additional_data_set_<%text>##</%text> name<%text>##</%text> _dup(${name_lib}_additional_data_t *ad, const char *data);<%text>\</%text>
int ${name_lib}_additional_data_new_<%text>##</%text> name<%text>##</%text> _nodup_fast(${name_lib}_additional_data_t **ad, char *data, size_t len);<%text>\</%text>
int ${name_lib}_additional_data_new_<%text>##</%text> name<%text>##</%text> _nodup(${name_lib}_additional_data_t **ad, char *data);<%text>\</%text>
int ${name_lib}_additional_data_set_<%text>##</%text> name<%text>##</%text> _nodup_fast(${name_lib}_additional_data_t *ad, char *data, size_t len);<%text>\</%text>
int ${name_lib}_additional_data_set_<%text>##</%text> name<%text>##</%text> _nodup(${name_lib}_additional_data_t *ad, char *data);
% for obj in lib_classes.obj_list:
% if obj.short_type_name == 'additional_data':
% for field in obj.enum_list:
% if field.short_type_name == "additional_data_type":
% for member_name_string in field.vtype_members['string'] + field.vtype_members['date-time']:
_${name_lib.upper()}_ADDITIONAL_DATA_DECL(${member_name_string.lower().replace(name_lib + "_additional_data_type_", "")})
% endfor
% if field.vtype_members['byte[]'] != []:
int ${name_lib}_additional_data_new_byte_string_ref(${name_lib}_additional_data_t **ad, const unsigned char *data, size_t len);
int ${name_lib}_additional_data_set_byte_string_ref(${name_lib}_additional_data_t *ad, const unsigned char *data, size_t len);
int ${name_lib}_additional_data_new_byte_string_dup(${name_lib}_additional_data_t **ad, const unsigned char *data, size_t len);
int ${name_lib}_additional_data_set_byte_string_dup(${name_lib}_additional_data_t *ad, const unsigned char *data, size_t len);
int ${name_lib}_additional_data_new_byte_string_nodup(${name_lib}_additional_data_t **ad, unsigned char *data, size_t len);
int ${name_lib}_additional_data_set_byte_string_nodup(${name_lib}_additional_data_t *ad, unsigned char *data, size_t len);
% endif ## data_type
% endif ## additional_data_type
% endfor ## field_list
% endif ## additional_data
% endfor ## list_obj
/*
 * copy / clone / destroy
 */
int ${name_lib}_additional_data_copy_ref(${name_lib}_additional_data_t *src, ${name_lib}_additional_data_t *dst);
int ${name_lib}_additional_data_copy_dup(${name_lib}_additional_data_t *src, ${name_lib}_additional_data_t *dst);

/*
 * Accessors
 */

float ${name_lib}_additional_data_get_real(${name_lib}_additional_data_t *data);
uint32_t ${name_lib}_additional_data_get_integer(${name_lib}_additional_data_t *data);
${prefix}_bool_t ${name_lib}_additional_data_get_boolean(${name_lib}_additional_data_t *data);
char ${name_lib}_additional_data_get_character(${name_lib}_additional_data_t *data);
uint8_t ${name_lib}_additional_data_get_byte(${name_lib}_additional_data_t *data);

size_t ${name_lib}_additional_data_get_len(${name_lib}_additional_data_t *data);

${prefix}_bool_t ${name_lib}_additional_data_is_empty(${name_lib}_additional_data_t *data);

int ${name_lib}_additional_data_data_to_string(${name_lib}_additional_data_t *ad, ${prefix}_string_t *out);

#ifdef __cplusplus
 }
#endif

#endif /* _${prefix.upper()}_${name_lib.upper()}_DATA_H */
