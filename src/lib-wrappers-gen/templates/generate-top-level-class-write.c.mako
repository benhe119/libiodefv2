<%!
import sys
sys.path.append('../')
from field import Struct, EnumField, Union, DataType, Multiplicity, Field, PreDeclared
%>
/*****
*
* Copyright (C) 2001-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@prelude-ids.com>
* Author: Nicolas Delon <nicolas.delon@prelude-ids.com>
*
* This file is part of the ${prefix.capitalize()} library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/*
 * This file was automatically generated by our generator, version ${generator_version}
 *
 * Do not make changes to this file unless you know what you are doing.
 * modify the template interface file instead.
 * ${name_lib.upper()} version : ${lib_version}
 * Template file: generate-top-level-class-write.c.mako
 *
 */

#include "config.h"

#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "${prefix}-inttypes.h"
#include "${prefix}-list.h"
#include "${prefix}-log.h"
#include "${prefix}-io.h"
#include "${prefix}-ident.h"
#include "${prefix}-${top_class}-id.h"
#include "${name_lib}-${top_class}-id.h"
#include "${name_lib}.h"
#include "${name_lib}-tree-wrap.h"
#include "${name_lib}-${top_class}-write.h"
#include "common.h"



/*
 * If you wonder why we do this, and why life is complicated,
 * then wonder why the hell the guys that wrote ${name_lib.upper()} choose to use XML.
 * XML is dog slow. And XML'll never achieve performance needed for real time IDS.
 *
 * Here we are trying to communicate using a home made, binary version of ${name_lib.upper()}.
 */
int binary_write(${prefix}_io_t*, uint8_t, uint32_t, const void*);
int binary_write(${prefix}_io_t *fd, uint8_t tag, uint32_t len, const void *data)
{
        uint32_t l;

        l = htonl(len);

        ${prefix}_io_write(fd, &tag, sizeof(tag));
        ${prefix}_io_write(fd, &l, sizeof(l));

        if ( len > 0 )
                ${prefix}_io_write(fd, data, len);

        return 1;
}



static inline int ${prefix}_string_write(${prefix}_string_t *string, ${prefix}_io_t *fd, uint8_t tag)
{
        if ( ! string || ${prefix}_string_is_empty(string) )
                return 0;

        return binary_write(fd, tag, ${prefix}_string_get_len(string) + 1, ${prefix}_string_get_string(string));
}



static inline int uint64_write(uint64_t data, ${prefix}_io_t *fd, uint8_t tag)
{
        uint64_t dst;

        dst = ${prefix}_hton64(data);

        return binary_write(fd, tag, sizeof(dst), &dst);
}



static inline int uint32_write(uint32_t data, ${prefix}_io_t *fd, uint8_t tag)
{
        data = htonl(data);
        return binary_write(fd, tag, sizeof(data), &data);
}



static inline int int32_write(uint32_t data, ${prefix}_io_t *fd, uint8_t tag)
{
        return uint32_write(data, fd, tag);
}



static inline int uint8_write(uint8_t data, ${prefix}_io_t *fd, uint8_t tag)
{
        return binary_write(fd, tag, sizeof(data), &data);
}



static inline int uint16_write(uint16_t data, ${prefix}_io_t *fd, uint8_t tag)
{
        data = htons(data);
        return binary_write(fd, tag, sizeof(data), &data);
}



static inline int float_write(float data, ${prefix}_io_t *fd, uint8_t tag)
{
        uint32_t tmp = ${prefix}_htonf(data);
        return binary_write(fd, tag, sizeof(tmp), &tmp);
}


static inline int ${name_lib}_time_write(const ${name_lib}_time_t *data, ${prefix}_io_t *fd, uint8_t tag)
{
        uint32_t tmp;
        unsigned char buf[12];

        if ( ! data )
                return 0;

        tmp = htonl(${name_lib}_time_get_sec(data));
        memcpy(buf, &tmp, sizeof(tmp));

        tmp = htonl(${name_lib}_time_get_usec(data));
        memcpy(buf + 4, &tmp, sizeof(tmp));

        tmp = htonl(${name_lib}_time_get_gmt_offset(data));
        memcpy(buf + 8, &tmp, sizeof(tmp));

        return binary_write(fd, tag, sizeof (buf), buf);
}



static inline int ${name_lib}_data_write(${name_lib}_data_t *data, ${prefix}_io_t *fd, uint8_t tag)
{
        int ret;
        ${name_lib}_data_type_t type;

        if ( ! data )
                return 0;

        type = ${name_lib}_data_get_type(data);
        if ( type == ${name_lib.upper()}_DATA_TYPE_UNKNOWN )
                return 0;

        ret = uint32_write(${name_lib}_data_get_type(data), fd, tag);
        if ( ret < 0 )
                return ret;

        switch ( type ) {
        case ${name_lib.upper()}_DATA_TYPE_CHAR:
        case ${name_lib.upper()}_DATA_TYPE_BYTE:
                ret = uint8_write(* (const uint8_t *) ${name_lib}_data_get_data(data), fd, tag);
                break;

        case ${name_lib.upper()}_DATA_TYPE_UINT32:
                ret = uint32_write(${name_lib}_data_get_int(data), fd, tag);
                break;

        case ${name_lib.upper()}_DATA_TYPE_INT:
                ret = uint64_write(${name_lib}_data_get_int(data), fd, tag);
                break;

        case ${name_lib.upper()}_DATA_TYPE_FLOAT:
                ret = float_write(${name_lib}_data_get_float(data), fd, tag);
                break;

        case ${name_lib.upper()}_DATA_TYPE_CHAR_STRING:
        case ${name_lib.upper()}_DATA_TYPE_BYTE_STRING:
                ret = binary_write(fd, tag, ${name_lib}_data_get_len(data), ${name_lib}_data_get_data(data));
                break;

        case ${name_lib.upper()}_DATA_TYPE_TIME:
                ret = ${name_lib}_time_write(${name_lib}_data_get_data(data), fd, tag);
                break;

        case ${name_lib.upper()}_DATA_TYPE_UNKNOWN:
                /* nop */;
        }

        return ret;
}
% for obj in lib_classes.obj_list:
% if isinstance(obj , Struct):
/**
 * ${name_lib}_${obj.short_type_name}_write:
 * @${obj.short_type_name}: Pointer to a #${obj.type_name} object.
 * @msg: Pointer to a #${prefix}_msgbuf_t object, where the message should be written.
 *
 * Write @${obj.short_type_name} within @msg message buffer. The buffer is
 * associated with a #${prefix}_io_t file descriptor where the data will be written.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int ${name_lib}_${obj.short_type_name}_write(${obj.type_name} *${obj.short_type_name}, ${prefix}_io_t *fd)
{<% maj = obj.short_type_name.upper() %>
        int ret;
        if ( ! ${obj.short_type_name} )
            return 0;

## % if obj.type_name == name_lib + "_heartbeat_t":
##        ${prefix}_fd_set_priority(${prefix}_fdbuf_get_fd(fd), ${prefix.upper()}_MSG_PRIORITY_HIGH);
## % endif
% if obj.top_level == 0 :
        ret = binary_write(fd,  ${name_lib.upper()}_MSG_${maj}_TAG, 0, NULL);
        if ( ret < 0 )
                return ret;
% endif
% for field in obj.fields_list :
% if field.listed:
        {
                ${field.type_name} *${field.short_name} = NULL;


                while ( (${field.short_name} = ${name_lib}_${obj.short_type_name}_get_next_${field.short_name}(${obj.short_type_name}, ${field.short_name})) ) {
% if field.data_type== DataType.PRIMITIVE or field.data_type == DataType.PRIMITIVE_STRUCT:
                        ret = ${field.short_type_name}_write(${field.short_name}, fd, ${name_lib.upper()}_MSG_${obj.short_type_name.upper()}_${field.short_name.upper()} );
                        if ( ret < 0 )
                                return ret;
% else :
                        ret = ${name_lib}_${field.short_type_name}_write(${field.short_name}, fd);
                        if ( ret < 0 )
                                return ret;
% endif
            }
        }
% elif field.data_type == DataType.UNION:
        switch ( ${name_lib}_${obj.short_type_name}_get_${field.var}(${obj.short_type_name}) ) {
% for member in field.list_member :
                case ${member.value}:
                        ret = ${name_lib}_${member.short_type_name}_write(${name_lib}_${obj.short_type_name}_get_${member.name}(${obj.short_type_name}), fd);
                        break;
% endfor
                default:
                        /* nop */;
        }
% else:## Normal
% if field.data_type == DataType.PRIMITIVE or field.data_type == DataType.PRIMITIVE_STRUCT:
<%
    type = field.short_type_name
    function = type + "_write"
    maj1 = obj.short_type_name.upper()
    maj2 = field.name.upper()
%>
% if field.is_op_int:
        {
                ${field.type_name} *tmp;

                tmp = ${name_lib}_${obj.short_type_name}_get_${field.name}(${obj.short_type_name});
                if ( tmp ) {
                        ret = ${function}(*tmp, fd, ${name_lib.upper()}_MSG_${maj1}_${maj2});
                        if ( ret < 0 )
                                return ret;
## % if field.type_name == name_lib + "_impact_severity_t" :
##                        ${prefix}_fd_set_priority(${prefix}_fdbuf_get_fd(fd),
##                                                 _${name_lib}_impact_severity_to_fd_priority(*tmp));
## % endif
                }
        }
% else:
        ret = ${function}(${name_lib}_${obj.short_type_name}_get_${field.name}(${obj.short_type_name}), fd, ${name_lib.upper()}_MSG_${maj1}_${maj2});
        if ( ret < 0 )
                return ret;
% endif ## fin opt_int
%elif field.data_type== DataType.STRUCT or field.data_type== DataType.PRIMITIVE_STRUCT:
         ret = ${name_lib}_${field.short_type_name}_write(${name_lib}_${obj.short_type_name}_get_${field.name}(${obj.short_type_name}), fd);
         if ( ret < 0 )
                return ret;
%elif field.data_type == DataType.ENUM:
<%
    type = "uint32"
    function = type + "_write"
    maj1 = obj.short_type_name.upper()
    maj2 = field.name.upper()
%>
% if field.is_op_int:
        {
                ${field.type_name} *tmp;

                tmp = ${name_lib}_${obj.short_type_name}_get_${field.name}(${obj.short_type_name});
                if ( tmp ) {
                        ret = ${function}(*tmp, fd, ${name_lib.upper()}_MSG_${maj1}_${maj2});
                        if ( ret < 0 )
                                return ret;
##% if field.type_name == name_lib + "_impact_severity_t":
##                        ${prefix}_fd_set_priority(${prefix}_fdbuf_get_fd(fd),
##                                                 _${name_lib}_impact_severity_to_fd_priority(*tmp));
##% endif
                }
        }
% else :
        ret = ${function}(${name_lib}_${obj.short_type_name}_get_${field.name}(${obj.short_type_name}), fd, ${name_lib.upper()}_MSG_${maj1}_${maj2});
        if ( ret < 0 )
                return ret;
% endif
% endif

% endif
% endfor ##obj.fields_list
        return binary_write(fd, ${name_lib.upper()}_MSG_END_OF_TAG, 0, NULL);
}
% endif ## Struct end
% if isinstance(obj, PreDeclared) :
int ${name_lib}_${obj.short_type_name}_write(${obj.type_name} *, ${prefix}_io_t *);
% endif ##Predeclared

% endfor ##lib_classes
