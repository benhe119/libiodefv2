<%!
import sys
sys.path.append('../')
from field import Struct, EnumField, Union, DataType, Field, PreDeclared
%>\
/*****
*
* Copyright (C) 2001-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@prelude-ids.com>
* Author: Nicolas Delon <nicolas.delon@prelude-ids.com>
*
* This file is part of the ${prefix.capitalize()} library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/*
 * This file was automatically generated by our generator, version ${generator_version}
 *
 * Do not make changes to this file unless you know what you are doing.
 * modify the template interface file instead.
 * ${name_lib.upper()} version : ${lib_version}
 * Template file: generate-top-level-class-read-json.c.mako
 *
 */

#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "${prefix}-error.h"
#include "${prefix}-inttypes.h"
#include "${prefix}-list.h"
#include "${prefix}-extract.h"
#include "${prefix}-io.h"
#include "${name_lib}-${top_class}-id.h"
#include "${name_lib}.h"
#include "${name_lib}-tree-wrap.h"

#define JSMN_PARENT_LINKS

#include "lib-wrappers-gen/jsmn/jsmn.h"
#include "lib-wrappers-gen/jsmn/jsmn.c"

#ifndef MIN
# define MIN(x, y) ((x) < (y) ? (x) : (y))
#endif

typedef struct {
        const char *input;
        jsmntok_t jtok[1024];
        int jtoksize;
        unsigned int idx;
} json_data_t;

% for predeclared in lib_classes.predeclared_list:
static int ${name_lib}_${predeclared.short_type_name}_read_json(${predeclared.type_name} *${predeclared.short_type_name}, json_data_t *ctrl);
% endfor

// code from http://stackoverflow.com/a/4609989/697313
static int unicode_to_utf8(unsigned int codepoint, ${prefix}_string_t *out)
{
          char val;

          if ( codepoint < 0x80 )
                ${prefix}_string_ncat(out, (char *) &codepoint, 1);

          else if ( codepoint < 0x800 ) {
                val = 192 + codepoint / 64;
                ${prefix}_string_ncat(out, &val, 1);
                val = 128 + codepoint % 64;
                ${prefix}_string_ncat(out, &val, 1);
          }

          else if ( codepoint - 0xd800u < 0x800 )
                return 0; // surrogate must have been treated earlier

          else if ( codepoint < 0x10000 ) {
                val = 224 + codepoint / 4096;
                ${prefix}_string_ncat(out, &val, 1);
                val = 128 + codepoint /64 % 64;
                ${prefix}_string_ncat(out, &val, 1);
                val = 128 + codepoint % 64;
                ${prefix}_string_ncat(out, &val, 1);
          }

          else if ( codepoint < 0x110000 ) {
                val = 240 + codepoint / 262144;
                ${prefix}_string_ncat(out, &val, 1);
                val = 128 + codepoint / 4096 % 64;
                ${prefix}_string_ncat(out, &val, 1);
                val = 128 + codepoint / 64 % 64;
                ${prefix}_string_ncat(out, &val, 1);
                val = 128 + codepoint % 64;
                ${prefix}_string_ncat(out, &val, 1);
          }

          else
                return -1;

          return 1;
}


static int hexval(char c)
{
        if ( c >= '0' && c <= '9' )
                return c - '0';

        else if ( c >= 'a' && c <= 'f' )
                return c - 'a' + 10;

        else if ( c >= 'A' && c <= 'F' )
                return c - 'A' + 10;

        else return -1;
}


static int unescape_unicode(const char *in, const char *end)
{
        int h1, h2, h3, h4;

        if ( in + 4 > end )
                return ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "unicode sequence must be at least 4 characters long");;

        if ( (h1 = hexval(in[0])) < 0 || (h2 = hexval(in[1])) < 0 || (h3 = hexval(in[2])) < 0 || (h4 = hexval(in[3])) < 0 )
                return ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "invalid unicode escape: '%.6s'", in - 2);

        return h1 << 12 | h2 << 8 | h3 << 4 | h4;
}


static int unescape_string(${prefix}_string_t *out, const char *in, size_t size)
{
        int ret;
        const char *end = in + size;

        for ( ; in < end; in++ ) {
                if ( *in != '\\' ) {
                        ret = ${prefix}_string_ncat(out, in, 1);
                        continue;
                }

                in++;
                switch(*in) {
                        case '"':
                        case '/':
                        case '\\':
                                ret = ${prefix}_string_ncat(out, in, 1);
                                break;

                        case 'b':
                                ret = ${prefix}_string_ncat(out, "\b", 1);
                                break;
                        case 't':
                                ret = ${prefix}_string_ncat(out, "\t", 1);
                                break;
                        case 'n':
                                ret = ${prefix}_string_ncat(out, "\n", 1);
                                break;
                        case 'f':
                                ret = ${prefix}_string_ncat(out, "\f", 1);
                                break;
                        case 'r':
                                ret = ${prefix}_string_ncat(out, "\r", 1);
                                break;

                        case 'u': {
                                int codepoint;

                                codepoint = unescape_unicode(in + 1, end);
                                if ( codepoint < 0 )
                                        return codepoint;

                                if ( (codepoint & 0xfc00) == 0xd800 ) {
                                        /*
                                         * high surrogate; need one more unicode to succeed
                                         */
                                        in += 7;

                                        ret = unescape_unicode(in, end);
                                        if ( ret < 0 )
                                                return ret;

                                        codepoint = 0x10000 + ((codepoint - 0xd800) << 10) + (ret - 0xdc00);
                                }

                                ret = unicode_to_utf8(codepoint, out);
                                if ( ret < 0 )
                                        return ret;

                                in += 4;
                                break;
                        }

                        default:
                                ret = ${prefix}_string_ncat(out, in, 1);
                                break;
                }

                if ( ret < 0 )
                        return ret;
        }

        return 0;
}


static int __get_float(json_data_t *ctrl, float *value)
{
        char *end = NULL;
        jsmntok_t *j = &ctrl->jtok[ctrl->idx];
        size_t len = j->end - j->start;
        const char *str = ctrl->input + j->start;

        *value = strtof(ctrl->input + j->start, &end);
        if ( end != (str + len) )
                return ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "error decoding to real");

        return 0;
}



static int64_t __get_integer(json_data_t *ctrl)
{
        int64_t ret;
        char *end = NULL;
        jsmntok_t *j = &ctrl->jtok[ctrl->idx];
        size_t len = j->end - j->start;
        const char *str = ctrl->input + j->start;

        if ( j->type != JSMN_PRIMITIVE )
                return ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "JSON value is not a primitive");

        ret = strtoll(ctrl->input + j->start, &end, 10);
        if ( end != (str + len) )
                return ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "error decoding to integer");

        return ret;
}


static int __get_string_copy(json_data_t *ctrl, unsigned int idx, char *out, size_t size)
{
        size_t insize;
        jsmntok_t *j = &ctrl->jtok[idx];
        const char *input = ctrl->input + j->start;

        insize = j->end - j->start;

        if ( insize == 0 ) {
                *out = '\0';
                return 0;
        }

        else if ( insize >= size )
                return ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "buffer is too small");

        strncpy(out, input, MIN(size, j->end - j->start));
        out[j->end - j->start] = 0;

        return 0;
}

static int __get_string(json_data_t *ctrl, ${prefix}_string_t *out)
{
        jsmntok_t *j = &ctrl->jtok[ctrl->idx];
        const char *input = ctrl->input + j->start;

        if ( j->type != JSMN_STRING )
                return ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "JSON value is not string");

        if ( j->end - j->start == 0 )
                return 0;

        return unescape_string(out, input, j->end - j->start);
}


static int jsoneq(json_data_t *data, jsmntok_t *tok, const char *wanted)
{
    size_t size = tok->end - tok->start;
    const char *start = data->input + tok->start;

    if ( tok->type == JSMN_STRING && strlen(wanted) == size && strncmp(start, wanted, size) == 0)
            return 0;

    return -1;
}



static int __get_json_key(json_data_t *ctrl, const char *wanted, unsigned int sidx)
{
        unsigned int i;

        for ( i = 0; i < ctrl->jtok[sidx].size * 2; i++ ) {
                if ( jsoneq(ctrl, &ctrl->jtok[sidx + i], wanted) == 0 )
                        return i;
        }

        return -1;
}
% for obj in lib_classes.obj_list :
% if isinstance(obj, Struct):
<% i = 0 %>
/**
 * ${name_lib}_${obj.short_type_name}_read:
 * @${obj.short_type_name}: Pointer to a #${obj.type_name} object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an ${name_lib}_${obj.short_type_name} from the @json message, and
 * store it into @${obj.short_type_name}.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int ${name_lib}_${obj.short_type_name}_read_json(${obj.type_name} *${obj.short_type_name}, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
% if obj.short_type_name == "additional_data":
                unsigned int obj_idx = ctrl->idx;
% endif
        //printf("READ ${obj.short_type_name} idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }
% for field in obj.fields_list :
<% name = field.short_name if (field.listed or field.data_type == DataType.STRUCT) else field.name %>
% if field.data_type != DataType.UNION:
<% i += 1 %>
% if i == 1:
                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "${name}") == 0 ) {
                        ctrl->idx++;

% else:
                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "${name}") == 0 ) {
                        ctrl->idx++;
% endif
% endif
% if field.listed:
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {
% if field.data_type == DataType.PRIMITIVE or field.data_type == DataType.PRIMITIVE_STRUCT:
${struct_field_normal(obj, field)}
% else:
${struct_field_struct(obj, field, field.short_name)}
%endif
                        }
                }
% elif field.data_type == DataType.UNION:
% for member in field.list_member :
<% i += 1 %>
% if i == 1:
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "${member.name}") == 0){
                        ctrl->idx++;

% else:
                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "${member.name}") == 0){
                        ctrl->idx++;
% endif
${struct_field_struct(obj, member)}
                }
% endfor
% else: ##normal
% if field.data_type == DataType.PRIMITIVE or field.data_type == DataType.PRIMITIVE_STRUCT:
${struct_field_normal(obj, field)}
% elif field.data_type == DataType.ENUM:
${struct_field_normal(obj, field, "int32", "int32_t")}

% else:
${struct_field_struct(obj, field)}
                }
% endif ## normal
% endif ## field_type
% endfor ## field_list
                else {
                        return ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "unexpected field '%.*s' while reading ${obj.short_type_name}", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}
% endif ## is_struct
% endfor
<% first = True %>
int ${name_lib}_object_new_from_json(${name_lib}_object_t **object, const char *json_message)
{
        int ret, selfkey;
        jsmn_parser parser;
        json_data_t ctrl;

        jsmn_init(&parser);
        ctrl.idx = 0;
        ctrl.input = json_message;

        ret = ctrl.jtoksize = jsmn_parse(&parser, json_message, strlen(json_message), ctrl.jtok, sizeof(ctrl.jtok) / sizeof(*ctrl.jtok));
        if ( ret < 0 )
                return ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "error parsing json message");

        selfkey = __get_json_key(&ctrl, "_self", 0);
        if ( selfkey < 0 )
                return ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "json message miss '_self' attribute");
% for obj in sorted(lib_classes.obj_list, key=lambda obj: int(obj.ident)):
% if isinstance(obj, Struct):
% if not first:
        else
% else:
<% first = False %>
% endif ##
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "${obj.type_name}") == 0 ) {
                ret = ${name_lib}_${obj.short_type_name}_new((${name_lib}_${obj.short_type_name}_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = ${name_lib}_${obj.short_type_name}_read_json((${name_lib}_${obj.short_type_name}_t *) *object, &ctrl);
        }
% endif ## Struct
% endfor
        else {
                ret = ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "unknown object type '%s'", "");
        }

        return ret;
}
<%def name="struct_field_normal(obj, field, type_arg=None, var_type_arg=None)" >
<%type = type_arg if type_arg else field.value_type %>
<%var_type = var_type_arg if var_type_arg else field.type_name %>
% if field.listed:
% if field.data_type == DataType.ENUM:
                                        char buf[128];

                                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                                        if ( ret < 0 )
                                                return ret;

                                        int ret = ${name_lib}_${obj.short_type_name}_${field.short_name}_to_numeric(buf);
                                        if ( ret != -1 )
                                                ${name_lib}_${obj.short_type_name}_set_${field.short_name}(${obj.short_type_name}, ret, ${name_lib.upper()}_LIST_APPEND);
% elif field.is_op_int:
                                {
                                        int64_t ret;

                                        ret = __get_integer(ctrl);
                                        if ( ret < 0 )
                                                return ret;

                                        ${name_lib}_${obj.short_type_name}_set_${field.short_name}(${obj.short_type_name}, ret, ${name_lib.upper()}_LIST_APPEND);
                                }
% else:
                                        int ret;
                                        ${prefix}_string_t *str;

                                        ret = ${name_lib}_${obj.short_type_name}_new_${field.short_name}(${obj.short_type_name}, &str, ${name_lib.upper()}_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
% endif
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;
% else:
% if field.data_type == DataType.ENUM:
                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = ${name_lib}_${obj.short_type_name}_${field.short_name}_to_numeric(buf);
                        if ( ret != -1 )
                                ${name_lib}_${obj.short_type_name}_set_${field.short_name}(${obj.short_type_name}, ret);
% elif field.is_op_int:
                    {
                        int64_t ret;

                        ret = __get_integer(ctrl);
                        if ( ret < 0 )
                                return ret;

                        ${name_lib}_${obj.short_type_name}_set_${field.short_name}(${obj.short_type_name}, ret);
                    }
% elif field.type_name == name_lib + '_time_t':

                        int ret;
                        char buf[128];
                        ${name_lib}_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = ${name_lib}_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        ${name_lib}_${obj.short_type_name}_set_${field.short_name}(${obj.short_type_name}, time);
% elif field.type_name == name_lib + '_data_t':
% if obj.short_type_name != 'additional_data':
                        int ret;
                        ${name_lib}_data_t *data;
                        ${prefix}_string_t *str;

                        ret = ${name_lib}_${obj.short_type_name}_new_${field.short_name}(${obj.short_type_name}, &data);
                        if ( ret < 0 )
                                return ret;

                        ret = ${prefix}_string_new(&str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 ) {
                                ${prefix}_string_destroy(str);
                                return ret;
                        }
                        ret = ${name_lib}_data_set_byte_string_dup(data, (const unsigned char *) ${prefix}_string_get_string(str), ${prefix}_string_get_len(str));
                        ${prefix}_string_destroy(str);
##% elif field.type_name != '${name_lib}_data_t' and field.type_name != '${name_lib}_time_t' and not field.is_op_int and field.data_type != DataType.ENUM:
% else:
                        int ret;
                        char buf[128];
                        ${name_lib}_data_t *data;
                        ${name_lib}_additional_data_type_t type;

                        ret = __get_json_key(ctrl, "type", obj_idx);
                        if ( ret < 0 )
                                return ${prefix}_error_verbose(${prefix.upper()}_ERROR_GENERIC, "type argument required for additional data object");


                        ret = __get_string_copy(ctrl, obj_idx + ret + 1, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        type = ${name_lib}_additional_data_type_to_numeric(buf);
                        if ( type < 0 )
                                return type;

                        ret = ${name_lib}_${obj.short_type_name}_new_${field.short_name}(${obj.short_type_name}, &data);
                        if ( ret < 0 )
                                return ret;
% for field in obj.enum_list:
% if field.short_type_name == "additional_data_type":
                        switch(type) {
% if field.vtype_members['real'] != []:
% for real_member_name in field.vtype_members['real']:
                                case ${real_member_name}:
% endfor
                                {
                                        float val;

                                        ret = __get_float(ctrl, &val);
                                        if ( ret < 0 )
                                                return ret;

                                        ${name_lib}_data_set_float(data, val);
                                        break;
                                }
% endif
% if field.vtype_members['integer'] != []:
% for integer_member_name in field.vtype_members['integer']:
                                case ${integer_member_name}:
% endfor
                                {

                                        int64_t val;

                                        val = __get_integer(ctrl);
                                        if ( val < 0 )
                                                return val;

                                        ${name_lib}_data_set_int(data, val);
                                        break;
                                }
% endif
% if field.vtype_members['date-time'] != []:
% for date_time_member_name in field.vtype_members['date-time']:
                                case ${date_time_member_name}:
% endfor
                                {
                                        ${name_lib}_time_t *time;
                                        char buf[128];

                                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                                        if ( ret < 0 )
                                                return ret;

                                        ret = ${name_lib}_time_new_from_string(&time, buf);
                                        if ( ret < 0 )
                                                return ret;

                                        ${name_lib}_data_set_time(data, time);
                                        break;
                                }
% endif
% if field.vtype_members['string'] != [] or field.vtype_members['byte[]'] != []:
% for string_member_name in field.vtype_members['string'] + field.vtype_members['byte[]']:
                                case ${string_member_name}:
% endfor
                                {
                                        ${prefix}_string_t *str;

                                        ret = ${prefix}_string_new(&str);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 ) {
                                                ${prefix}_string_destroy(str);
                                                return ret;
                                        }
% if field.vtype_members['byte[]'] != []:
<% in_data_member_name = "" %>
% for data_member_name in field.vtype_members['byte[]'][:-1]:
<% in_data_member_name = in_data_member_name + "type == " + data_member_name + " || \n                                               " %>
% endfor
<% in_data_member_name = in_data_member_name + field.vtype_members['byte[]'][-1] %>
                                        if ( ${in_data_member_name} )
                                                ret = ${name_lib}_data_set_byte_string_dup(data, (const unsigned char *) ${prefix}_string_get_string(str), ${prefix}_string_get_len(str));
% endif
                                        else
                                                ret = ${name_lib}_data_set_char_string_dup_fast(data, ${prefix}_string_get_string(str), ${prefix}_string_get_len(str));

                                        ${prefix}_string_destroy(str);
                                        break;
                                }
% endif

                                default:
                                        return -1;
                        }
% endif ## additinal_data_type
% endfor ## enum_additional_data
% endif ## additional_data
% elif field.type_name == 'float':
                        int ret;
                        float *value;

                        ret = ${name_lib}_${obj.short_type_name}_new_${field.short_name}(${obj.short_type_name}, &value);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_float(ctrl, value);
                        if ( ret < 0 )
                                return ret;
% else:
                        int ret;
                        ${prefix}_string_t *str;

                        ret = ${name_lib}_${obj.short_type_name}_new_${field.short_name}(${obj.short_type_name}, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;

% endif
                }
% endif
</%def>
<%def name="struct_field_struct(obj, field, name_arg=None)" >
<% name = name_arg if name_arg else field.name %>

% if field.listed:
                                                int ret;
                                                ${name_lib}_${name}_t *${name};

                                                ret = ${name_lib}_${obj.short_type_name}_new_${name}(${obj.short_type_name}, &${name}, ${name_lib.upper()}_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = ${name_lib}_${name}_read_json(${name}, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;
% else:
                        int ret;
                        ${name_lib}_${name}_t *${name};

                        ret = ${name_lib}_${obj.short_type_name}_new_${name}(${obj.short_type_name}, &${name});
                        if ( ret < 0 )
                                return ret;

                        ret = ${name_lib}_${name}_read_json(${name}, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;
% endif
</%def>
