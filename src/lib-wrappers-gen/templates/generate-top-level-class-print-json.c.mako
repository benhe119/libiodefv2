<%!
import sys
sys.path.append('../')
from field import Struct, EnumField, Union, DataType, Multiplicity, Field, PreDeclared
%>
/*****
*
* Copyright (C) 2004-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@prelude-ids.com>
* Author: Nicolas Delon <nicolas.delon@prelude-ids.com>
*
* This file is part of the ${prefix.capitalize()} library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/*
 * This file was automatically generated by our generator, version ${generator_version}
 *
 * Do not make changes to this file unless you know what you are doing.
 * modify the template interface file instead.
 * ${name_lib.upper()} version : ${lib_version}
 * Template file: generate-top-level-class-print-json.c.mako
 *
 */

#include "config.h"
#include "libmissing.h"

#include <stdio.h>
#include <string.h>

#include "${name_lib}.h"
#include "${name_lib}-tree-wrap.h"
#include "${name_lib}-${top_class}-print-json.h"


#define conv_uint8 conv_uint64
#define conv_uint16 conv_uint64
#define conv_uint32 conv_uint64
#define conv_int8 conv_int64
#define conv_int16 conv_int64
#define conv_int32 conv_int64


static int conv_uint64(${prefix}_io_t *fd, uint64_t value)
{
        int ret;
        char buf[32];

        ret = snprintf(buf, sizeof(buf), "%" ${prefix.upper()}_PRIu64, value);
        if ( ret < 0 || ret >= sizeof(buf) )
                return -1;

        return ${prefix}_io_write(fd, buf, ret);
}


static int conv_int64(${prefix}_io_t *fd, int64_t value)
{
        int ret;
        char buf[32];

        ret = snprintf(buf, sizeof(buf), "%" ${prefix.upper()}_PRId64, value);
        if ( ret < 0 || ret >= sizeof(buf) )
                return -1;

        return ${prefix}_io_write(fd, buf, ret);
}


static int conv_float(${prefix}_io_t *fd, float value)
{
        int ret;
        char buf[32];

        ret = snprintf(buf, sizeof(buf), "%f", value);
        if ( ret < 0 || ret >= sizeof(buf) )
                return -1;

        return ${prefix}_io_write(fd, buf, ret);
}


static int conv_string(${prefix}_io_t *fd, ${prefix}_string_t *string)
{
        size_t i;
        ssize_t ret;
        const unsigned char *content;

        content = (const unsigned char *) ${prefix}_string_get_string_or_default(string, "");
        ret = ${prefix}_io_write(fd, "\"", 1);
        if ( ret < 0 )
                return ret;

        for ( i = 0; i < ${prefix}_string_get_len(string); i++, content++ ) {
                switch(*content) {
                        case '\\':
                        case '"':
                        case '/':
                                ret = ${prefix}_io_write(fd, "\\", 1);
                                if ( ret < 0 )
                                        return ret;

                                ret = ${prefix}_io_write(fd, content, 1);
                                break;
                        case '\b':
                                ret = ${prefix}_io_write(fd, "\\b", 2);
                                break;
                        case '\t':
                                ret = ${prefix}_io_write(fd, "\\t", 2);
                                break;
                        case '\n':
                                ret = ${prefix}_io_write(fd, "\\n", 2);
                                break;
                        case '\f':
                                ret = ${prefix}_io_write(fd, "\\f", 2);
                                break;
                        case '\r':
                                ret = ${prefix}_io_write(fd, "\\r", 2);
                                break;
                        default:
                                if ( *content >= 0x20 )
                                        ret = ${prefix}_io_write(fd, content, 1);
                                else {
                                        char seq[7];
                                        snprintf(seq, sizeof(seq), "\\u%04X", *content);
                                        ret = ${prefix}_io_write(fd, seq, strlen(seq));
                                }
                }

                if ( ret < 0 )
                        return ret;
        }

        return ${prefix}_io_write(fd, "\"", 1);
}


static int conv_time(${prefix}_io_t *fd, ${name_lib}_time_t *t)
{
        int ret;
        ${prefix}_string_t *str;

        if ( ! t )
                return 0;

        ret = ${prefix}_string_new(&str);
        if ( ret < 0 )
                return ret;

        ret = ${name_lib}_time_to_string(t, str);
        if ( ret < 0 )
                goto error;

        ret = conv_string(fd, str);

error:
        ${prefix}_string_destroy(str);
        return ret;
}


static int conv_data(${prefix}_io_t *fd, ${name_lib}_data_t *data)
{
        int ret;
        ${prefix}_string_t *out;

        ret = ${prefix}_string_new(&out);
        if ( ret < 0 )
                return ret;

        ret = ${name_lib}_data_to_string(data, out);
        if ( ret < 0 )
                goto error;

        switch (${name_lib}_data_get_type(data)) {
                case ${name_lib.upper()}_DATA_TYPE_INT:
                case ${name_lib.upper()}_DATA_TYPE_FLOAT:
                        ret = ${prefix}_io_write(fd, ${prefix}_string_get_string(out), ${prefix}_string_get_len(out));
                        break;
                default:
                        ret = conv_string(fd, out);
                        break;
        }
error:
        ${prefix}_string_destroy(out);
        return ret;
}


static int do_write(${prefix}_io_t *fd, const char *str)
{
        return ${prefix}_io_write(fd, str, strlen(str));
}
% for obj in lib_classes.obj_list :
% if isinstance(obj, Struct) :
/**
 * ${name_lib}_${obj.short_type_name}_json:
 * @ptr: Pointer to an ${obj.type_name} object.
 *
 * This function will convert @ptr to a json,
 */
int ${name_lib}_${obj.short_type_name}_print_json(${obj.type_name} *ptr, ${prefix}_io_t *fd)
{
        int ret;

        if ( ! ptr )
                return 0;

        ret = do_write(fd, "{\"_self\": \"${obj.type_name}\"");
        if ( ret < 0 )
                return ret;
% for field in obj.fields_list:
% if field.data_type == DataType.UNION:
        switch ( ${name_lib}_${obj.short_type_name}_get_${field.var}(ptr) ) {
% for member in field.list_member:
        case ${member.value}:
                ret = do_write(fd, ", \"${member.name}\": ");
                if ( ret < 0 )
                        return ret;

                ret = ${name_lib}_${member.name}_print_json(${name_lib}_${obj.short_type_name}_get_${member.name}(ptr), fd);
                if ( ret < 0 )
                        return ret;
                break;
% endfor ## end_member_list
        default:
                break;
        }
% elif field.listed:
{

                ${field.type_name} *elem = NULL;
                int first = 1;

                while ( (elem = ${name_lib}_${obj.short_type_name}_get_next_${field.short_name}(ptr, elem)) ) {
                        if ( ! first )
                                ret = do_write(fd, ", ");
                        else {
                                first = 0;
                                ret = do_write(fd, ", \"${field.short_name}\": [");
                        }

                        if ( ret < 0 )
                                return ret;
% if field.data_type == DataType.PRIMITIVE or field.data_type == DataType.PRIMITIVE_STRUCT:
                        ret = conv_${field.value_type}(fd, elem);
                        if ( ret < 0 )
                                return ret;
% else:
                        ret = ${name_lib}_${field.short_type_name}_print_json(elem, fd);
                        if ( ret < 0 )
                                return ret;
% endif
 }

                if ( ! first ) {
                        ret = do_write(fd, "]");
                        if ( ret < 0 )
                                return ret;
                }
        }
% else:
<% refer = "*" if field.is_op_int else "" %>
% if  field.data_type == DataType.ENUM:
        {
                int ${refer}i = ${name_lib}_${obj.short_type_name}_get_${field.name}(ptr);
% if field.is_op_int:
                if ( i )
% endif
{
                        const char *enumstr = ${name_lib}_${field.short_type_name}_to_string(${refer}i);

                        if ( enumstr ) {
                                ret = do_write(fd, ", \"${field.short_name}\": \"");
                                if ( ret < 0 )
                                        return ret;

                                ret = do_write(fd, enumstr);
                                if ( ret < 0 )
                                        return ret;

                                ret = do_write(fd, "\"");
                                if ( ret < 0 )
                                        return ret;
                        }
                }
        }
% elif field.data_type == DataType.PRIMITIVE or field.data_type == DataType.PRIMITIVE_STRUCT:
% if  field.data_type == DataType.STRUCT or field.data_type == DataType.PRIMITIVE_STRUCT or field.is_op_int:
        {
                ${field.type_name} *field;

                field = ${name_lib}_${obj.short_type_name}_get_${field.name}(ptr);
                if ( field ) {
                        ret = do_write(fd, ", \"${field.short_name}\": ");
                        if ( ret < 0 )
                                return ret;

                        ret = conv_${field.value_type}(fd, ${refer}field);
                        if ( ret < 0 )
                                return ret;
                }
        }
% else:
        {
                ${field.type_name} field;

                field = ${name_lib}_${obj.short_type_name}_get_${field.name}(ptr);
                if ( field ) {
                        ret = do_write(fd, ", \"${field.short_name}\": ");
                        if ( ret < 0 )
                                return ret;

                        ret = conv_${field.value_type}(fd, ${refer}field);
                        if ( ret < 0 )
                                return ret;
                }
        }
% endif ##opt or primitive_struct
% elif  field.data_type == DataType.STRUCT or field.data_type == DataType.PRIMITIVE_STRUCT:
{
                ${field.type_name} *field;

                field = ${name_lib}_${obj.short_type_name}_get_${field.name}(ptr);
                if ( field ) {
                        ret = do_write(fd, ", \"${field.short_name}\": ");
                        if ( ret < 0 )
                                return ret;

                        ret = ${name_lib}_${field.short_type_name}_print_json(field, fd);
                        if ( ret < 0 )
                                return ret;
                }
        }
% endif ## field_normal
% endif ## field_case
% endfor ## field_list
return do_write(fd, "}");
}
% endif ## struct_end
% endfor ## obj_list
