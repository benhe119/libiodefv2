<%!
import sys
sys.path.append('../')
from field import Struct, EnumField, Union, DataType, Field, PreDeclared
%>
<%def name="header()">
/*****
*
* Copyright (C) 2008-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@prelude-ids.com>
*
* This file is part of the ${prefix.capitalize()} library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/*
 * This file was automatically generated by our generator, version ${generator_version}
 *
 * Do not make changes to this file unless you know what you are doing.
 * modify the template interface file instead.
 * ${name_lib.upper()} version : ${lib_version}
 * Template file: generate-tree-wrap.hxx.mako
 *
 */


#ifndef _${prefix.upper()}_${name_lib.upper()}_TREE_WRAP_HXX
#define _${prefix.upper()}_${name_lib.upper()}_TREE_WRAP_HXX

#include <list>
#include <string>

#include "${prefix}.h"
#include "${name_lib}-time.hxx"

using namespace std;


class ${name_lib.upper()}${name_lib}_data {
};
</%def>
<%def name="footer(type_list)">
% for (short_type_name, ident) in type_list:
#define ${short_type_name} ${ident}
% endfor
#endif /*_${prefix.upper()}_${name_lib.upper()}_TREE_WRAP */
</%def>
<%def name="struct_definition(struct)">
<% priv = 0 ; type = "" %>
class ${name_lib.upper()}${struct.short_type_name} {
% for member in struct.fields_list:
##% if member.data_type == DataType.STRUCT or member.listed or member.data_type == DataType.UNION :
% if member.data_type != DataType.PRIMITIVE and member.data_type != DataType.PRIMITIVE_STRUCT and member.data_type != DataType.ENUM:
% if priv == 0:
<% priv = 1 %>private:
% endif
%if member.listed:
<% type = "std::list<" + name_lib.upper() + member.short_type_name + " *>" %>
%elif member.data_type == DataType.UNION:
        union {
% for umember in member.list_member:
<% type = "%s%s *" % (name_lib.upper(), umember.short_type_name) %>
                ${type} ${umember.short_type_name};
% endfor
        } ${member.name};
        ${member.type_name} ${member.var};
<% continue %>
% else:
<% type = "%s%s *" % (name_lib.upper(), member.short_type_name) %>
% endif
        ${type} ${member.short_type_name};
% endif ## big if
% endfor
    protected:
        ${struct.type_name} *_priv;
        ${struct.type_name} *_priv;

    public:
</%def>
<%def name="struct_constructor(struct)">
        ${name_lib.upper()}${struct.short_type_name}();
        ${name_lib.upper()}${struct.short_type_name}(${struct.type_name} *ptr);
        ${name_lib.upper()}${struct.short_type_name} *copy(${name_lib.upper()}${struct.short_type_name} *dst);
        ${name_lib.upper()}${struct.short_type_name} *clone();
        int compare(${name_lib.upper()}${struct.short_type_name} *obj1);
</%def>
<%def name="struct_ref(struct)">
% if struct.refcount == 1 :
        ${name_lib.upper()}${struct.short_type_name} *ref();
% endif
</%def>
<%def name="struct_destroy(struct)">
        ~{${name_lib.upper()}$struct.short_type_name}();\n");
</%def>
<%def name="struct_field_normal(field, name_member=None)">
<%
    (name, field_is_op_int) = (name_member, False) if name_member else (field.name, field.is_op_int)
    ptr = ""
    refer = ""
    if field.data_type == DataType.STRUCT or field.data_type == DataType.PRIMITIVE_STRUCT:
        refer = "*"
        ptr = "*"
    if  field_is_op_int:
        refer = "*"
    type = field.type_name
    if name == "class":
        field_name = "class_str"
    elif name == "virtual":
        field_name = "virtual_sys"
    elif name == "operator":
        field_name = "operator_indic"
    else:
        field_name = name
%>
% if field_is_op_int:
        void unset_${name}();
% endif
% if field.type_name == prefix + "_string_t":
<% type = "std::string" %>
% elif field.type_name == "time_time_t":
<% type = name_lib.upper() + "Time" %>
%elif  field.type == DataType.STRUCT or field.data_type == DataType.PRIMITIVE_STRUCT:
<% type = "%s%s" % (name_lib.upper(), field.short_type_name) %>
% else:
<% type = field.type_name %>
% endif
        ${type} ${refer}get_${name}();
        void set_${name}(${type} ${ptr}${field_name});
        ${type} *new_${name}();

</%def>
<%def name="struct_field_union(field)">
        ${field.type_name} get_${field.var}();
% for member in field.list_member:
## <% name = member.name ; member.name = field.name + name %>
${struct_field_normal(member, member.name)}
% endfor
</%def>
<%def name="struct_field_list(field)">
<% type = field.type_name %>
% if field.type_name == prefix + "_string_t":
<% type = "std::string" %>
%elif field.data_type != DataType.PRIMITIVE and field.data_type != DataType.PRIMITIVE_STRUCT:
<% type = name_lib.upper() + "" + field.short_type_name %>
% else:
<% type = field.type_name %>
% endif
        std::list<${type} *> *get_${field.short_name}_list();
        void set_${field.short_name}(${type} *object, int pos);
        ${type} *new_${field.short_name}(int pos);
</%def>
<%def name="struct_field(struct)">
%for field in struct.fields_list :
%if field.listed:
${struct_field_list(field)}
%elif field.data_type == DataType.UNION:
${struct_field_union(field)}
%else:
${struct_field_normal(field)}
%endif
%endfor
</%def>
<%def name="struct(struct)">
    ${struct_definition(struct)}
    ${struct_constructor(struct)}
    ##    ${struct_ref(struct)}
    ${struct_destroy(struct)}
    ${struct_field(struct)}
};
</%def>
<%def name="pre_dec(pre_declared)">
%if  pre_declared.data_type == DataType.STRUCT:
typedef struct ${name_lib}_${pre_declared.short_type_name} ${pre_declared.type_name};
% else:
typedef enum ${name_lib}_${pre_declared.short_type_name} ${pre_declared.type_name};
% endif
</%def>
<%def name="generateFile(lib_classes)">
${header()}
% for obj in lib_classes.obj_list:
    % if isinstance(obj, Struct):
        ${struct(obj)}
##    % elif isinstance(obj, EnumField):
##        ${enum(obj)}
    % elif isinstance(obj, PreDeclared):
        ${pre_dec(obj)}
    % endif
%endfor
${footer(lib_classes.type_list)}
</%def>
${generateFile(lib_classes)}
