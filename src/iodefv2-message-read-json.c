
/*****
*
* Copyright (C) 2001-2016 CS-SI. All Rights Reserved.
* Author: Yoann Vandoorselaere <yoann.v@libidmefv2-ids.com>
* Author: Nicolas Delon <nicolas.delon@libidmefv2-ids.com>
*
* This file is part of the Libiodefv2 library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/* Auto-generated by the iodefv2-message-read.c.mako template */
#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "libiodefv2-error.h"
#include "libiodefv2-inttypes.h"
#include "libiodefv2-list.h"
#include "libiodefv2-extract.h"
#include "libiodefv2-io.h"
#include "iodefv2-document-id.h"
#include "iodefv2.h"
#include "iodefv2-tree-wrap.h"

#define JSMN_PARENT_LINKS

#include "lib-wrappers-gen/jsmn/jsmn.h"
#include "lib-wrappers-gen/jsmn/jsmn.c"

#ifndef MIN
# define MIN(x, y) ((x) < (y) ? (x) : (y))
#endif

typedef struct {
        const char *input;
        jsmntok_t jtok[1024];
        int jtoksize;
        unsigned int idx;
} json_data_t;

static int iodefv2_contact_read_json(iodefv2_contact_t *contact, json_data_t *ctrl);
static int iodefv2_address_read_json(iodefv2_address_t *address, json_data_t *ctrl);
static int iodefv2_detection_pattern_read_json(iodefv2_detection_pattern_t *detection_pattern, json_data_t *ctrl);
static int iodefv2_contact_read_json(iodefv2_contact_t *contact, json_data_t *ctrl);
static int iodefv2_contact_read_json(iodefv2_contact_t *contact, json_data_t *ctrl);
static int iodefv2_application_header_field_read_json(iodefv2_application_header_field_t *application_header_field, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_contact_read_json(iodefv2_contact_t *contact, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_related_dns_read_json(iodefv2_related_dns_t *related_dns, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_application_read_json(iodefv2_application_t *application, json_data_t *ctrl);
static int iodefv2_application_read_json(iodefv2_application_t *application, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_fuzzy_hash_value_read_json(iodefv2_fuzzy_hash_value_t *fuzzy_hash_value, json_data_t *ctrl);
static int iodefv2_application_read_json(iodefv2_application_t *application, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_email_header_field_read_json(iodefv2_email_header_field_t *email_header_field, json_data_t *ctrl);
static int iodefv2_associated_software_read_json(iodefv2_associated_software_t *associated_software, json_data_t *ctrl);
static int iodefv2_file_properties_read_json(iodefv2_file_properties_t *file_properties, json_data_t *ctrl);
static int iodefv2_application_read_json(iodefv2_application_t *application, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_operating_system_read_json(iodefv2_operating_system_t *operating_system, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_application_read_json(iodefv2_application_t *application, json_data_t *ctrl);
static int iodefv2_record_item_read_json(iodefv2_record_item_t *record_item, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_event_data_read_json(iodefv2_event_data_t *event_data, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);
static int iodefv2_additional_data_read_json(iodefv2_additional_data_t *additional_data, json_data_t *ctrl);



// code from http://stackoverflow.com/a/4609989/697313
static int unicode_to_utf8(unsigned int codepoint, libiodefv2_string_t *out)
{
          char val;

          if ( codepoint < 0x80 )
                libiodefv2_string_ncat(out, (char *) &codepoint, 1);

          else if ( codepoint < 0x800 ) {
                val = 192 + codepoint / 64;
                libiodefv2_string_ncat(out, &val, 1);
                val = 128 + codepoint % 64;
                libiodefv2_string_ncat(out, &val, 1);
          }

          else if ( codepoint - 0xd800u < 0x800 )
                return 0; // surrogate must have been treated earlier

          else if ( codepoint < 0x10000 ) {
                val = 224 + codepoint / 4096;
                libiodefv2_string_ncat(out, &val, 1);
                val = 128 + codepoint /64 % 64;
                libiodefv2_string_ncat(out, &val, 1);
                val = 128 + codepoint % 64;
                libiodefv2_string_ncat(out, &val, 1);
          }

          else if ( codepoint < 0x110000 ) {
                val = 240 + codepoint / 262144;
                libiodefv2_string_ncat(out, &val, 1);
                val = 128 + codepoint / 4096 % 64;
                libiodefv2_string_ncat(out, &val, 1);
                val = 128 + codepoint / 64 % 64;
                libiodefv2_string_ncat(out, &val, 1);
                val = 128 + codepoint % 64;
                libiodefv2_string_ncat(out, &val, 1);
          }

          else
                return -1;

          return 1;
}


static int hexval(char c)
{
        if ( c >= '0' && c <= '9' )
                return c - '0';

        else if ( c >= 'a' && c <= 'f' )
                return c - 'a' + 10;

        else if ( c >= 'A' && c <= 'F' )
                return c - 'A' + 10;

        else return -1;
}


static int unescape_unicode(const char *in, const char *end)
{
        int h1, h2, h3, h4;

        if ( in + 4 > end )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unicode sequence must be at least 4 characters long");;

        if ( (h1 = hexval(in[0])) < 0 || (h2 = hexval(in[1])) < 0 || (h3 = hexval(in[2])) < 0 || (h4 = hexval(in[3])) < 0 )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "invalid unicode escape: '%.6s'", in - 2);

        return h1 << 12 | h2 << 8 | h3 << 4 | h4;
}


static int unescape_string(libiodefv2_string_t *out, const char *in, size_t size)
{
        int ret;
        const char *end = in + size;

        for ( ; in < end; in++ ) {
                if ( *in != '\\' ) {
                        ret = libiodefv2_string_ncat(out, in, 1);
                        continue;
                }

                in++;
                switch(*in) {
                        case '"':
                        case '/':
                        case '\\':
                                ret = libiodefv2_string_ncat(out, in, 1);
                                break;

                        case 'b':
                                ret = libiodefv2_string_ncat(out, "\b", 1);
                                break;
                        case 't':
                                ret = libiodefv2_string_ncat(out, "\t", 1);
                                break;
                        case 'n':
                                ret = libiodefv2_string_ncat(out, "\n", 1);
                                break;
                        case 'f':
                                ret = libiodefv2_string_ncat(out, "\f", 1);
                                break;
                        case 'r':
                                ret = libiodefv2_string_ncat(out, "\r", 1);
                                break;

                        case 'u': {
                                int codepoint;

                                codepoint = unescape_unicode(in + 1, end);
                                if ( codepoint < 0 )
                                        return codepoint;

                                if ( (codepoint & 0xfc00) == 0xd800 ) {
                                        /*
                                         * high surrogate; need one more unicode to succeed
                                         */
                                        in += 7;

                                        ret = unescape_unicode(in, end);
                                        if ( ret < 0 )
                                                return ret;

                                        codepoint = 0x10000 + ((codepoint - 0xd800) << 10) + (ret - 0xdc00);
                                }

                                ret = unicode_to_utf8(codepoint, out);
                                if ( ret < 0 )
                                        return ret;

                                in += 4;
                                break;
                        }

                        default:
                                ret = libiodefv2_string_ncat(out, in, 1);
                                break;
                }

                if ( ret < 0 )
                        return ret;
        }

        return 0;
}


static int __get_float(json_data_t *ctrl, float *value)
{
        char *end = NULL;
        jsmntok_t *j = &ctrl->jtok[ctrl->idx];
        size_t len = j->end - j->start;
        const char *str = ctrl->input + j->start;

        *value = strtof(ctrl->input + j->start, &end);
        if ( end != (str + len) )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "error decoding to real");

        return 0;
}



static int64_t __get_integer(json_data_t *ctrl)
{
        int64_t ret;
        char *end = NULL;
        jsmntok_t *j = &ctrl->jtok[ctrl->idx];
        size_t len = j->end - j->start;
        const char *str = ctrl->input + j->start;

        if ( j->type != JSMN_PRIMITIVE )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "JSON value is not a primitive");

        ret = strtoll(ctrl->input + j->start, &end, 10);
        if ( end != (str + len) )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "error decoding to integer");

        return ret;
}


static int __get_string_copy(json_data_t *ctrl, unsigned int idx, char *out, size_t size)
{
        size_t insize;
        jsmntok_t *j = &ctrl->jtok[idx];
        const char *input = ctrl->input + j->start;

        insize = j->end - j->start;

        if ( insize == 0 ) {
                *out = '\0';
                return 0;
        }

        else if ( insize >= size )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "buffer is too small");

        strncpy(out, input, MIN(size, j->end - j->start));
        out[j->end - j->start] = 0;

        return 0;
}

static int __get_string(json_data_t *ctrl, libiodefv2_string_t *out)
{
        jsmntok_t *j = &ctrl->jtok[ctrl->idx];
        const char *input = ctrl->input + j->start;

        if ( j->type != JSMN_STRING )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "JSON value is not string");

        if ( j->end - j->start == 0 )
                return 0;

        return unescape_string(out, input, j->end - j->start);
}


static int jsoneq(json_data_t *data, jsmntok_t *tok, const char *wanted)
{
    size_t size = tok->end - tok->start;
    const char *start = data->input + tok->start;

    if ( tok->type == JSMN_STRING && strlen(wanted) == size && strncmp(start, wanted, size) == 0)
            return 0;

    return -1;
}



static int __get_json_key(json_data_t *ctrl, const char *wanted, unsigned int sidx)
{
        unsigned int i;

        for ( i = 0; i < ctrl->jtok[sidx].size * 2; i++ ) {
                if ( jsoneq(ctrl, &ctrl->jtok[sidx + i], wanted) == 0 )
                        return i;
        }

        return -1;
}

/**
 * iodefv2_telephone_read:
 * @telephone: Pointer to a #iodefv2_telephone_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_telephone from the @json message, and
 * store it into @telephone.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_telephone_read_json(iodefv2_telephone_t *telephone, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ telephone idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "type") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_telephone_type_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_telephone_set_type(telephone, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_telephone_new_ext_type(telephone, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "telephone_number") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_telephone_new_telephone_number(telephone, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_telephone_new_description(telephone, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading telephone", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_certificate_read:
 * @certificate: Pointer to a #iodefv2_certificate_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_certificate from the @json message, and
 * store it into @certificate.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_certificate_read_json(iodefv2_certificate_t *certificate, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ certificate idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_certificate_new_observable_id(certificate, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "x509_data") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_data_t *data;
                        libiodefv2_string_t *str;

                        ret = iodefv2_certificate_new_x509_data(certificate, &data);
                        if ( ret < 0 )
                                return ret;

                        ret = libiodefv2_string_new(&str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 ) {
                                libiodefv2_string_destroy(str);
                                return ret;
                        }
                        ret = iodefv2_data_set_byte_string_dup(data, (const unsigned char *) libiodefv2_string_get_string(str), libiodefv2_string_get_len(str));
                        libiodefv2_string_destroy(str);    
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_certificate_new_description(certificate, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading certificate", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_key_read:
 * @key: Pointer to a #iodefv2_key_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_key from the @json message, and
 * store it into @key.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_key_read_json(iodefv2_key_t *key, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ key idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "registryaction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_key_registryaction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_key_set_registryaction(key, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_registryaction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_key_new_ext_registryaction(key, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_key_new_observable_id(key, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "key_name") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_key_new_key_name(key, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "key_value") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_key_new_key_value(key, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading key", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_observable_reference_read:
 * @observable_reference: Pointer to a #iodefv2_observable_reference_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_observable_reference from the @json message, and
 * store it into @observable_reference.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_observable_reference_read_json(iodefv2_observable_reference_t *observable_reference, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ observable_reference idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "uid_ref") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_observable_reference_new_uid_ref(observable_reference, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading observable_reference", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_domain_contacts_read:
 * @domain_contacts: Pointer to a #iodefv2_domain_contacts_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_domain_contacts from the @json message, and
 * store it into @domain_contacts.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_domain_contacts_read_json(iodefv2_domain_contacts_t *domain_contacts, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ domain_contacts idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_contact_t *contact;

                                                ret = iodefv2_domain_contacts_new_contact(domain_contacts, &contact, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_contact_read_json(contact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "same_domain_contact") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_domain_contacts_new_same_domain_contact(domain_contacts, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading domain_contacts", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_extension_read:
 * @extension: Pointer to a #iodefv2_extension_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_extension from the @json message, and
 * store it into @extension.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_extension_read_json(iodefv2_extension_t *extension, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ extension idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_extension_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_extension_set_restriction(extension, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "name") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_extension_new_name(extension, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "dtype") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_extension_dtype_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_extension_set_dtype(extension, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_extension_new_ext_restriction(extension, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "meaning") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_extension_new_meaning(extension, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_extension_new_observable_id(extension, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "formatid") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_extension_new_formatid(extension, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_dtype") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_extension_new_ext_dtype(extension, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading extension", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_registry_handle_read:
 * @registry_handle: Pointer to a #iodefv2_registry_handle_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_registry_handle from the @json message, and
 * store it into @registry_handle.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_registry_handle_read_json(iodefv2_registry_handle_t *registry_handle, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ registry_handle idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "registry") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_registry_handle_registry_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_registry_handle_set_registry(registry_handle, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_registry") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_registry_handle_new_ext_registry(registry_handle, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading registry_handle", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_time_impact_read:
 * @time_impact: Pointer to a #iodefv2_time_impact_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_time_impact from the @json message, and
 * store it into @time_impact.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_time_impact_read_json(iodefv2_time_impact_t *time_impact, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ time_impact idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_metric") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_time_impact_new_ext_metric(time_impact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "duration") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_impact_duration_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_time_impact_set_duration(time_impact, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "metric") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_impact_metric_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_time_impact_set_metric(time_impact, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "severity") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_impact_severity_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_time_impact_set_severity(time_impact, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_duration") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_time_impact_new_ext_duration(time_impact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading time_impact", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_record_pattern_read:
 * @record_pattern: Pointer to a #iodefv2_record_pattern_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_record_pattern from the @json message, and
 * store it into @record_pattern.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_record_pattern_read_json(iodefv2_record_pattern_t *record_pattern, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ record_pattern idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "offsetunit") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_record_pattern_offsetunit_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_record_pattern_set_offsetunit(record_pattern, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "instance") == 0 ) {
                        ctrl->idx++;



                    {
                        int64_t ret;

                        ret = __get_integer(ctrl);
                        if ( ret < 0 )
                                return ret;

                        iodefv2_record_pattern_set_instance(record_pattern, ret);
                    }
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_record_pattern_new_ext_type(record_pattern, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "offset") == 0 ) {
                        ctrl->idx++;



                    {
                        int64_t ret;

                        ret = __get_integer(ctrl);
                        if ( ret < 0 )
                                return ret;

                        iodefv2_record_pattern_set_offset(record_pattern, ret);
                    }
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_offsetunit") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_record_pattern_new_ext_offsetunit(record_pattern, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_record_pattern_type_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_record_pattern_set_type(record_pattern, ret);
                } 

                
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading record_pattern", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_reference_read:
 * @reference: Pointer to a #iodefv2_reference_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_reference from the @json message, and
 * store it into @reference.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_reference_read_json(iodefv2_reference_t *reference, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ reference idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_reference_new_observable_id(reference, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "url") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_reference_new_url(reference, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_reference_new_description(reference, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "reference_name") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_reference_new_reference_name(reference, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading reference", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_postal_address_read:
 * @postal_address: Pointer to a #iodefv2_postal_address_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_postal_address from the @json message, and
 * store it into @postal_address.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_postal_address_read_json(iodefv2_postal_address_t *postal_address, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ postal_address idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "type") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_postal_address_type_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_postal_address_set_type(postal_address, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_postal_address_new_ext_type(postal_address, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "p_address") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_postal_address_new_p_address(postal_address, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_postal_address_new_description(postal_address, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading postal_address", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_node_role_read:
 * @node_role: Pointer to a #iodefv2_node_role_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_node_role from the @json message, and
 * store it into @node_role.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_node_role_read_json(iodefv2_node_role_t *node_role, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ node_role idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "category") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_node_role_category_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_node_role_set_category(node_role, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_category") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_node_role_new_ext_category(node_role, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_node_role_new_description(node_role, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading node_role", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_nameservers_read:
 * @nameservers: Pointer to a #iodefv2_nameservers_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_nameservers from the @json message, and
 * store it into @nameservers.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_nameservers_read_json(iodefv2_nameservers_t *nameservers, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ nameservers idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "server") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_nameservers_new_server(nameservers, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "address") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_address_t *address;

                                                ret = iodefv2_nameservers_new_address(nameservers, &address, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_address_read_json(address, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading nameservers", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_alternative_indicator_id_read:
 * @alternative_indicator_id: Pointer to a #iodefv2_alternative_indicator_id_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_alternative_indicator_id from the @json message, and
 * store it into @alternative_indicator_id.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_alternative_indicator_id_read_json(iodefv2_alternative_indicator_id_t *alternative_indicator_id, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ alternative_indicator_id idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_alternative_indicator_id_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_alternative_indicator_id_set_restriction(alternative_indicator_id, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_alternative_indicator_id_new_ext_restriction(alternative_indicator_id, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "indicator_reference") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_alternative_indicator_id_new_indicator_reference(alternative_indicator_id, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading alternative_indicator_id", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_confidence_read:
 * @confidence: Pointer to a #iodefv2_confidence_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_confidence from the @json message, and
 * store it into @confidence.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_confidence_read_json(iodefv2_confidence_t *confidence, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ confidence idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "rating") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_confidence_rating_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_confidence_set_rating(confidence, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_rating") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_confidence_new_ext_rating(confidence, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading confidence", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_system_impact_read:
 * @system_impact: Pointer to a #iodefv2_system_impact_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_system_impact from the @json message, and
 * store it into @system_impact.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_system_impact_read_json(iodefv2_system_impact_t *system_impact, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ system_impact idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "completion") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_system_impact_completion_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_system_impact_set_completion(system_impact, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_system_impact_type_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_system_impact_set_type(system_impact, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "severity") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_system_impact_severity_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_system_impact_set_severity(system_impact, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_system_impact_new_ext_type(system_impact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_system_impact_new_description(system_impact, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading system_impact", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_discovery_read:
 * @discovery: Pointer to a #iodefv2_discovery_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_discovery from the @json message, and
 * store it into @discovery.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_discovery_read_json(iodefv2_discovery_t *discovery, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ discovery idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "source") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_discovery_source_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_discovery_set_source(discovery, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_discovery_new_ext_restriction(discovery, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_discovery_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_discovery_set_restriction(discovery, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_discovery_new_observable_id(discovery, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_source") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_discovery_new_ext_source(discovery, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "detection_pattern") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_detection_pattern_t *detection_pattern;

                                                ret = iodefv2_discovery_new_detection_pattern(discovery, &detection_pattern, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_detection_pattern_read_json(detection_pattern, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_contact_t *contact;

                                                ret = iodefv2_discovery_new_contact(discovery, &contact, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_contact_read_json(contact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_discovery_new_description(discovery, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading discovery", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_monetary_impact_read:
 * @monetary_impact: Pointer to a #iodefv2_monetary_impact_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_monetary_impact from the @json message, and
 * store it into @monetary_impact.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_monetary_impact_read_json(iodefv2_monetary_impact_t *monetary_impact, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ monetary_impact idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "currency") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_monetary_impact_new_currency(monetary_impact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "severity") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_monetary_impact_severity_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_monetary_impact_set_severity(monetary_impact, ret);
                } 

                
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading monetary_impact", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_business_impact_read:
 * @business_impact: Pointer to a #iodefv2_business_impact_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_business_impact from the @json message, and
 * store it into @business_impact.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_business_impact_read_json(iodefv2_business_impact_t *business_impact, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ business_impact idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_severity") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_business_impact_new_ext_severity(business_impact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_business_impact_type_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_business_impact_set_type(business_impact, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "severity") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_business_impact_severity_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_business_impact_set_severity(business_impact, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_business_impact_new_ext_type(business_impact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_business_impact_new_description(business_impact, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading business_impact", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_indicator_reference_read:
 * @indicator_reference: Pointer to a #iodefv2_indicator_reference_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_indicator_reference from the @json message, and
 * store it into @indicator_reference.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_indicator_reference_read_json(iodefv2_indicator_reference_t *indicator_reference, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ indicator_reference idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "uid_ref") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_indicator_reference_new_uid_ref(indicator_reference, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "version") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_indicator_reference_new_version(indicator_reference, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "euid_ref") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_indicator_reference_new_euid_ref(indicator_reference, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading indicator_reference", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_email_read:
 * @email: Pointer to a #iodefv2_email_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_email from the @json message, and
 * store it into @email.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_email_read_json(iodefv2_email_t *email, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ email idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "type") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_email_type_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_email_set_type(email, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_email_new_ext_type(email, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "email_to") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_email_new_email_to(email, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_email_new_description(email, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading email", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_incident_id_read:
 * @incident_id: Pointer to a #iodefv2_incident_id_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_incident_id from the @json message, and
 * store it into @incident_id.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_incident_id_read_json(iodefv2_incident_id_t *incident_id, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ incident_id idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "instance") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_incident_id_new_instance(incident_id, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_incident_id_new_ext_restriction(incident_id, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "name") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_incident_id_new_name(incident_id, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_incident_id_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_incident_id_set_restriction(incident_id, ret);
                } 

                
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading incident_id", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_counter_read:
 * @counter: Pointer to a #iodefv2_counter_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_counter from the @json message, and
 * store it into @counter.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_counter_read_json(iodefv2_counter_t *counter, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ counter idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_unit") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_counter_new_ext_unit(counter, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "meaning") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_counter_new_meaning(counter, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_duration") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_counter_new_ext_duration(counter, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_counter_new_ext_type(counter, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "duration") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_counter_duration_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_counter_set_duration(counter, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_counter_type_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_counter_set_type(counter, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "unit") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_counter_unit_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_counter_set_unit(counter, ret);
                } 

                
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading counter", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_software_reference_read:
 * @software_reference: Pointer to a #iodefv2_software_reference_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_software_reference from the @json message, and
 * store it into @software_reference.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_software_reference_read_json(iodefv2_software_reference_t *software_reference, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ software_reference idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "dtype") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_software_reference_dtype_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_software_reference_set_dtype(software_reference, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_spec_name") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_software_reference_new_ext_spec_name(software_reference, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_dtype") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_software_reference_new_ext_dtype(software_reference, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading software_reference", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_service_name_read:
 * @service_name: Pointer to a #iodefv2_service_name_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_service_name from the @json message, and
 * store it into @service_name.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_service_name_read_json(iodefv2_service_name_t *service_name, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ service_name idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "url") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_service_name_new_url(service_name, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "iana_service") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_service_name_new_iana_service(service_name, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_service_name_new_description(service_name, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading service_name", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_intended_impact_read:
 * @intended_impact: Pointer to a #iodefv2_intended_impact_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_intended_impact from the @json message, and
 * store it into @intended_impact.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_intended_impact_read_json(iodefv2_intended_impact_t *intended_impact, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ intended_impact idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_severity") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_intended_impact_new_ext_severity(intended_impact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_intended_impact_type_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_intended_impact_set_type(intended_impact, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "severity") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_intended_impact_severity_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_intended_impact_set_severity(intended_impact, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_intended_impact_new_ext_type(intended_impact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_intended_impact_new_description(intended_impact, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading intended_impact", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_indicator_id_read:
 * @indicator_id: Pointer to a #iodefv2_indicator_id_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_indicator_id from the @json message, and
 * store it into @indicator_id.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_indicator_id_read_json(iodefv2_indicator_id_t *indicator_id, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ indicator_id idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "version") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_indicator_id_new_version(indicator_id, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "name") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_indicator_id_new_name(indicator_id, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading indicator_id", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_signature_data_read:
 * @signature_data: Pointer to a #iodefv2_signature_data_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_signature_data from the @json message, and
 * store it into @signature_data.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_signature_data_read_json(iodefv2_signature_data_t *signature_data, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ signature_data idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "signature") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_signature_data_new_signature(signature_data, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading signature_data", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_address_read:
 * @address: Pointer to a #iodefv2_address_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_address from the @json message, and
 * store it into @address.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_address_read_json(iodefv2_address_t *address, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ address idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "category") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_address_category_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_address_set_category(address, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "vlan_name") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_address_new_vlan_name(address, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_category") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_address_new_ext_category(address, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "vlan_num") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_address_new_vlan_num(address, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_address_new_observable_id(address, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading address", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_expectation_read:
 * @expectation: Pointer to a #iodefv2_expectation_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_expectation from the @json message, and
 * store it into @expectation.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_expectation_read_json(iodefv2_expectation_t *expectation, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ expectation idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_expectation_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_expectation_set_restriction(expectation, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_action") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_expectation_new_ext_action(expectation, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "severity") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_expectation_severity_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_expectation_set_severity(expectation, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_expectation_new_ext_restriction(expectation, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "action") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_expectation_action_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_expectation_set_action(expectation, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_severity") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_expectation_new_ext_severity(expectation, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "end_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_expectation_set_end_time(expectation, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "defined_coa") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_expectation_new_defined_coa(expectation, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_expectation_new_description(expectation, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "start_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_expectation_set_start_time(expectation, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_contact_t *contact;

                        ret = iodefv2_expectation_new_contact(expectation, &contact);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_contact_read_json(contact, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading expectation", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_application_header_read:
 * @application_header: Pointer to a #iodefv2_application_header_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_application_header from the @json message, and
 * store it into @application_header.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_application_header_read_json(iodefv2_application_header_t *application_header, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ application_header idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "application_header_field") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_application_header_field_t *application_header_field;

                                                ret = iodefv2_application_header_new_application_header_field(application_header, &application_header_field, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_application_header_field_read_json(application_header_field, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading application_header", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_certificate_data_read:
 * @certificate_data: Pointer to a #iodefv2_certificate_data_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_certificate_data from the @json message, and
 * store it into @certificate_data.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_certificate_data_read_json(iodefv2_certificate_data_t *certificate_data, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ certificate_data idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_certificate_data_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_certificate_data_set_restriction(certificate_data, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_certificate_data_new_ext_restriction(certificate_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_certificate_data_new_observable_id(certificate_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "certificate") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_certificate_t *certificate;

                                                ret = iodefv2_certificate_data_new_certificate(certificate_data, &certificate, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_certificate_read_json(certificate, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading certificate_data", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_history_item_read:
 * @history_item: Pointer to a #iodefv2_history_item_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_history_item from the @json message, and
 * store it into @history_item.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_history_item_read_json(iodefv2_history_item_t *history_item, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ history_item idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "action") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_history_item_action_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_history_item_set_action(history_item, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_history_item_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_history_item_set_restriction(history_item, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_action") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_history_item_new_ext_action(history_item, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_history_item_new_ext_restriction(history_item, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_history_item_new_observable_id(history_item, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_history_item_new_additional_data(history_item, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "defined_coa") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_history_item_new_defined_coa(history_item, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_history_item_new_description(history_item, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "date_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_history_item_set_date_time(history_item, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_contact_t *contact;

                        ret = iodefv2_history_item_new_contact(history_item, &contact);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_contact_read_json(contact, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "incident_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_incident_id_t *incident_id;

                        ret = iodefv2_history_item_new_incident_id(history_item, &incident_id);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_incident_id_read_json(incident_id, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading history_item", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_method_read:
 * @method: Pointer to a #iodefv2_method_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_method from the @json message, and
 * store it into @method.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_method_read_json(iodefv2_method_t *method, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ method idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_method_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_method_set_restriction(method, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_method_new_ext_restriction(method, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_method_new_additional_data(method, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_method_new_description(method, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "reference") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_reference_t *reference;

                                                ret = iodefv2_method_new_reference(method, &reference, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_reference_read_json(reference, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading method", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_alternative_id_read:
 * @alternative_id: Pointer to a #iodefv2_alternative_id_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_alternative_id from the @json message, and
 * store it into @alternative_id.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_alternative_id_read_json(iodefv2_alternative_id_t *alternative_id, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ alternative_id idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_alternative_id_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_alternative_id_set_restriction(alternative_id, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_alternative_id_new_ext_restriction(alternative_id, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "incident_id") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_incident_id_t *incident_id;

                                                ret = iodefv2_alternative_id_new_incident_id(alternative_id, &incident_id, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_incident_id_read_json(incident_id, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading alternative_id", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_software_read:
 * @software: Pointer to a #iodefv2_software_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_software from the @json message, and
 * store it into @software.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_software_read_json(iodefv2_software_t *software, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ software idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "url") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_software_new_url(software, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_software_new_description(software, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "software_reference") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_software_reference_t *software_reference;

                        ret = iodefv2_software_new_software_reference(software, &software_reference);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_software_reference_read_json(software_reference, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading software", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_windows_registry_keys_modified_read:
 * @windows_registry_keys_modified: Pointer to a #iodefv2_windows_registry_keys_modified_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_windows_registry_keys_modified from the @json message, and
 * store it into @windows_registry_keys_modified.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_windows_registry_keys_modified_read_json(iodefv2_windows_registry_keys_modified_t *windows_registry_keys_modified, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ windows_registry_keys_modified idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_windows_registry_keys_modified_new_observable_id(windows_registry_keys_modified, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "key") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_key_t *key;

                                                ret = iodefv2_windows_registry_keys_modified_new_key(windows_registry_keys_modified, &key, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_key_read_json(key, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading windows_registry_keys_modified", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_campaign_read:
 * @campaign: Pointer to a #iodefv2_campaign_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_campaign from the @json message, and
 * store it into @campaign.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_campaign_read_json(iodefv2_campaign_t *campaign, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ campaign idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_campaign_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_campaign_set_restriction(campaign, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_campaign_new_ext_restriction(campaign, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "url") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_campaign_new_url(campaign, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_campaign_new_additional_data(campaign, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_campaign_new_description(campaign, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "campaign_id") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_campaign_new_campaign_id(campaign, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading campaign", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_domain_data_read:
 * @domain_data: Pointer to a #iodefv2_domain_data_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_domain_data from the @json message, and
 * store it into @domain_data.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_domain_data_read_json(iodefv2_domain_data_t *domain_data, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ domain_data idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_domain_status") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_domain_data_new_ext_domain_status(domain_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "domain_status") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_domain_data_domain_status_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_domain_data_set_domain_status(domain_data, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_system_status") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_domain_data_new_ext_system_status(domain_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_domain_data_new_observable_id(domain_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "system_status") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_domain_data_system_status_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_domain_data_set_system_status(domain_data, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "related_dns") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_related_dns_t *related_dns;

                                                ret = iodefv2_domain_data_new_related_dns(domain_data, &related_dns, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_related_dns_read_json(related_dns, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "name") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_domain_data_new_name(domain_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "nameservers") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_nameservers_t *nameservers;

                                                ret = iodefv2_domain_data_new_nameservers(domain_data, &nameservers, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_nameservers_read_json(nameservers, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "domain_contacts") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_domain_contacts_t *domain_contacts;

                        ret = iodefv2_domain_data_new_domain_contacts(domain_data, &domain_contacts);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_domain_contacts_read_json(domain_contacts, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "date_domain_was_checked") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_domain_data_set_date_domain_was_checked(domain_data, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "expiration_date") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_domain_data_set_expiration_date(domain_data, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "registration_date") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_domain_data_set_registration_date(domain_data, time);
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading domain_data", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_attack_phase_read:
 * @attack_phase: Pointer to a #iodefv2_attack_phase_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_attack_phase from the @json message, and
 * store it into @attack_phase.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_attack_phase_read_json(iodefv2_attack_phase_t *attack_phase, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ attack_phase idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "url") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_attack_phase_new_url(attack_phase, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_attack_phase_new_additional_data(attack_phase, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_attack_phase_new_description(attack_phase, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "attack_phase_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_attack_phase_new_attack_phase_id(attack_phase, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading attack_phase", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_contact_read:
 * @contact: Pointer to a #iodefv2_contact_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_contact from the @json message, and
 * store it into @contact.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_contact_read_json(iodefv2_contact_t *contact, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ contact idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_contact_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_contact_set_restriction(contact, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_contact_new_ext_type(contact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_contact_new_ext_restriction(contact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "role") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_contact_role_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_contact_set_role(contact, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_role") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_contact_new_ext_role(contact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_contact_type_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_contact_set_type(contact, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_contact_new_additional_data(contact, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact_title") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_contact_new_contact_title(contact, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_contact_new_description(contact, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "telephone") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_telephone_t *telephone;

                                                ret = iodefv2_contact_new_telephone(contact, &telephone, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_telephone_read_json(telephone, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "registry_handle") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_registry_handle_t *registry_handle;

                                                ret = iodefv2_contact_new_registry_handle(contact, &registry_handle, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_registry_handle_read_json(registry_handle, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_contact_t *contact;

                                                ret = iodefv2_contact_new_contact(contact, &contact, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_contact_read_json(contact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact_name") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_contact_new_contact_name(contact, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "timezone") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_contact_new_timezone(contact, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "postal_address") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_postal_address_t *postal_address;

                                                ret = iodefv2_contact_new_postal_address(contact, &postal_address, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_postal_address_read_json(postal_address, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "email") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_email_t *email;

                                                ret = iodefv2_contact_new_email(contact, &email, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_email_read_json(email, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading contact", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_assessment_read:
 * @assessment: Pointer to a #iodefv2_assessment_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_assessment from the @json message, and
 * store it into @assessment.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_assessment_read_json(iodefv2_assessment_t *assessment, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ assessment idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_assessment_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_assessment_set_restriction(assessment, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_assessment_new_ext_restriction(assessment, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "occurrence") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_assessment_occurrence_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_assessment_set_occurrence(assessment, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_assessment_new_observable_id(assessment, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "intended_impact") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_intended_impact_t *intended_impact;

                                                ret = iodefv2_assessment_new_intended_impact(assessment, &intended_impact, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_intended_impact_read_json(intended_impact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "confidence") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_confidence_t *confidence;

                        ret = iodefv2_assessment_new_confidence(assessment, &confidence);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_confidence_read_json(confidence, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "time_impact") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_time_impact_t *time_impact;

                                                ret = iodefv2_assessment_new_time_impact(assessment, &time_impact, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_time_impact_read_json(time_impact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_assessment_new_additional_data(assessment, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "monetary_impact") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_monetary_impact_t *monetary_impact;

                                                ret = iodefv2_assessment_new_monetary_impact(assessment, &monetary_impact, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_monetary_impact_read_json(monetary_impact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "counter") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_counter_t *counter;

                                                ret = iodefv2_assessment_new_counter(assessment, &counter, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_counter_read_json(counter, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "system_impact") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_system_impact_t *system_impact;

                                                ret = iodefv2_assessment_new_system_impact(assessment, &system_impact, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_system_impact_read_json(system_impact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "business_impact") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_business_impact_t *business_impact;

                                                ret = iodefv2_assessment_new_business_impact(assessment, &business_impact, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_business_impact_read_json(business_impact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "incident_category") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_assessment_new_incident_category(assessment, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "mitigating_factor") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_assessment_new_mitigating_factor(assessment, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "cause") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_assessment_new_cause(assessment, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading assessment", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_threat_actor_read:
 * @threat_actor: Pointer to a #iodefv2_threat_actor_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_threat_actor from the @json message, and
 * store it into @threat_actor.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_threat_actor_read_json(iodefv2_threat_actor_t *threat_actor, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ threat_actor idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_threat_actor_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_threat_actor_set_restriction(threat_actor, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_threat_actor_new_ext_restriction(threat_actor, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "url") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_threat_actor_new_url(threat_actor, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "threat_actor_id") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_threat_actor_new_threat_actor_id(threat_actor, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_threat_actor_new_description(threat_actor, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_threat_actor_new_additional_data(threat_actor, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading threat_actor", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_related_activity_read:
 * @related_activity: Pointer to a #iodefv2_related_activity_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_related_activity from the @json message, and
 * store it into @related_activity.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_related_activity_read_json(iodefv2_related_activity_t *related_activity, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ related_activity idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_related_activity_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_related_activity_set_restriction(related_activity, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_related_activity_new_ext_restriction(related_activity, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_related_activity_new_additional_data(related_activity, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "confidence") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_confidence_t *confidence;

                        ret = iodefv2_related_activity_new_confidence(related_activity, &confidence);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_confidence_read_json(confidence, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_related_activity_new_description(related_activity, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "campaign") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_campaign_t *campaign;

                                                ret = iodefv2_related_activity_new_campaign(related_activity, &campaign, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_campaign_read_json(campaign, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "url") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_related_activity_new_url(related_activity, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "threat_actor") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_threat_actor_t *threat_actor;

                                                ret = iodefv2_related_activity_new_threat_actor(related_activity, &threat_actor, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_threat_actor_read_json(threat_actor, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "indicator_id") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_indicator_id_t *indicator_id;

                                                ret = iodefv2_related_activity_new_indicator_id(related_activity, &indicator_id, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_indicator_id_read_json(indicator_id, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "incident_id") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_incident_id_t *incident_id;

                                                ret = iodefv2_related_activity_new_incident_id(related_activity, &incident_id, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_incident_id_read_json(incident_id, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading related_activity", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_node_read:
 * @node: Pointer to a #iodefv2_node_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_node from the @json message, and
 * store it into @node.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_node_read_json(iodefv2_node_t *node, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ node idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "postal_address") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_node_new_postal_address(node, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "counter") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_counter_t *counter;

                                                ret = iodefv2_node_new_counter(node, &counter, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_counter_read_json(counter, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "location") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_node_new_location(node, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "domain_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_domain_data_t *domain_data;

                                                ret = iodefv2_node_new_domain_data(node, &domain_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_domain_data_read_json(domain_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "address") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_address_t *address;

                                                ret = iodefv2_node_new_address(node, &address, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_address_read_json(address, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading node", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_history_read:
 * @history: Pointer to a #iodefv2_history_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_history from the @json message, and
 * store it into @history.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_history_read_json(iodefv2_history_t *history, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ history idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_history_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_history_set_restriction(history, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "history_item") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_history_item_t *history_item;

                                                ret = iodefv2_history_new_history_item(history, &history_item, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_history_item_read_json(history_item, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading history", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_hash_read:
 * @hash: Pointer to a #iodefv2_hash_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_hash from the @json message, and
 * store it into @hash.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_hash_read_json(iodefv2_hash_t *hash, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ hash idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "digest_value") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_hash_new_digest_value(hash, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "application") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_application_t *application;

                        ret = iodefv2_hash_new_application(hash, &application);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_application_read_json(application, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "canonicalization_method") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_hash_new_canonicalization_method(hash, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "digest_method") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_hash_new_digest_method(hash, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading hash", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_detection_pattern_read:
 * @detection_pattern: Pointer to a #iodefv2_detection_pattern_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_detection_pattern from the @json message, and
 * store it into @detection_pattern.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_detection_pattern_read_json(iodefv2_detection_pattern_t *detection_pattern, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ detection_pattern idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_detection_pattern_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_detection_pattern_set_restriction(detection_pattern, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_detection_pattern_new_ext_restriction(detection_pattern, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_detection_pattern_new_observable_id(detection_pattern, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "application") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_application_t *application;

                        ret = iodefv2_detection_pattern_new_application(detection_pattern, &application);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_application_read_json(application, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "detection_pattern") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_detection_pattern_t *detection_pattern;

                                                ret = iodefv2_detection_pattern_new_detection_pattern(detection_pattern, &detection_pattern, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_detection_pattern_read_json(detection_pattern, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_detection_pattern_new_description(detection_pattern, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "detection_configuration") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_detection_pattern_new_detection_configuration(detection_pattern, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading detection_pattern", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_fuzzy_hash_read:
 * @fuzzy_hash: Pointer to a #iodefv2_fuzzy_hash_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_fuzzy_hash from the @json message, and
 * store it into @fuzzy_hash.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_fuzzy_hash_read_json(iodefv2_fuzzy_hash_t *fuzzy_hash, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ fuzzy_hash idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_fuzzy_hash_new_additional_data(fuzzy_hash, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "fuzzy_hash_value") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_fuzzy_hash_value_t *fuzzy_hash_value;

                                                ret = iodefv2_fuzzy_hash_new_fuzzy_hash_value(fuzzy_hash, &fuzzy_hash_value, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_fuzzy_hash_value_read_json(fuzzy_hash_value, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "application") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_application_t *application;

                        ret = iodefv2_fuzzy_hash_new_application(fuzzy_hash, &application);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_application_read_json(application, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading fuzzy_hash", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_hash_data_read:
 * @hash_data: Pointer to a #iodefv2_hash_data_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_hash_data from the @json message, and
 * store it into @hash_data.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_hash_data_read_json(iodefv2_hash_data_t *hash_data, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ hash_data idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "scope") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_hash_data_scope_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_hash_data_set_scope(hash_data, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_scope") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_hash_data_new_ext_scope(hash_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "hash_target_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_hash_data_new_hash_target_id(hash_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "hash") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_hash_t *hash;

                        ret = iodefv2_hash_data_new_hash(hash_data, &hash);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_hash_read_json(hash, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "fuzzy_hash") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_fuzzy_hash_t *fuzzy_hash;

                        ret = iodefv2_hash_data_new_fuzzy_hash(hash_data, &fuzzy_hash);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_fuzzy_hash_read_json(fuzzy_hash, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading hash_data", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_bulk_observable_format_read:
 * @bulk_observable_format: Pointer to a #iodefv2_bulk_observable_format_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_bulk_observable_format from the @json message, and
 * store it into @bulk_observable_format.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_bulk_observable_format_read_json(iodefv2_bulk_observable_format_t *bulk_observable_format, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ bulk_observable_format idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_bulk_observable_format_new_additional_data(bulk_observable_format, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "hash") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_hash_t *hash;

                        ret = iodefv2_bulk_observable_format_new_hash(bulk_observable_format, &hash);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_hash_read_json(hash, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading bulk_observable_format", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_bulk_observable_read:
 * @bulk_observable: Pointer to a #iodefv2_bulk_observable_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_bulk_observable from the @json message, and
 * store it into @bulk_observable.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_bulk_observable_read_json(iodefv2_bulk_observable_t *bulk_observable, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ bulk_observable idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "type") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_bulk_observable_type_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_bulk_observable_set_type(bulk_observable, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_type") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_bulk_observable_new_ext_type(bulk_observable, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "bulk_observable_list") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_bulk_observable_new_bulk_observable_list(bulk_observable, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "bulk_observable_format") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_bulk_observable_format_t *bulk_observable_format;

                        ret = iodefv2_bulk_observable_new_bulk_observable_format(bulk_observable, &bulk_observable_format);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_bulk_observable_format_read_json(bulk_observable_format, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_bulk_observable_new_additional_data(bulk_observable, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading bulk_observable", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_email_data_read:
 * @email_data: Pointer to a #iodefv2_email_data_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_email_data from the @json message, and
 * store it into @email_data.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_email_data_read_json(iodefv2_email_data_t *email_data, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ email_data idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_email_data_new_observable_id(email_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "hash_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_hash_data_t *hash_data;

                                                ret = iodefv2_email_data_new_hash_data(email_data, &hash_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_hash_data_read_json(hash_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "email_headers") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_email_data_new_email_headers(email_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "signature_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_signature_data_t *signature_data;

                                                ret = iodefv2_email_data_new_signature_data(email_data, &signature_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_signature_data_read_json(signature_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "email_to") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_email_data_new_email_to(email_data, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "email_x_mailer") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_email_data_new_email_x_mailer(email_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "email_from") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_email_data_new_email_from(email_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "application_header") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_application_header_t *application_header;

                        ret = iodefv2_email_data_new_application_header(email_data, &application_header);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_application_header_read_json(application_header, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "email_header_field") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_email_header_field_t *email_header_field;

                                                ret = iodefv2_email_data_new_email_header_field(email_data, &email_header_field, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_email_header_field_read_json(email_header_field, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "email_message") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_email_data_new_email_message(email_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "email_subject") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_email_data_new_email_subject(email_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "email_body") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_email_data_new_email_body(email_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading email_data", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_file_read:
 * @file: Pointer to a #iodefv2_file_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_file from the @json message, and
 * store it into @file.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_file_read_json(iodefv2_file_t *file, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ file idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_file_new_observable_id(file, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "associated_software") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_associated_software_t *associated_software;

                        ret = iodefv2_file_new_associated_software(file, &associated_software);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_associated_software_read_json(associated_software, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "url") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_file_new_url(file, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "file_name") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_file_new_file_name(file, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "hash_data") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_hash_data_t *hash_data;

                        ret = iodefv2_file_new_hash_data(file, &hash_data);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_hash_data_read_json(hash_data, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "signature_data") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_signature_data_t *signature_data;

                        ret = iodefv2_file_new_signature_data(file, &signature_data);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_signature_data_read_json(signature_data, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "file_properties") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_file_properties_t *file_properties;

                                                ret = iodefv2_file_new_file_properties(file, &file_properties, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_file_properties_read_json(file_properties, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading file", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_service_read:
 * @service: Pointer to a #iodefv2_service_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_service from the @json message, and
 * store it into @service.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_service_read_json(iodefv2_service_t *service, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ service idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ip_protocol") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_service_new_ip_protocol(service, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_service_new_observable_id(service, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "proto_code") == 0 ) {
                        ctrl->idx++;



                    {
                        int64_t ret;

                        ret = __get_integer(ctrl);
                        if ( ret < 0 )
                                return ret;

                        iodefv2_service_set_proto_code(service, ret);
                    }
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "portlist") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_service_new_portlist(service, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "proto_field") == 0 ) {
                        ctrl->idx++;



                    {
                        int64_t ret;

                        ret = __get_integer(ctrl);
                        if ( ret < 0 )
                                return ret;

                        iodefv2_service_set_proto_field(service, ret);
                    }
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "application") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_application_t *application;

                                                ret = iodefv2_service_new_application(service, &application, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_application_read_json(application, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "service_name") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_service_name_t *service_name;

                        ret = iodefv2_service_new_service_name(service, &service_name);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_service_name_read_json(service_name, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "application_header") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_application_header_t *application_header;

                        ret = iodefv2_service_new_application_header(service, &application_header);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_application_header_read_json(application_header, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "email_data") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_email_data_t *email_data;

                        ret = iodefv2_service_new_email_data(service, &email_data);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_email_data_read_json(email_data, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "proto_type") == 0 ) {
                        ctrl->idx++;



                    {
                        int64_t ret;

                        ret = __get_integer(ctrl);
                        if ( ret < 0 )
                                return ret;

                        iodefv2_service_set_proto_type(service, ret);
                    }
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "port") == 0 ) {
                        ctrl->idx++;



                    {
                        int64_t ret;

                        ret = __get_integer(ctrl);
                        if ( ret < 0 )
                                return ret;

                        iodefv2_service_set_port(service, ret);
                    }
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading service", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_file_data_read:
 * @file_data: Pointer to a #iodefv2_file_data_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_file_data from the @json message, and
 * store it into @file_data.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_file_data_read_json(iodefv2_file_data_t *file_data, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ file_data idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_file_data_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_file_data_set_restriction(file_data, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_file_data_new_ext_restriction(file_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_file_data_new_observable_id(file_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "file") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_file_t *file;

                                                ret = iodefv2_file_data_new_file(file_data, &file, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_file_read_json(file, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading file_data", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_system_read:
 * @system: Pointer to a #iodefv2_system_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_system from the @json message, and
 * store it into @system.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_system_read_json(iodefv2_system_t *system, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ system idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "category") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_system_category_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_system_set_category(system, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_system_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_system_set_restriction(system, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "spoofed") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_system_spoofed_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_system_set_spoofed(system, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_ownership") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_system_new_ext_ownership(system, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_category") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_system_new_ext_category(system, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_system_new_ext_restriction(system, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "virtual") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_system_virtual_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_system_set_virtual(system, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_system_new_observable_id(system, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ownership") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_system_ownership_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_system_set_ownership(system, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "interface") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_system_new_interface(system, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "node") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_node_t *node;

                        ret = iodefv2_system_new_node(system, &node);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_node_read_json(node, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_system_new_additional_data(system, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_system_new_description(system, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "service") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_service_t *service;

                                                ret = iodefv2_system_new_service(system, &service, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_service_read_json(service, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "asset_id") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_system_new_asset_id(system, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "counter") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_counter_t *counter;

                                                ret = iodefv2_system_new_counter(system, &counter, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_counter_read_json(counter, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "node_role") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_node_role_t *node_role;

                                                ret = iodefv2_system_new_node_role(system, &node_role, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_node_role_read_json(node_role, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "operating_system") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_operating_system_t *operating_system;

                        ret = iodefv2_system_new_operating_system(system, &operating_system);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_operating_system_read_json(operating_system, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading system", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_record_data_read:
 * @record_data: Pointer to a #iodefv2_record_data_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_record_data from the @json message, and
 * store it into @record_data.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_record_data_read_json(iodefv2_record_data_t *record_data, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ record_data idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_record_data_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_record_data_set_restriction(record_data, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_record_data_new_ext_restriction(record_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_record_data_new_observable_id(record_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_record_data_new_additional_data(record_data, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_record_data_new_description(record_data, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "url") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_record_data_new_url(record_data, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "certificate_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_certificate_data_t *certificate_data;

                                                ret = iodefv2_record_data_new_certificate_data(record_data, &certificate_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_certificate_data_read_json(certificate_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "record_pattern") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_record_pattern_t *record_pattern;

                                                ret = iodefv2_record_data_new_record_pattern(record_data, &record_pattern, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_record_pattern_read_json(record_pattern, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "date_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_record_data_set_date_time(record_data, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "windows_registry_keys_modified") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_windows_registry_keys_modified_t *windows_registry_keys_modified;

                                                ret = iodefv2_record_data_new_windows_registry_keys_modified(record_data, &windows_registry_keys_modified, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_windows_registry_keys_modified_read_json(windows_registry_keys_modified, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "application") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_application_t *application;

                        ret = iodefv2_record_data_new_application(record_data, &application);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_application_read_json(application, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "record_item") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_record_item_t *record_item;

                                                ret = iodefv2_record_data_new_record_item(record_data, &record_item, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_record_item_read_json(record_item, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "file_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_file_data_t *file_data;

                                                ret = iodefv2_record_data_new_file_data(record_data, &file_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_file_data_read_json(file_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading record_data", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_observable_read:
 * @observable: Pointer to a #iodefv2_observable_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_observable from the @json message, and
 * store it into @observable.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_observable_read_json(iodefv2_observable_t *observable, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ observable idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_observable_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_observable_set_restriction(observable, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_observable_new_ext_restriction(observable, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "detection_pattern") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_detection_pattern_t *detection_pattern;

                        ret = iodefv2_observable_new_detection_pattern(observable, &detection_pattern);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_detection_pattern_read_json(detection_pattern, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "registry_handle") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_registry_handle_t *registry_handle;

                        ret = iodefv2_observable_new_registry_handle(observable, &registry_handle);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_registry_handle_read_json(registry_handle, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "reference") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_reference_t *reference;

                        ret = iodefv2_observable_new_reference(observable, &reference);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_reference_read_json(reference, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "service") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_service_t *service;

                        ret = iodefv2_observable_new_service(observable, &service);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_service_read_json(service, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_observable_new_additional_data(observable, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "bulk_observable") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_bulk_observable_t *bulk_observable;

                        ret = iodefv2_observable_new_bulk_observable(observable, &bulk_observable);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_bulk_observable_read_json(bulk_observable, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "certificate_data") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_certificate_data_t *certificate_data;

                        ret = iodefv2_observable_new_certificate_data(observable, &certificate_data);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_certificate_data_read_json(certificate_data, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "system") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_system_t *system;

                        ret = iodefv2_observable_new_system(observable, &system);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_system_read_json(system, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "history_item") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_history_item_t *history_item;

                        ret = iodefv2_observable_new_history_item(observable, &history_item);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_history_item_read_json(history_item, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "windows_registry_keys_modified") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_windows_registry_keys_modified_t *windows_registry_keys_modified;

                        ret = iodefv2_observable_new_windows_registry_keys_modified(observable, &windows_registry_keys_modified);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_windows_registry_keys_modified_read_json(windows_registry_keys_modified, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "expectation") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_expectation_t *expectation;

                        ret = iodefv2_observable_new_expectation(observable, &expectation);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_expectation_read_json(expectation, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "event_data") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_event_data_t *event_data;

                        ret = iodefv2_observable_new_event_data(observable, &event_data);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_event_data_read_json(event_data, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "domain_data") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_domain_data_t *domain_data;

                        ret = iodefv2_observable_new_domain_data(observable, &domain_data);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_domain_data_read_json(domain_data, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "address") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_address_t *address;

                        ret = iodefv2_observable_new_address(observable, &address);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_address_read_json(address, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "email_data") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_email_data_t *email_data;

                        ret = iodefv2_observable_new_email_data(observable, &email_data);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_email_data_read_json(email_data, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "file_data") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_file_data_t *file_data;

                        ret = iodefv2_observable_new_file_data(observable, &file_data);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_file_data_read_json(file_data, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "assessment") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_assessment_t *assessment;

                        ret = iodefv2_observable_new_assessment(observable, &assessment);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_assessment_read_json(assessment, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "record_data") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_record_data_t *record_data;

                        ret = iodefv2_observable_new_record_data(observable, &record_data);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_record_data_read_json(record_data, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading observable", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_flow_read:
 * @flow: Pointer to a #iodefv2_flow_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_flow from the @json message, and
 * store it into @flow.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_flow_read_json(iodefv2_flow_t *flow, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ flow idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "system") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_system_t *system;

                                                ret = iodefv2_flow_new_system(flow, &system, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_system_read_json(system, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading flow", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_record_read:
 * @record: Pointer to a #iodefv2_record_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_record from the @json message, and
 * store it into @record.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_record_read_json(iodefv2_record_t *record, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ record idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_record_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_record_set_restriction(record, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_record_new_ext_restriction(record, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "record_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_record_data_t *record_data;

                                                ret = iodefv2_record_new_record_data(record, &record_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_record_data_read_json(record_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading record", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_indicator_expression_read:
 * @indicator_expression: Pointer to a #iodefv2_indicator_expression_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_indicator_expression from the @json message, and
 * store it into @indicator_expression.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_indicator_expression_read_json(iodefv2_indicator_expression_t *indicator_expression, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ indicator_expression idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "operator") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_indicator_expression_operator_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_indicator_expression_set_operator(indicator_expression, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_operator") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_indicator_expression_new_ext_operator(indicator_expression, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "indicator_reference") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_indicator_reference_t *indicator_reference;

                                                ret = iodefv2_indicator_expression_new_indicator_reference(indicator_expression, &indicator_reference, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_indicator_reference_read_json(indicator_reference, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_observable_t *observable;

                                                ret = iodefv2_indicator_expression_new_observable(indicator_expression, &observable, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_observable_read_json(observable, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "confidence") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_confidence_t *confidence;

                        ret = iodefv2_indicator_expression_new_confidence(indicator_expression, &confidence);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_confidence_read_json(confidence, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "indicator_expression") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_indicator_expression_t *indicator_expression;

                                                ret = iodefv2_indicator_expression_new_indicator_expression(indicator_expression, &indicator_expression, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_indicator_expression_read_json(indicator_expression, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_indicator_expression_new_additional_data(indicator_expression, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading indicator_expression", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_event_data_read:
 * @event_data: Pointer to a #iodefv2_event_data_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_event_data from the @json message, and
 * store it into @event_data.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_event_data_read_json(iodefv2_event_data_t *event_data, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ event_data idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_event_data_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_event_data_set_restriction(event_data, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_event_data_new_ext_restriction(event_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_event_data_new_observable_id(event_data, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "detect_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_event_data_set_detect_time(event_data, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_event_data_new_additional_data(event_data, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "report_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_event_data_set_report_time(event_data, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_event_data_new_description(event_data, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "flow") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_flow_t *flow;

                                                ret = iodefv2_event_data_new_flow(event_data, &flow, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_flow_read_json(flow, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "expectation") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_expectation_t *expectation;

                                                ret = iodefv2_event_data_new_expectation(event_data, &expectation, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_expectation_read_json(expectation, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "record") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_record_t *record;

                        ret = iodefv2_event_data_new_record(event_data, &record);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_record_read_json(record, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_contact_t *contact;

                                                ret = iodefv2_event_data_new_contact(event_data, &contact, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_contact_read_json(contact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "start_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_event_data_set_start_time(event_data, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "event_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_event_data_t *event_data;

                                                ret = iodefv2_event_data_new_event_data(event_data, &event_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_event_data_read_json(event_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "end_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_event_data_set_end_time(event_data, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "assessment") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_assessment_t *assessment;

                        ret = iodefv2_event_data_new_assessment(event_data, &assessment);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_assessment_read_json(assessment, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "method") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_method_t *method;

                                                ret = iodefv2_event_data_new_method(event_data, &method, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_method_read_json(method, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "recovery_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_event_data_set_recovery_time(event_data, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "discovery") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_discovery_t *discovery;

                                                ret = iodefv2_event_data_new_discovery(event_data, &discovery, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_discovery_read_json(discovery, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading event_data", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_indicator_read:
 * @indicator: Pointer to a #iodefv2_indicator_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_indicator from the @json message, and
 * store it into @indicator.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_indicator_read_json(iodefv2_indicator_t *indicator, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ indicator idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_indicator_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_indicator_set_restriction(indicator, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_indicator_new_ext_restriction(indicator, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_indicator_new_additional_data(indicator, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "confidence") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_confidence_t *confidence;

                        ret = iodefv2_indicator_new_confidence(indicator, &confidence);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_confidence_read_json(confidence, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "start_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_indicator_set_start_time(indicator, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "reference") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_reference_t *reference;

                                                ret = iodefv2_indicator_new_reference(indicator, &reference, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_reference_read_json(reference, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "alternative_indicator_id") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_alternative_indicator_id_t *alternative_indicator_id;

                                                ret = iodefv2_indicator_new_alternative_indicator_id(indicator, &alternative_indicator_id, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_alternative_indicator_id_read_json(alternative_indicator_id, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "indicator_expression") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_indicator_expression_t *indicator_expression;

                        ret = iodefv2_indicator_new_indicator_expression(indicator, &indicator_expression);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_indicator_expression_read_json(indicator_expression, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_contact_t *contact;

                                                ret = iodefv2_indicator_new_contact(indicator, &contact, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_contact_read_json(contact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "node_role") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_node_role_t *node_role;

                                                ret = iodefv2_indicator_new_node_role(indicator, &node_role, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_node_role_read_json(node_role, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_observable_t *observable;

                        ret = iodefv2_indicator_new_observable(indicator, &observable);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_observable_read_json(observable, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "indicator_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_indicator_id_t *indicator_id;

                        ret = iodefv2_indicator_new_indicator_id(indicator, &indicator_id);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_indicator_id_read_json(indicator_id, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "indicator_reference") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_indicator_reference_t *indicator_reference;

                        ret = iodefv2_indicator_new_indicator_reference(indicator, &indicator_reference);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_indicator_reference_read_json(indicator_reference, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_reference") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_observable_reference_t *observable_reference;

                        ret = iodefv2_indicator_new_observable_reference(indicator, &observable_reference);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_observable_reference_read_json(observable_reference, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "attack_phase") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_attack_phase_t *attack_phase;

                                                ret = iodefv2_indicator_new_attack_phase(indicator, &attack_phase, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_attack_phase_read_json(attack_phase, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "end_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_indicator_set_end_time(indicator, time);
                } 

                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading indicator", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_indicator_data_read:
 * @indicator_data: Pointer to a #iodefv2_indicator_data_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_indicator_data from the @json message, and
 * store it into @indicator_data.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_indicator_data_read_json(iodefv2_indicator_data_t *indicator_data, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ indicator_data idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "indicator") == 0 ) {
                        ctrl->idx++;

                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_indicator_t *indicator;

                                                ret = iodefv2_indicator_data_new_indicator(indicator_data, &indicator, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_indicator_read_json(indicator, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading indicator_data", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_incident_read:
 * @incident: Pointer to a #iodefv2_incident_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_incident from the @json message, and
 * store it into @incident.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_incident_read_json(iodefv2_incident_t *incident, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ incident idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "status") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_incident_status_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_incident_set_status(incident, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "lang") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_incident_lang_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_incident_set_lang(incident, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_purpose") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_incident_new_ext_purpose(incident, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "restriction") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_incident_restriction_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_incident_set_restriction(incident, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "observable_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_incident_new_observable_id(incident, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "purpose") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_incident_purpose_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_incident_set_purpose(incident, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "ext_status") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_incident_new_ext_status(incident, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "detect_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_incident_set_detect_time(incident, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_incident_new_additional_data(incident, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "generation_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_incident_set_generation_time(incident, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "incident_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_incident_id_t *incident_id;

                        ret = iodefv2_incident_new_incident_id(incident, &incident_id);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_incident_id_read_json(incident_id, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "description") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                        int ret;
                                        libiodefv2_string_t *str;

                                        ret = iodefv2_incident_new_description(incident, &str, IODEFV2_LIST_APPEND);
                                        if ( ret < 0 )
                                                return ret;

                                        ret = __get_string(ctrl, str);
                                        if ( ret < 0 )
                                                return ret;
                                                            ctrl->idx += 1;
                    }

                                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "alternative_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_alternative_id_t *alternative_id;

                        ret = iodefv2_incident_new_alternative_id(incident, &alternative_id);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_alternative_id_read_json(alternative_id, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "discovery") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_discovery_t *discovery;

                                                ret = iodefv2_incident_new_discovery(incident, &discovery, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_discovery_read_json(discovery, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "report_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_incident_set_report_time(incident, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "indicator_data") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_indicator_data_t *indicator_data;

                        ret = iodefv2_incident_new_indicator_data(incident, &indicator_data);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_indicator_data_read_json(indicator_data, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "contact") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_contact_t *contact;

                                                ret = iodefv2_incident_new_contact(incident, &contact, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_contact_read_json(contact, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "start_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_incident_set_start_time(incident, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "event_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_event_data_t *event_data;

                                                ret = iodefv2_incident_new_event_data(incident, &event_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_event_data_read_json(event_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "related_activity") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_related_activity_t *related_activity;

                        ret = iodefv2_incident_new_related_activity(incident, &related_activity);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_related_activity_read_json(related_activity, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "end_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_incident_set_end_time(incident, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "assessment") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_assessment_t *assessment;

                                                ret = iodefv2_incident_new_assessment(incident, &assessment, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_assessment_read_json(assessment, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "method") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_method_t *method;

                                                ret = iodefv2_incident_new_method(incident, &method, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_method_read_json(method, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "recovery_time") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];
                        iodefv2_time_t *time;

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_time_new_from_string(&time, buf);
                        if (ret < 0)
                                return ret;

                        iodefv2_incident_set_recovery_time(incident, time);
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "history") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        iodefv2_history_t *history;

                        ret = iodefv2_incident_new_history(incident, &history);
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_history_read_json(history, ctrl);
                        if ( ret < 0 )
                                return ret;

                        ctrl->idx -= 1;

                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading incident", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

/**
 * iodefv2_document_read:
 * @document: Pointer to a #iodefv2_document_t object.
 * @json: Pointer to a #json_t object, containing a message.
 *
 * Read an iodefv2_document from the @json message, and
 * store it into @document.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
static int iodefv2_document_read_json(iodefv2_document_t *document, json_data_t *ctrl)
{
        unsigned int i = 0;
        size_t size = ctrl->jtok[ctrl->idx].size;
        //printf("READ document idx=%u rsize=%lu type=%d\n", ctrl->idx, size, ctrl->jtok[ctrl->idx].type);

        if ( ctrl->jtok[ctrl->idx].type != JSMN_OBJECT )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected JSON object type");

        for ( ctrl->idx += 1; i < size && ctrl->idx < ctrl->jtoksize; ctrl->idx++, i++ ) {
                //printf("MESSAGE READ %.*s type=%d idx=%d i=%u size=%lu\n", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start, ctrl->jtok[ctrl->idx+1].type, ctrl->idx, i, size);
                if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "_self") == 0 ) {
                        ctrl->idx++;
                        continue;
                }


                 if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "lang") == 0 ) {
                        ctrl->idx++;




                        int ret;
                        char buf[128];

                        ret = __get_string_copy(ctrl, ctrl->idx, buf, sizeof(buf));
                        if ( ret < 0 )
                                return ret;

                        ret = iodefv2_document_lang_to_numeric(buf);
                        if ( ret != -1 )
                                iodefv2_document_set_lang(document, ret);
                } 

                


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "formatid") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_document_new_formatid(document, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "version") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_document_new_version(document, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "private_enum_name") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_document_new_private_enum_name(document, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "private_enum_id") == 0 ) {
                        ctrl->idx++;



                        int ret;
                        libiodefv2_string_t *str;

                        ret = iodefv2_document_new_private_enum_id(document, &str);
                        if ( ret < 0 )
                                return ret;

                        ret = __get_string(ctrl, str);
                        if ( ret < 0 )
                                return ret;
                
                } 



                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "additional_data") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_additional_data_t *additional_data;

                                                ret = iodefv2_document_new_additional_data(document, &additional_data, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_additional_data_read_json(additional_data, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }


                else if ( jsoneq(ctrl, &ctrl->jtok[ctrl->idx], "incident") == 0 ) {
                        ctrl->idx++;
                        if ( ctrl->jtok[ctrl->idx].type == JSMN_ARRAY) {
                                size_t lsize = ctrl->jtok[ctrl->idx].size;

                                ctrl->idx += 1;
                                for ( unsigned int j = 0; j < lsize; j++ ) {



                                                int ret;
                                                iodefv2_incident_t *incident;

                                                ret = iodefv2_document_new_incident(document, &incident, IODEFV2_LIST_APPEND);
                                                if ( ret < 0 )
                                                        return ret;

                                                ret = iodefv2_incident_read_json(incident, ctrl);
                                                if ( ret < 0 )
                                                        return ret;
                                        }
                                ctrl->idx -= 1;

                        }
                }
                else {
                        return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unexpected field '%.*s' while reading document", ctrl->jtok[ctrl->idx].end - ctrl->jtok[ctrl->idx].start, ctrl->input + ctrl->jtok[ctrl->idx].start);
                }
        }

        return 0;
}

int iodefv2_object_new_from_json(iodefv2_object_t **object, const char *json_message)
{
        int ret, selfkey;
        jsmn_parser parser;
        json_data_t ctrl;

        jsmn_init(&parser);
        ctrl.idx = 0;
        ctrl.input = json_message;

        ret = ctrl.jtoksize = jsmn_parse(&parser, json_message, strlen(json_message), ctrl.jtok, sizeof(ctrl.jtok) / sizeof(*ctrl.jtok));
        if ( ret < 0 )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "error parsing json message");

        selfkey = __get_json_key(&ctrl, "_self", 0);
        if ( selfkey < 0 )
                return libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "json message miss '_self' attribute");

        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_telephone_t") == 0 ) {
                ret = iodefv2_telephone_new((iodefv2_telephone_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_telephone_read_json((iodefv2_telephone_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_certificate_t") == 0 ) {
                ret = iodefv2_certificate_new((iodefv2_certificate_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_certificate_read_json((iodefv2_certificate_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_key_t") == 0 ) {
                ret = iodefv2_key_new((iodefv2_key_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_key_read_json((iodefv2_key_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_observable_reference_t") == 0 ) {
                ret = iodefv2_observable_reference_new((iodefv2_observable_reference_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_observable_reference_read_json((iodefv2_observable_reference_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_domain_contacts_t") == 0 ) {
                ret = iodefv2_domain_contacts_new((iodefv2_domain_contacts_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_domain_contacts_read_json((iodefv2_domain_contacts_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_extension_t") == 0 ) {
                ret = iodefv2_extension_new((iodefv2_extension_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_extension_read_json((iodefv2_extension_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_registry_handle_t") == 0 ) {
                ret = iodefv2_registry_handle_new((iodefv2_registry_handle_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_registry_handle_read_json((iodefv2_registry_handle_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_time_impact_t") == 0 ) {
                ret = iodefv2_time_impact_new((iodefv2_time_impact_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_time_impact_read_json((iodefv2_time_impact_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_record_pattern_t") == 0 ) {
                ret = iodefv2_record_pattern_new((iodefv2_record_pattern_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_record_pattern_read_json((iodefv2_record_pattern_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_reference_t") == 0 ) {
                ret = iodefv2_reference_new((iodefv2_reference_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_reference_read_json((iodefv2_reference_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_postal_address_t") == 0 ) {
                ret = iodefv2_postal_address_new((iodefv2_postal_address_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_postal_address_read_json((iodefv2_postal_address_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_node_role_t") == 0 ) {
                ret = iodefv2_node_role_new((iodefv2_node_role_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_node_role_read_json((iodefv2_node_role_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_nameservers_t") == 0 ) {
                ret = iodefv2_nameservers_new((iodefv2_nameservers_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_nameservers_read_json((iodefv2_nameservers_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_alternative_indicator_id_t") == 0 ) {
                ret = iodefv2_alternative_indicator_id_new((iodefv2_alternative_indicator_id_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_alternative_indicator_id_read_json((iodefv2_alternative_indicator_id_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_confidence_t") == 0 ) {
                ret = iodefv2_confidence_new((iodefv2_confidence_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_confidence_read_json((iodefv2_confidence_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_system_impact_t") == 0 ) {
                ret = iodefv2_system_impact_new((iodefv2_system_impact_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_system_impact_read_json((iodefv2_system_impact_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_discovery_t") == 0 ) {
                ret = iodefv2_discovery_new((iodefv2_discovery_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_discovery_read_json((iodefv2_discovery_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_monetary_impact_t") == 0 ) {
                ret = iodefv2_monetary_impact_new((iodefv2_monetary_impact_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_monetary_impact_read_json((iodefv2_monetary_impact_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_business_impact_t") == 0 ) {
                ret = iodefv2_business_impact_new((iodefv2_business_impact_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_business_impact_read_json((iodefv2_business_impact_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_indicator_reference_t") == 0 ) {
                ret = iodefv2_indicator_reference_new((iodefv2_indicator_reference_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_indicator_reference_read_json((iodefv2_indicator_reference_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_email_t") == 0 ) {
                ret = iodefv2_email_new((iodefv2_email_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_email_read_json((iodefv2_email_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_incident_id_t") == 0 ) {
                ret = iodefv2_incident_id_new((iodefv2_incident_id_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_incident_id_read_json((iodefv2_incident_id_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_counter_t") == 0 ) {
                ret = iodefv2_counter_new((iodefv2_counter_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_counter_read_json((iodefv2_counter_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_software_reference_t") == 0 ) {
                ret = iodefv2_software_reference_new((iodefv2_software_reference_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_software_reference_read_json((iodefv2_software_reference_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_service_name_t") == 0 ) {
                ret = iodefv2_service_name_new((iodefv2_service_name_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_service_name_read_json((iodefv2_service_name_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_intended_impact_t") == 0 ) {
                ret = iodefv2_intended_impact_new((iodefv2_intended_impact_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_intended_impact_read_json((iodefv2_intended_impact_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_indicator_id_t") == 0 ) {
                ret = iodefv2_indicator_id_new((iodefv2_indicator_id_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_indicator_id_read_json((iodefv2_indicator_id_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_signature_data_t") == 0 ) {
                ret = iodefv2_signature_data_new((iodefv2_signature_data_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_signature_data_read_json((iodefv2_signature_data_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_address_t") == 0 ) {
                ret = iodefv2_address_new((iodefv2_address_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_address_read_json((iodefv2_address_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_expectation_t") == 0 ) {
                ret = iodefv2_expectation_new((iodefv2_expectation_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_expectation_read_json((iodefv2_expectation_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_application_header_t") == 0 ) {
                ret = iodefv2_application_header_new((iodefv2_application_header_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_application_header_read_json((iodefv2_application_header_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_certificate_data_t") == 0 ) {
                ret = iodefv2_certificate_data_new((iodefv2_certificate_data_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_certificate_data_read_json((iodefv2_certificate_data_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_history_item_t") == 0 ) {
                ret = iodefv2_history_item_new((iodefv2_history_item_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_history_item_read_json((iodefv2_history_item_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_method_t") == 0 ) {
                ret = iodefv2_method_new((iodefv2_method_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_method_read_json((iodefv2_method_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_alternative_id_t") == 0 ) {
                ret = iodefv2_alternative_id_new((iodefv2_alternative_id_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_alternative_id_read_json((iodefv2_alternative_id_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_software_t") == 0 ) {
                ret = iodefv2_software_new((iodefv2_software_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_software_read_json((iodefv2_software_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_windows_registry_keys_modified_t") == 0 ) {
                ret = iodefv2_windows_registry_keys_modified_new((iodefv2_windows_registry_keys_modified_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_windows_registry_keys_modified_read_json((iodefv2_windows_registry_keys_modified_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_campaign_t") == 0 ) {
                ret = iodefv2_campaign_new((iodefv2_campaign_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_campaign_read_json((iodefv2_campaign_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_domain_data_t") == 0 ) {
                ret = iodefv2_domain_data_new((iodefv2_domain_data_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_domain_data_read_json((iodefv2_domain_data_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_attack_phase_t") == 0 ) {
                ret = iodefv2_attack_phase_new((iodefv2_attack_phase_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_attack_phase_read_json((iodefv2_attack_phase_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_contact_t") == 0 ) {
                ret = iodefv2_contact_new((iodefv2_contact_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_contact_read_json((iodefv2_contact_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_assessment_t") == 0 ) {
                ret = iodefv2_assessment_new((iodefv2_assessment_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_assessment_read_json((iodefv2_assessment_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_threat_actor_t") == 0 ) {
                ret = iodefv2_threat_actor_new((iodefv2_threat_actor_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_threat_actor_read_json((iodefv2_threat_actor_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_related_activity_t") == 0 ) {
                ret = iodefv2_related_activity_new((iodefv2_related_activity_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_related_activity_read_json((iodefv2_related_activity_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_node_t") == 0 ) {
                ret = iodefv2_node_new((iodefv2_node_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_node_read_json((iodefv2_node_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_history_t") == 0 ) {
                ret = iodefv2_history_new((iodefv2_history_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_history_read_json((iodefv2_history_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_hash_t") == 0 ) {
                ret = iodefv2_hash_new((iodefv2_hash_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_hash_read_json((iodefv2_hash_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_detection_pattern_t") == 0 ) {
                ret = iodefv2_detection_pattern_new((iodefv2_detection_pattern_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_detection_pattern_read_json((iodefv2_detection_pattern_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_fuzzy_hash_t") == 0 ) {
                ret = iodefv2_fuzzy_hash_new((iodefv2_fuzzy_hash_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_fuzzy_hash_read_json((iodefv2_fuzzy_hash_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_hash_data_t") == 0 ) {
                ret = iodefv2_hash_data_new((iodefv2_hash_data_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_hash_data_read_json((iodefv2_hash_data_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_bulk_observable_format_t") == 0 ) {
                ret = iodefv2_bulk_observable_format_new((iodefv2_bulk_observable_format_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_bulk_observable_format_read_json((iodefv2_bulk_observable_format_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_bulk_observable_t") == 0 ) {
                ret = iodefv2_bulk_observable_new((iodefv2_bulk_observable_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_bulk_observable_read_json((iodefv2_bulk_observable_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_email_data_t") == 0 ) {
                ret = iodefv2_email_data_new((iodefv2_email_data_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_email_data_read_json((iodefv2_email_data_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_file_t") == 0 ) {
                ret = iodefv2_file_new((iodefv2_file_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_file_read_json((iodefv2_file_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_service_t") == 0 ) {
                ret = iodefv2_service_new((iodefv2_service_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_service_read_json((iodefv2_service_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_file_data_t") == 0 ) {
                ret = iodefv2_file_data_new((iodefv2_file_data_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_file_data_read_json((iodefv2_file_data_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_system_t") == 0 ) {
                ret = iodefv2_system_new((iodefv2_system_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_system_read_json((iodefv2_system_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_record_data_t") == 0 ) {
                ret = iodefv2_record_data_new((iodefv2_record_data_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_record_data_read_json((iodefv2_record_data_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_observable_t") == 0 ) {
                ret = iodefv2_observable_new((iodefv2_observable_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_observable_read_json((iodefv2_observable_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_flow_t") == 0 ) {
                ret = iodefv2_flow_new((iodefv2_flow_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_flow_read_json((iodefv2_flow_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_record_t") == 0 ) {
                ret = iodefv2_record_new((iodefv2_record_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_record_read_json((iodefv2_record_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_indicator_expression_t") == 0 ) {
                ret = iodefv2_indicator_expression_new((iodefv2_indicator_expression_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_indicator_expression_read_json((iodefv2_indicator_expression_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_event_data_t") == 0 ) {
                ret = iodefv2_event_data_new((iodefv2_event_data_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_event_data_read_json((iodefv2_event_data_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_indicator_t") == 0 ) {
                ret = iodefv2_indicator_new((iodefv2_indicator_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_indicator_read_json((iodefv2_indicator_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_indicator_data_t") == 0 ) {
                ret = iodefv2_indicator_data_new((iodefv2_indicator_data_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_indicator_data_read_json((iodefv2_indicator_data_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_incident_t") == 0 ) {
                ret = iodefv2_incident_new((iodefv2_incident_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_incident_read_json((iodefv2_incident_t *) *object, &ctrl);
        }
        else 
        if ( jsoneq(&ctrl, &ctrl.jtok[selfkey + 1], "iodefv2_document_t") == 0 ) {
                ret = iodefv2_document_new((iodefv2_document_t **) object);
                if ( ret < 0 )
                        return ret;

                ret = iodefv2_document_read_json((iodefv2_document_t *) *object, &ctrl);
        }
        else {
                ret = libiodefv2_error_verbose(LIBIODEFV2_ERROR_GENERIC, "unknown object type '%s'", "");
        }

        return ret;
}


