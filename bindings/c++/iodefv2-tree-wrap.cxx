
















/*****
*
* Based on iodefv2-tree-wrap.c.mako

* Author: Sebastien Tricaud <stricaud@inl.fr>
*
* This file is part of the Libiodefv2 library.
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along
* with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*
*****/

/*
 * This file was automatically generated by our generator, version 1
 *
 * Do not make changes to this file unless you know what you are doing.
 * modify the template interface file instead.
 * IODEFV2 version : RFC5070-bis-26
 * Template file: generate-tree-wrap.cxx.mako
 *
 */

#include "config.h"

#include "iodefv2-tree-wrap.hxx"
#include "common.h"


static std::string *to_string(libiodefv2_string_t *str)
{
        return new std::string(libiodefv2_string_get_string(str));
}


static libiodefv2_string_t *from_string(std::string *str)
{
        int ret;
        libiodefv2_string_t *pstr;

        ret = libiodefv2_string_new_dup_fast(&pstr, str->c_str(), str->length());
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        return pstr;
}

    

/**
 * iodefv2_telephone_new:
 * @ret: Pointer where to store the created #iodefv2_telephone_t object.
 *
 * Create a new #iodefv2_telephone_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2telephone::IODEFV2telephone()
{
        iodefv2_telephone_new(&_priv);
}


/**
 * iodefv2_telephone_destroy:
 * @ptr: pointer to a #iodefv2_telephone_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2telephone::~IODEFV2telephone()
{
        iodefv2_telephone_destroy(_priv);
}





iodefv2_telephone_type_t * IODEFV2telephone::get_type()
{
        return (iodefv2_telephone_get_type(_priv));
}

void IODEFV2telephone::set_type(iodefv2_telephone_type_t type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type = type;
        ptr->type_is_set = 1;
}


void IODEFV2telephone::unset_type()
{
        iodefv2_telephone_unset_type(_priv);
}




std::string  IODEFV2telephone::get_ext_type()
{
        return to_string(iodefv2_telephone_get_ext_type(_priv));
}

void IODEFV2telephone::set_ext_type(libiodefv2_string_t *ext_type)
{
        iodefv2_telephone_set_ext_type(this, ext_type);
}




std::string  IODEFV2telephone::get_telephone_number()
{
        return to_string(iodefv2_telephone_get_telephone_number(_priv));
}

void IODEFV2telephone::set_telephone_number(libiodefv2_string_t *telephone_number)
{
        iodefv2_telephone_set_telephone_number(this, telephone_number);
}




std::string  IODEFV2telephone::get_description()
{
        return to_string(iodefv2_telephone_get_description(_priv));
}

void IODEFV2telephone::set_description(libiodefv2_string_t *description)
{
        iodefv2_telephone_set_description(this, description);
}



/**
 * iodefv2_telephone_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_telephone_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2telephone::copy(IODEFV2telephone *dst)
{
        return iodefv2_telephone_copy(_priv, dst->_priv);
}



/**
 * iodefv2_telephone_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2telephone *IODEFV2telephone::clone()
{
        int ret;
        iodefv2_telephone_t *dst;
        IODEFV2telephone *ptr;

        ret = iodefv2_telephone_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2telephone();
        iodefv2_telephone_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_telephone_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2telephone::compare(IODEFV2telephone *obj)
{
        return iodefv2_telephone_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_certificate_new:
 * @ret: Pointer where to store the created #iodefv2_certificate_t object.
 *
 * Create a new #iodefv2_certificate_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2certificate::IODEFV2certificate()
{
        iodefv2_certificate_new(&_priv);
}


/**
 * iodefv2_certificate_destroy:
 * @ptr: pointer to a #iodefv2_certificate_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2certificate::~IODEFV2certificate()
{
        iodefv2_certificate_destroy(_priv);
}





std::string  IODEFV2certificate::get_observable_id()
{
        return to_string(iodefv2_certificate_get_observable_id(_priv));
}

void IODEFV2certificate::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_certificate_set_observable_id(this, observable_id);
}




iodefv2_data_t  IODEFV2certificate::get_x509_data()
{
        return (iodefv2_certificate_get_x509_data(_priv));
}

void IODEFV2certificate::set_x509_data(iodefv2_data_t *x509_data)
{
        iodefv2_certificate_set_x509_data(this, x509_data);
}




std::string  IODEFV2certificate::get_description()
{
        return to_string(iodefv2_certificate_get_description(_priv));
}

void IODEFV2certificate::set_description(libiodefv2_string_t *description)
{
        iodefv2_certificate_set_description(this, description);
}



/**
 * iodefv2_certificate_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_certificate_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2certificate::copy(IODEFV2certificate *dst)
{
        return iodefv2_certificate_copy(_priv, dst->_priv);
}



/**
 * iodefv2_certificate_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2certificate *IODEFV2certificate::clone()
{
        int ret;
        iodefv2_certificate_t *dst;
        IODEFV2certificate *ptr;

        ret = iodefv2_certificate_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2certificate();
        iodefv2_certificate_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_certificate_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2certificate::compare(IODEFV2certificate *obj)
{
        return iodefv2_certificate_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_key_new:
 * @ret: Pointer where to store the created #iodefv2_key_t object.
 *
 * Create a new #iodefv2_key_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2key::IODEFV2key()
{
        iodefv2_key_new(&_priv);
}


/**
 * iodefv2_key_destroy:
 * @ptr: pointer to a #iodefv2_key_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2key::~IODEFV2key()
{
        iodefv2_key_destroy(_priv);
}





iodefv2_key_registryaction_t * IODEFV2key::get_registryaction()
{
        return (iodefv2_key_get_registryaction(_priv));
}

void IODEFV2key::set_registryaction(iodefv2_key_registryaction_t registryaction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->registryaction = registryaction;
        ptr->registryaction_is_set = 1;
}


void IODEFV2key::unset_registryaction()
{
        iodefv2_key_unset_registryaction(_priv);
}




std::string  IODEFV2key::get_ext_registryaction()
{
        return to_string(iodefv2_key_get_ext_registryaction(_priv));
}

void IODEFV2key::set_ext_registryaction(libiodefv2_string_t *ext_registryaction)
{
        iodefv2_key_set_ext_registryaction(this, ext_registryaction);
}




std::string  IODEFV2key::get_observable_id()
{
        return to_string(iodefv2_key_get_observable_id(_priv));
}

void IODEFV2key::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_key_set_observable_id(this, observable_id);
}




std::string  IODEFV2key::get_key_name()
{
        return to_string(iodefv2_key_get_key_name(_priv));
}

void IODEFV2key::set_key_name(libiodefv2_string_t *key_name)
{
        iodefv2_key_set_key_name(this, key_name);
}




std::string  IODEFV2key::get_key_value()
{
        return to_string(iodefv2_key_get_key_value(_priv));
}

void IODEFV2key::set_key_value(libiodefv2_string_t *key_value)
{
        iodefv2_key_set_key_value(this, key_value);
}



/**
 * iodefv2_key_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_key_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2key::copy(IODEFV2key *dst)
{
        return iodefv2_key_copy(_priv, dst->_priv);
}



/**
 * iodefv2_key_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2key *IODEFV2key::clone()
{
        int ret;
        iodefv2_key_t *dst;
        IODEFV2key *ptr;

        ret = iodefv2_key_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2key();
        iodefv2_key_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_key_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2key::compare(IODEFV2key *obj)
{
        return iodefv2_key_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_observable_reference_new:
 * @ret: Pointer where to store the created #iodefv2_observable_reference_t object.
 *
 * Create a new #iodefv2_observable_reference_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2observable_reference::IODEFV2observable_reference()
{
        iodefv2_observable_reference_new(&_priv);
}


/**
 * iodefv2_observable_reference_destroy:
 * @ptr: pointer to a #iodefv2_observable_reference_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2observable_reference::~IODEFV2observable_reference()
{
        iodefv2_observable_reference_destroy(_priv);
}





std::string  IODEFV2observable_reference::get_uid_ref()
{
        return to_string(iodefv2_observable_reference_get_uid_ref(_priv));
}

void IODEFV2observable_reference::set_uid_ref(libiodefv2_string_t *uid_ref)
{
        iodefv2_observable_reference_set_uid_ref(this, uid_ref);
}



/**
 * iodefv2_observable_reference_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_observable_reference_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2observable_reference::copy(IODEFV2observable_reference *dst)
{
        return iodefv2_observable_reference_copy(_priv, dst->_priv);
}



/**
 * iodefv2_observable_reference_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2observable_reference *IODEFV2observable_reference::clone()
{
        int ret;
        iodefv2_observable_reference_t *dst;
        IODEFV2observable_reference *ptr;

        ret = iodefv2_observable_reference_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2observable_reference();
        iodefv2_observable_reference_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_observable_reference_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2observable_reference::compare(IODEFV2observable_reference *obj)
{
        return iodefv2_observable_reference_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_registry_handle_new:
 * @ret: Pointer where to store the created #iodefv2_registry_handle_t object.
 *
 * Create a new #iodefv2_registry_handle_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2registry_handle::IODEFV2registry_handle()
{
        iodefv2_registry_handle_new(&_priv);
}


/**
 * iodefv2_registry_handle_destroy:
 * @ptr: pointer to a #iodefv2_registry_handle_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2registry_handle::~IODEFV2registry_handle()
{
        iodefv2_registry_handle_destroy(_priv);
}





iodefv2_registry_handle_registry_t  IODEFV2registry_handle::get_registry()
{
        return (iodefv2_registry_handle_get_registry(_priv));
}

void IODEFV2registry_handle::set_registry(iodefv2_registry_handle_registry_t registry)
{
        iodefv2_registry_handle_set_registry(this, registry);
}




std::string  IODEFV2registry_handle::get_ext_registry()
{
        return to_string(iodefv2_registry_handle_get_ext_registry(_priv));
}

void IODEFV2registry_handle::set_ext_registry(libiodefv2_string_t *ext_registry)
{
        iodefv2_registry_handle_set_ext_registry(this, ext_registry);
}



/**
 * iodefv2_registry_handle_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_registry_handle_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2registry_handle::copy(IODEFV2registry_handle *dst)
{
        return iodefv2_registry_handle_copy(_priv, dst->_priv);
}



/**
 * iodefv2_registry_handle_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2registry_handle *IODEFV2registry_handle::clone()
{
        int ret;
        iodefv2_registry_handle_t *dst;
        IODEFV2registry_handle *ptr;

        ret = iodefv2_registry_handle_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2registry_handle();
        iodefv2_registry_handle_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_registry_handle_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2registry_handle::compare(IODEFV2registry_handle *obj)
{
        return iodefv2_registry_handle_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_time_impact_new:
 * @ret: Pointer where to store the created #iodefv2_time_impact_t object.
 *
 * Create a new #iodefv2_time_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2time_impact::IODEFV2time_impact()
{
        iodefv2_time_impact_new(&_priv);
}


/**
 * iodefv2_time_impact_destroy:
 * @ptr: pointer to a #iodefv2_time_impact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2time_impact::~IODEFV2time_impact()
{
        iodefv2_time_impact_destroy(_priv);
}





std::string  IODEFV2time_impact::get_ext_metric()
{
        return to_string(iodefv2_time_impact_get_ext_metric(_priv));
}

void IODEFV2time_impact::set_ext_metric(libiodefv2_string_t *ext_metric)
{
        iodefv2_time_impact_set_ext_metric(this, ext_metric);
}




iodefv2_time_impact_duration_t  IODEFV2time_impact::get_duration()
{
        return (iodefv2_time_impact_get_duration(_priv));
}

void IODEFV2time_impact::set_duration(iodefv2_time_impact_duration_t duration)
{
        iodefv2_time_impact_set_duration(this, duration);
}




iodefv2_time_impact_metric_t  IODEFV2time_impact::get_metric()
{
        return (iodefv2_time_impact_get_metric(_priv));
}

void IODEFV2time_impact::set_metric(iodefv2_time_impact_metric_t metric)
{
        iodefv2_time_impact_set_metric(this, metric);
}




iodefv2_time_impact_severity_t * IODEFV2time_impact::get_severity()
{
        return (iodefv2_time_impact_get_severity(_priv));
}

void IODEFV2time_impact::set_severity(iodefv2_time_impact_severity_t severity)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity = severity;
        ptr->severity_is_set = 1;
}


void IODEFV2time_impact::unset_severity()
{
        iodefv2_time_impact_unset_severity(_priv);
}




std::string  IODEFV2time_impact::get_ext_duration()
{
        return to_string(iodefv2_time_impact_get_ext_duration(_priv));
}

void IODEFV2time_impact::set_ext_duration(libiodefv2_string_t *ext_duration)
{
        iodefv2_time_impact_set_ext_duration(this, ext_duration);
}



/**
 * iodefv2_time_impact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_time_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2time_impact::copy(IODEFV2time_impact *dst)
{
        return iodefv2_time_impact_copy(_priv, dst->_priv);
}



/**
 * iodefv2_time_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2time_impact *IODEFV2time_impact::clone()
{
        int ret;
        iodefv2_time_impact_t *dst;
        IODEFV2time_impact *ptr;

        ret = iodefv2_time_impact_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2time_impact();
        iodefv2_time_impact_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_time_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2time_impact::compare(IODEFV2time_impact *obj)
{
        return iodefv2_time_impact_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_record_pattern_new:
 * @ret: Pointer where to store the created #iodefv2_record_pattern_t object.
 *
 * Create a new #iodefv2_record_pattern_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2record_pattern::IODEFV2record_pattern()
{
        iodefv2_record_pattern_new(&_priv);
}


/**
 * iodefv2_record_pattern_destroy:
 * @ptr: pointer to a #iodefv2_record_pattern_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2record_pattern::~IODEFV2record_pattern()
{
        iodefv2_record_pattern_destroy(_priv);
}





uint32_t * IODEFV2record_pattern::get_instance()
{
        return (iodefv2_record_pattern_get_instance(_priv));
}

void IODEFV2record_pattern::set_instance(uint32_t instance)
{
        libiodefv2_return_if_fail(ptr);
        ptr->instance = instance;
        ptr->instance_is_set = 1;
}


void IODEFV2record_pattern::unset_instance()
{
        iodefv2_record_pattern_unset_instance(_priv);
}




std::string  IODEFV2record_pattern::get_ext_type()
{
        return to_string(iodefv2_record_pattern_get_ext_type(_priv));
}

void IODEFV2record_pattern::set_ext_type(libiodefv2_string_t *ext_type)
{
        iodefv2_record_pattern_set_ext_type(this, ext_type);
}




uint32_t * IODEFV2record_pattern::get_offset()
{
        return (iodefv2_record_pattern_get_offset(_priv));
}

void IODEFV2record_pattern::set_offset(uint32_t offset)
{
        libiodefv2_return_if_fail(ptr);
        ptr->offset = offset;
        ptr->offset_is_set = 1;
}


void IODEFV2record_pattern::unset_offset()
{
        iodefv2_record_pattern_unset_offset(_priv);
}




iodefv2_record_pattern_offsetunit_t * IODEFV2record_pattern::get_offsetunit()
{
        return (iodefv2_record_pattern_get_offsetunit(_priv));
}

void IODEFV2record_pattern::set_offsetunit(iodefv2_record_pattern_offsetunit_t offsetunit)
{
        libiodefv2_return_if_fail(ptr);
        ptr->offsetunit = offsetunit;
        ptr->offsetunit_is_set = 1;
}


void IODEFV2record_pattern::unset_offsetunit()
{
        iodefv2_record_pattern_unset_offsetunit(_priv);
}




std::string  IODEFV2record_pattern::get_ext_offsetunit()
{
        return to_string(iodefv2_record_pattern_get_ext_offsetunit(_priv));
}

void IODEFV2record_pattern::set_ext_offsetunit(libiodefv2_string_t *ext_offsetunit)
{
        iodefv2_record_pattern_set_ext_offsetunit(this, ext_offsetunit);
}




iodefv2_record_pattern_type_t  IODEFV2record_pattern::get_type()
{
        return (iodefv2_record_pattern_get_type(_priv));
}

void IODEFV2record_pattern::set_type(iodefv2_record_pattern_type_t type)
{
        iodefv2_record_pattern_set_type(this, type);
}



/**
 * iodefv2_record_pattern_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_record_pattern_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2record_pattern::copy(IODEFV2record_pattern *dst)
{
        return iodefv2_record_pattern_copy(_priv, dst->_priv);
}



/**
 * iodefv2_record_pattern_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2record_pattern *IODEFV2record_pattern::clone()
{
        int ret;
        iodefv2_record_pattern_t *dst;
        IODEFV2record_pattern *ptr;

        ret = iodefv2_record_pattern_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2record_pattern();
        iodefv2_record_pattern_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_record_pattern_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2record_pattern::compare(IODEFV2record_pattern *obj)
{
        return iodefv2_record_pattern_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_reference_new:
 * @ret: Pointer where to store the created #iodefv2_reference_t object.
 *
 * Create a new #iodefv2_reference_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2reference::IODEFV2reference()
{
        iodefv2_reference_new(&_priv);
}


/**
 * iodefv2_reference_destroy:
 * @ptr: pointer to a #iodefv2_reference_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2reference::~IODEFV2reference()
{
        iodefv2_reference_destroy(_priv);
}





std::string  IODEFV2reference::get_observable_id()
{
        return to_string(iodefv2_reference_get_observable_id(_priv));
}

void IODEFV2reference::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_reference_set_observable_id(this, observable_id);
}




std::string  IODEFV2reference::get_url()
{
        return to_string(iodefv2_reference_get_url(_priv));
}

void IODEFV2reference::set_url(libiodefv2_string_t *url)
{
        iodefv2_reference_set_url(this, url);
}




std::string  IODEFV2reference::get_description()
{
        return to_string(iodefv2_reference_get_description(_priv));
}

void IODEFV2reference::set_description(libiodefv2_string_t *description)
{
        iodefv2_reference_set_description(this, description);
}




std::string  IODEFV2reference::get_reference_name()
{
        return to_string(iodefv2_reference_get_reference_name(_priv));
}

void IODEFV2reference::set_reference_name(libiodefv2_string_t *reference_name)
{
        iodefv2_reference_set_reference_name(this, reference_name);
}



/**
 * iodefv2_reference_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_reference_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2reference::copy(IODEFV2reference *dst)
{
        return iodefv2_reference_copy(_priv, dst->_priv);
}



/**
 * iodefv2_reference_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2reference *IODEFV2reference::clone()
{
        int ret;
        iodefv2_reference_t *dst;
        IODEFV2reference *ptr;

        ret = iodefv2_reference_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2reference();
        iodefv2_reference_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_reference_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2reference::compare(IODEFV2reference *obj)
{
        return iodefv2_reference_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_postal_address_new:
 * @ret: Pointer where to store the created #iodefv2_postal_address_t object.
 *
 * Create a new #iodefv2_postal_address_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2postal_address::IODEFV2postal_address()
{
        iodefv2_postal_address_new(&_priv);
}


/**
 * iodefv2_postal_address_destroy:
 * @ptr: pointer to a #iodefv2_postal_address_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2postal_address::~IODEFV2postal_address()
{
        iodefv2_postal_address_destroy(_priv);
}





iodefv2_postal_address_type_t * IODEFV2postal_address::get_type()
{
        return (iodefv2_postal_address_get_type(_priv));
}

void IODEFV2postal_address::set_type(iodefv2_postal_address_type_t type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type = type;
        ptr->type_is_set = 1;
}


void IODEFV2postal_address::unset_type()
{
        iodefv2_postal_address_unset_type(_priv);
}




std::string  IODEFV2postal_address::get_ext_type()
{
        return to_string(iodefv2_postal_address_get_ext_type(_priv));
}

void IODEFV2postal_address::set_ext_type(libiodefv2_string_t *ext_type)
{
        iodefv2_postal_address_set_ext_type(this, ext_type);
}




std::string  IODEFV2postal_address::get_p_address()
{
        return to_string(iodefv2_postal_address_get_p_address(_priv));
}

void IODEFV2postal_address::set_p_address(libiodefv2_string_t *p_address)
{
        iodefv2_postal_address_set_p_address(this, p_address);
}




std::string  IODEFV2postal_address::get_description()
{
        return to_string(iodefv2_postal_address_get_description(_priv));
}

void IODEFV2postal_address::set_description(libiodefv2_string_t *description)
{
        iodefv2_postal_address_set_description(this, description);
}



/**
 * iodefv2_postal_address_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_postal_address_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2postal_address::copy(IODEFV2postal_address *dst)
{
        return iodefv2_postal_address_copy(_priv, dst->_priv);
}



/**
 * iodefv2_postal_address_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2postal_address *IODEFV2postal_address::clone()
{
        int ret;
        iodefv2_postal_address_t *dst;
        IODEFV2postal_address *ptr;

        ret = iodefv2_postal_address_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2postal_address();
        iodefv2_postal_address_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_postal_address_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2postal_address::compare(IODEFV2postal_address *obj)
{
        return iodefv2_postal_address_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_node_role_new:
 * @ret: Pointer where to store the created #iodefv2_node_role_t object.
 *
 * Create a new #iodefv2_node_role_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2node_role::IODEFV2node_role()
{
        iodefv2_node_role_new(&_priv);
}


/**
 * iodefv2_node_role_destroy:
 * @ptr: pointer to a #iodefv2_node_role_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2node_role::~IODEFV2node_role()
{
        iodefv2_node_role_destroy(_priv);
}





iodefv2_node_role_category_t  IODEFV2node_role::get_category()
{
        return (iodefv2_node_role_get_category(_priv));
}

void IODEFV2node_role::set_category(iodefv2_node_role_category_t category)
{
        iodefv2_node_role_set_category(this, category);
}




std::string  IODEFV2node_role::get_ext_category()
{
        return to_string(iodefv2_node_role_get_ext_category(_priv));
}

void IODEFV2node_role::set_ext_category(libiodefv2_string_t *ext_category)
{
        iodefv2_node_role_set_ext_category(this, ext_category);
}




std::string  IODEFV2node_role::get_description()
{
        return to_string(iodefv2_node_role_get_description(_priv));
}

void IODEFV2node_role::set_description(libiodefv2_string_t *description)
{
        iodefv2_node_role_set_description(this, description);
}



/**
 * iodefv2_node_role_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_node_role_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2node_role::copy(IODEFV2node_role *dst)
{
        return iodefv2_node_role_copy(_priv, dst->_priv);
}



/**
 * iodefv2_node_role_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2node_role *IODEFV2node_role::clone()
{
        int ret;
        iodefv2_node_role_t *dst;
        IODEFV2node_role *ptr;

        ret = iodefv2_node_role_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2node_role();
        iodefv2_node_role_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_node_role_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2node_role::compare(IODEFV2node_role *obj)
{
        return iodefv2_node_role_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_incident_id_new:
 * @ret: Pointer where to store the created #iodefv2_incident_id_t object.
 *
 * Create a new #iodefv2_incident_id_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2incident_id::IODEFV2incident_id()
{
        iodefv2_incident_id_new(&_priv);
}


/**
 * iodefv2_incident_id_destroy:
 * @ptr: pointer to a #iodefv2_incident_id_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2incident_id::~IODEFV2incident_id()
{
        iodefv2_incident_id_destroy(_priv);
}





std::string  IODEFV2incident_id::get_instance()
{
        return to_string(iodefv2_incident_id_get_instance(_priv));
}

void IODEFV2incident_id::set_instance(libiodefv2_string_t *instance)
{
        iodefv2_incident_id_set_instance(this, instance);
}




std::string  IODEFV2incident_id::get_ext_restriction()
{
        return to_string(iodefv2_incident_id_get_ext_restriction(_priv));
}

void IODEFV2incident_id::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_incident_id_set_ext_restriction(this, ext_restriction);
}




std::string  IODEFV2incident_id::get_name()
{
        return to_string(iodefv2_incident_id_get_name(_priv));
}

void IODEFV2incident_id::set_name(libiodefv2_string_t *name)
{
        iodefv2_incident_id_set_name(this, name);
}




iodefv2_incident_id_restriction_t * IODEFV2incident_id::get_restriction()
{
        return (iodefv2_incident_id_get_restriction(_priv));
}

void IODEFV2incident_id::set_restriction(iodefv2_incident_id_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2incident_id::unset_restriction()
{
        iodefv2_incident_id_unset_restriction(_priv);
}



/**
 * iodefv2_incident_id_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_incident_id_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2incident_id::copy(IODEFV2incident_id *dst)
{
        return iodefv2_incident_id_copy(_priv, dst->_priv);
}



/**
 * iodefv2_incident_id_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2incident_id *IODEFV2incident_id::clone()
{
        int ret;
        iodefv2_incident_id_t *dst;
        IODEFV2incident_id *ptr;

        ret = iodefv2_incident_id_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2incident_id();
        iodefv2_incident_id_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_incident_id_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2incident_id::compare(IODEFV2incident_id *obj)
{
        return iodefv2_incident_id_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_alternative_indicator_id_new:
 * @ret: Pointer where to store the created #iodefv2_alternative_indicator_id_t object.
 *
 * Create a new #iodefv2_alternative_indicator_id_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2alternative_indicator_id::IODEFV2alternative_indicator_id()
{
        iodefv2_alternative_indicator_id_new(&_priv);
}


/**
 * iodefv2_alternative_indicator_id_destroy:
 * @ptr: pointer to a #iodefv2_alternative_indicator_id_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2alternative_indicator_id::~IODEFV2alternative_indicator_id()
{
        iodefv2_alternative_indicator_id_destroy(_priv);
}





iodefv2_alternative_indicator_id_restriction_t * IODEFV2alternative_indicator_id::get_restriction()
{
        return (iodefv2_alternative_indicator_id_get_restriction(_priv));
}

void IODEFV2alternative_indicator_id::set_restriction(iodefv2_alternative_indicator_id_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2alternative_indicator_id::unset_restriction()
{
        iodefv2_alternative_indicator_id_unset_restriction(_priv);
}




std::string  IODEFV2alternative_indicator_id::get_ext_restriction()
{
        return to_string(iodefv2_alternative_indicator_id_get_ext_restriction(_priv));
}

void IODEFV2alternative_indicator_id::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_alternative_indicator_id_set_ext_restriction(this, ext_restriction);
}




std::string  IODEFV2alternative_indicator_id::get_indicator_reference()
{
        return to_string(iodefv2_alternative_indicator_id_get_indicator_reference(_priv));
}

void IODEFV2alternative_indicator_id::set_indicator_reference(libiodefv2_string_t *indicator_reference)
{
        iodefv2_alternative_indicator_id_set_indicator_reference(this, indicator_reference);
}



/**
 * iodefv2_alternative_indicator_id_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_alternative_indicator_id_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2alternative_indicator_id::copy(IODEFV2alternative_indicator_id *dst)
{
        return iodefv2_alternative_indicator_id_copy(_priv, dst->_priv);
}



/**
 * iodefv2_alternative_indicator_id_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2alternative_indicator_id *IODEFV2alternative_indicator_id::clone()
{
        int ret;
        iodefv2_alternative_indicator_id_t *dst;
        IODEFV2alternative_indicator_id *ptr;

        ret = iodefv2_alternative_indicator_id_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2alternative_indicator_id();
        iodefv2_alternative_indicator_id_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_alternative_indicator_id_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2alternative_indicator_id::compare(IODEFV2alternative_indicator_id *obj)
{
        return iodefv2_alternative_indicator_id_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_confidence_new:
 * @ret: Pointer where to store the created #iodefv2_confidence_t object.
 *
 * Create a new #iodefv2_confidence_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2confidence::IODEFV2confidence()
{
        iodefv2_confidence_new(&_priv);
}


/**
 * iodefv2_confidence_destroy:
 * @ptr: pointer to a #iodefv2_confidence_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2confidence::~IODEFV2confidence()
{
        iodefv2_confidence_destroy(_priv);
}





iodefv2_confidence_rating_t  IODEFV2confidence::get_rating()
{
        return (iodefv2_confidence_get_rating(_priv));
}

void IODEFV2confidence::set_rating(iodefv2_confidence_rating_t rating)
{
        iodefv2_confidence_set_rating(this, rating);
}




std::string  IODEFV2confidence::get_ext_rating()
{
        return to_string(iodefv2_confidence_get_ext_rating(_priv));
}

void IODEFV2confidence::set_ext_rating(libiodefv2_string_t *ext_rating)
{
        iodefv2_confidence_set_ext_rating(this, ext_rating);
}



/**
 * iodefv2_confidence_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_confidence_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2confidence::copy(IODEFV2confidence *dst)
{
        return iodefv2_confidence_copy(_priv, dst->_priv);
}



/**
 * iodefv2_confidence_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2confidence *IODEFV2confidence::clone()
{
        int ret;
        iodefv2_confidence_t *dst;
        IODEFV2confidence *ptr;

        ret = iodefv2_confidence_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2confidence();
        iodefv2_confidence_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_confidence_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2confidence::compare(IODEFV2confidence *obj)
{
        return iodefv2_confidence_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_system_impact_new:
 * @ret: Pointer where to store the created #iodefv2_system_impact_t object.
 *
 * Create a new #iodefv2_system_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2system_impact::IODEFV2system_impact()
{
        iodefv2_system_impact_new(&_priv);
}


/**
 * iodefv2_system_impact_destroy:
 * @ptr: pointer to a #iodefv2_system_impact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2system_impact::~IODEFV2system_impact()
{
        iodefv2_system_impact_destroy(_priv);
}





iodefv2_system_impact_completion_t * IODEFV2system_impact::get_completion()
{
        return (iodefv2_system_impact_get_completion(_priv));
}

void IODEFV2system_impact::set_completion(iodefv2_system_impact_completion_t completion)
{
        libiodefv2_return_if_fail(ptr);
        ptr->completion = completion;
        ptr->completion_is_set = 1;
}


void IODEFV2system_impact::unset_completion()
{
        iodefv2_system_impact_unset_completion(_priv);
}




iodefv2_system_impact_type_t  IODEFV2system_impact::get_type()
{
        return (iodefv2_system_impact_get_type(_priv));
}

void IODEFV2system_impact::set_type(iodefv2_system_impact_type_t type)
{
        iodefv2_system_impact_set_type(this, type);
}




iodefv2_system_impact_severity_t * IODEFV2system_impact::get_severity()
{
        return (iodefv2_system_impact_get_severity(_priv));
}

void IODEFV2system_impact::set_severity(iodefv2_system_impact_severity_t severity)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity = severity;
        ptr->severity_is_set = 1;
}


void IODEFV2system_impact::unset_severity()
{
        iodefv2_system_impact_unset_severity(_priv);
}




std::string  IODEFV2system_impact::get_ext_type()
{
        return to_string(iodefv2_system_impact_get_ext_type(_priv));
}

void IODEFV2system_impact::set_ext_type(libiodefv2_string_t *ext_type)
{
        iodefv2_system_impact_set_ext_type(this, ext_type);
}




std::string  IODEFV2system_impact::get_description()
{
        return to_string(iodefv2_system_impact_get_description(_priv));
}

void IODEFV2system_impact::set_description(libiodefv2_string_t *description)
{
        iodefv2_system_impact_set_description(this, description);
}



/**
 * iodefv2_system_impact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_system_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2system_impact::copy(IODEFV2system_impact *dst)
{
        return iodefv2_system_impact_copy(_priv, dst->_priv);
}



/**
 * iodefv2_system_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2system_impact *IODEFV2system_impact::clone()
{
        int ret;
        iodefv2_system_impact_t *dst;
        IODEFV2system_impact *ptr;

        ret = iodefv2_system_impact_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2system_impact();
        iodefv2_system_impact_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_system_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2system_impact::compare(IODEFV2system_impact *obj)
{
        return iodefv2_system_impact_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_software_reference_new:
 * @ret: Pointer where to store the created #iodefv2_software_reference_t object.
 *
 * Create a new #iodefv2_software_reference_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2software_reference::IODEFV2software_reference()
{
        iodefv2_software_reference_new(&_priv);
}


/**
 * iodefv2_software_reference_destroy:
 * @ptr: pointer to a #iodefv2_software_reference_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2software_reference::~IODEFV2software_reference()
{
        iodefv2_software_reference_destroy(_priv);
}





iodefv2_software_reference_dtype_t * IODEFV2software_reference::get_dtype()
{
        return (iodefv2_software_reference_get_dtype(_priv));
}

void IODEFV2software_reference::set_dtype(iodefv2_software_reference_dtype_t dtype)
{
        libiodefv2_return_if_fail(ptr);
        ptr->dtype = dtype;
        ptr->dtype_is_set = 1;
}


void IODEFV2software_reference::unset_dtype()
{
        iodefv2_software_reference_unset_dtype(_priv);
}




std::string  IODEFV2software_reference::get_ext_spec_name()
{
        return to_string(iodefv2_software_reference_get_ext_spec_name(_priv));
}

void IODEFV2software_reference::set_ext_spec_name(libiodefv2_string_t *ext_spec_name)
{
        iodefv2_software_reference_set_ext_spec_name(this, ext_spec_name);
}




std::string  IODEFV2software_reference::get_ext_dtype()
{
        return to_string(iodefv2_software_reference_get_ext_dtype(_priv));
}

void IODEFV2software_reference::set_ext_dtype(libiodefv2_string_t *ext_dtype)
{
        iodefv2_software_reference_set_ext_dtype(this, ext_dtype);
}



/**
 * iodefv2_software_reference_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_software_reference_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2software_reference::copy(IODEFV2software_reference *dst)
{
        return iodefv2_software_reference_copy(_priv, dst->_priv);
}



/**
 * iodefv2_software_reference_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2software_reference *IODEFV2software_reference::clone()
{
        int ret;
        iodefv2_software_reference_t *dst;
        IODEFV2software_reference *ptr;

        ret = iodefv2_software_reference_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2software_reference();
        iodefv2_software_reference_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_software_reference_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2software_reference::compare(IODEFV2software_reference *obj)
{
        return iodefv2_software_reference_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_business_impact_new:
 * @ret: Pointer where to store the created #iodefv2_business_impact_t object.
 *
 * Create a new #iodefv2_business_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2business_impact::IODEFV2business_impact()
{
        iodefv2_business_impact_new(&_priv);
}


/**
 * iodefv2_business_impact_destroy:
 * @ptr: pointer to a #iodefv2_business_impact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2business_impact::~IODEFV2business_impact()
{
        iodefv2_business_impact_destroy(_priv);
}





std::string  IODEFV2business_impact::get_ext_severity()
{
        return to_string(iodefv2_business_impact_get_ext_severity(_priv));
}

void IODEFV2business_impact::set_ext_severity(libiodefv2_string_t *ext_severity)
{
        iodefv2_business_impact_set_ext_severity(this, ext_severity);
}




iodefv2_business_impact_type_t  IODEFV2business_impact::get_type()
{
        return (iodefv2_business_impact_get_type(_priv));
}

void IODEFV2business_impact::set_type(iodefv2_business_impact_type_t type)
{
        iodefv2_business_impact_set_type(this, type);
}




iodefv2_business_impact_severity_t * IODEFV2business_impact::get_severity()
{
        return (iodefv2_business_impact_get_severity(_priv));
}

void IODEFV2business_impact::set_severity(iodefv2_business_impact_severity_t severity)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity = severity;
        ptr->severity_is_set = 1;
}


void IODEFV2business_impact::unset_severity()
{
        iodefv2_business_impact_unset_severity(_priv);
}




std::string  IODEFV2business_impact::get_ext_type()
{
        return to_string(iodefv2_business_impact_get_ext_type(_priv));
}

void IODEFV2business_impact::set_ext_type(libiodefv2_string_t *ext_type)
{
        iodefv2_business_impact_set_ext_type(this, ext_type);
}




std::string  IODEFV2business_impact::get_description()
{
        return to_string(iodefv2_business_impact_get_description(_priv));
}

void IODEFV2business_impact::set_description(libiodefv2_string_t *description)
{
        iodefv2_business_impact_set_description(this, description);
}



/**
 * iodefv2_business_impact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_business_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2business_impact::copy(IODEFV2business_impact *dst)
{
        return iodefv2_business_impact_copy(_priv, dst->_priv);
}



/**
 * iodefv2_business_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2business_impact *IODEFV2business_impact::clone()
{
        int ret;
        iodefv2_business_impact_t *dst;
        IODEFV2business_impact *ptr;

        ret = iodefv2_business_impact_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2business_impact();
        iodefv2_business_impact_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_business_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2business_impact::compare(IODEFV2business_impact *obj)
{
        return iodefv2_business_impact_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_indicator_reference_new:
 * @ret: Pointer where to store the created #iodefv2_indicator_reference_t object.
 *
 * Create a new #iodefv2_indicator_reference_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2indicator_reference::IODEFV2indicator_reference()
{
        iodefv2_indicator_reference_new(&_priv);
}


/**
 * iodefv2_indicator_reference_destroy:
 * @ptr: pointer to a #iodefv2_indicator_reference_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2indicator_reference::~IODEFV2indicator_reference()
{
        iodefv2_indicator_reference_destroy(_priv);
}





std::string  IODEFV2indicator_reference::get_uid_ref()
{
        return to_string(iodefv2_indicator_reference_get_uid_ref(_priv));
}

void IODEFV2indicator_reference::set_uid_ref(libiodefv2_string_t *uid_ref)
{
        iodefv2_indicator_reference_set_uid_ref(this, uid_ref);
}




std::string  IODEFV2indicator_reference::get_version()
{
        return to_string(iodefv2_indicator_reference_get_version(_priv));
}

void IODEFV2indicator_reference::set_version(libiodefv2_string_t *version)
{
        iodefv2_indicator_reference_set_version(this, version);
}




std::string  IODEFV2indicator_reference::get_euid_ref()
{
        return to_string(iodefv2_indicator_reference_get_euid_ref(_priv));
}

void IODEFV2indicator_reference::set_euid_ref(libiodefv2_string_t *euid_ref)
{
        iodefv2_indicator_reference_set_euid_ref(this, euid_ref);
}



/**
 * iodefv2_indicator_reference_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_indicator_reference_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2indicator_reference::copy(IODEFV2indicator_reference *dst)
{
        return iodefv2_indicator_reference_copy(_priv, dst->_priv);
}



/**
 * iodefv2_indicator_reference_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2indicator_reference *IODEFV2indicator_reference::clone()
{
        int ret;
        iodefv2_indicator_reference_t *dst;
        IODEFV2indicator_reference *ptr;

        ret = iodefv2_indicator_reference_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2indicator_reference();
        iodefv2_indicator_reference_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_indicator_reference_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2indicator_reference::compare(IODEFV2indicator_reference *obj)
{
        return iodefv2_indicator_reference_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_email_new:
 * @ret: Pointer where to store the created #iodefv2_email_t object.
 *
 * Create a new #iodefv2_email_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2email::IODEFV2email()
{
        iodefv2_email_new(&_priv);
}


/**
 * iodefv2_email_destroy:
 * @ptr: pointer to a #iodefv2_email_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2email::~IODEFV2email()
{
        iodefv2_email_destroy(_priv);
}





iodefv2_email_type_t * IODEFV2email::get_type()
{
        return (iodefv2_email_get_type(_priv));
}

void IODEFV2email::set_type(iodefv2_email_type_t type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type = type;
        ptr->type_is_set = 1;
}


void IODEFV2email::unset_type()
{
        iodefv2_email_unset_type(_priv);
}




std::string  IODEFV2email::get_ext_type()
{
        return to_string(iodefv2_email_get_ext_type(_priv));
}

void IODEFV2email::set_ext_type(libiodefv2_string_t *ext_type)
{
        iodefv2_email_set_ext_type(this, ext_type);
}




std::string  IODEFV2email::get_email_to()
{
        return to_string(iodefv2_email_get_email_to(_priv));
}

void IODEFV2email::set_email_to(libiodefv2_string_t *email_to)
{
        iodefv2_email_set_email_to(this, email_to);
}




std::string  IODEFV2email::get_description()
{
        return to_string(iodefv2_email_get_description(_priv));
}

void IODEFV2email::set_description(libiodefv2_string_t *description)
{
        iodefv2_email_set_description(this, description);
}



/**
 * iodefv2_email_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_email_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2email::copy(IODEFV2email *dst)
{
        return iodefv2_email_copy(_priv, dst->_priv);
}



/**
 * iodefv2_email_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2email *IODEFV2email::clone()
{
        int ret;
        iodefv2_email_t *dst;
        IODEFV2email *ptr;

        ret = iodefv2_email_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2email();
        iodefv2_email_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_email_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2email::compare(IODEFV2email *obj)
{
        return iodefv2_email_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_intended_impact_new:
 * @ret: Pointer where to store the created #iodefv2_intended_impact_t object.
 *
 * Create a new #iodefv2_intended_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2intended_impact::IODEFV2intended_impact()
{
        iodefv2_intended_impact_new(&_priv);
}


/**
 * iodefv2_intended_impact_destroy:
 * @ptr: pointer to a #iodefv2_intended_impact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2intended_impact::~IODEFV2intended_impact()
{
        iodefv2_intended_impact_destroy(_priv);
}





std::string  IODEFV2intended_impact::get_ext_severity()
{
        return to_string(iodefv2_intended_impact_get_ext_severity(_priv));
}

void IODEFV2intended_impact::set_ext_severity(libiodefv2_string_t *ext_severity)
{
        iodefv2_intended_impact_set_ext_severity(this, ext_severity);
}




iodefv2_intended_impact_type_t  IODEFV2intended_impact::get_type()
{
        return (iodefv2_intended_impact_get_type(_priv));
}

void IODEFV2intended_impact::set_type(iodefv2_intended_impact_type_t type)
{
        iodefv2_intended_impact_set_type(this, type);
}




iodefv2_intended_impact_severity_t * IODEFV2intended_impact::get_severity()
{
        return (iodefv2_intended_impact_get_severity(_priv));
}

void IODEFV2intended_impact::set_severity(iodefv2_intended_impact_severity_t severity)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity = severity;
        ptr->severity_is_set = 1;
}


void IODEFV2intended_impact::unset_severity()
{
        iodefv2_intended_impact_unset_severity(_priv);
}




std::string  IODEFV2intended_impact::get_ext_type()
{
        return to_string(iodefv2_intended_impact_get_ext_type(_priv));
}

void IODEFV2intended_impact::set_ext_type(libiodefv2_string_t *ext_type)
{
        iodefv2_intended_impact_set_ext_type(this, ext_type);
}




std::string  IODEFV2intended_impact::get_description()
{
        return to_string(iodefv2_intended_impact_get_description(_priv));
}

void IODEFV2intended_impact::set_description(libiodefv2_string_t *description)
{
        iodefv2_intended_impact_set_description(this, description);
}



/**
 * iodefv2_intended_impact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_intended_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2intended_impact::copy(IODEFV2intended_impact *dst)
{
        return iodefv2_intended_impact_copy(_priv, dst->_priv);
}



/**
 * iodefv2_intended_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2intended_impact *IODEFV2intended_impact::clone()
{
        int ret;
        iodefv2_intended_impact_t *dst;
        IODEFV2intended_impact *ptr;

        ret = iodefv2_intended_impact_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2intended_impact();
        iodefv2_intended_impact_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_intended_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2intended_impact::compare(IODEFV2intended_impact *obj)
{
        return iodefv2_intended_impact_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_additional_data_new:
 * @ret: Pointer where to store the created #iodefv2_additional_data_t object.
 *
 * Create a new #iodefv2_additional_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2additional_data::IODEFV2additional_data()
{
        iodefv2_additional_data_new(&_priv);
}


/**
 * iodefv2_additional_data_destroy:
 * @ptr: pointer to a #iodefv2_additional_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2additional_data::~IODEFV2additional_data()
{
        iodefv2_additional_data_destroy(_priv);
}





iodefv2_additional_data_restriction_t * IODEFV2additional_data::get_restriction()
{
        return (iodefv2_additional_data_get_restriction(_priv));
}

void IODEFV2additional_data::set_restriction(iodefv2_additional_data_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2additional_data::unset_restriction()
{
        iodefv2_additional_data_unset_restriction(_priv);
}




std::string  IODEFV2additional_data::get_name()
{
        return to_string(iodefv2_additional_data_get_name(_priv));
}

void IODEFV2additional_data::set_name(libiodefv2_string_t *name)
{
        iodefv2_additional_data_set_name(this, name);
}




iodefv2_additional_data_type_t  IODEFV2additional_data::get_type()
{
        return (iodefv2_additional_data_get_type(_priv));
}

void IODEFV2additional_data::set_type(iodefv2_additional_data_type_t type)
{
        iodefv2_additional_data_set_type(this, type);
}




std::string  IODEFV2additional_data::get_ext_restriction()
{
        return to_string(iodefv2_additional_data_get_ext_restriction(_priv));
}

void IODEFV2additional_data::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_additional_data_set_ext_restriction(this, ext_restriction);
}




std::string  IODEFV2additional_data::get_formatid()
{
        return to_string(iodefv2_additional_data_get_formatid(_priv));
}

void IODEFV2additional_data::set_formatid(libiodefv2_string_t *formatid)
{
        iodefv2_additional_data_set_formatid(this, formatid);
}




std::string  IODEFV2additional_data::get_observable_id()
{
        return to_string(iodefv2_additional_data_get_observable_id(_priv));
}

void IODEFV2additional_data::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_additional_data_set_observable_id(this, observable_id);
}




std::string  IODEFV2additional_data::get_meaning()
{
        return to_string(iodefv2_additional_data_get_meaning(_priv));
}

void IODEFV2additional_data::set_meaning(libiodefv2_string_t *meaning)
{
        iodefv2_additional_data_set_meaning(this, meaning);
}




std::string  IODEFV2additional_data::get_ext_dtype()
{
        return to_string(iodefv2_additional_data_get_ext_dtype(_priv));
}

void IODEFV2additional_data::set_ext_dtype(libiodefv2_string_t *ext_dtype)
{
        iodefv2_additional_data_set_ext_dtype(this, ext_dtype);
}




iodefv2_data_t  IODEFV2additional_data::get_data()
{
        return (iodefv2_additional_data_get_data(_priv));
}

void IODEFV2additional_data::set_data(iodefv2_data_t *data)
{
        iodefv2_additional_data_set_data(this, data);
}



/**
 * iodefv2_additional_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_additional_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2additional_data::copy(IODEFV2additional_data *dst)
{
        return iodefv2_additional_data_copy(_priv, dst->_priv);
}



/**
 * iodefv2_additional_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2additional_data *IODEFV2additional_data::clone()
{
        int ret;
        iodefv2_additional_data_t *dst;
        IODEFV2additional_data *ptr;

        ret = iodefv2_additional_data_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2additional_data();
        iodefv2_additional_data_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_additional_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2additional_data::compare(IODEFV2additional_data *obj)
{
        return iodefv2_additional_data_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_counter_new:
 * @ret: Pointer where to store the created #iodefv2_counter_t object.
 *
 * Create a new #iodefv2_counter_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2counter::IODEFV2counter()
{
        iodefv2_counter_new(&_priv);
}


/**
 * iodefv2_counter_destroy:
 * @ptr: pointer to a #iodefv2_counter_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2counter::~IODEFV2counter()
{
        iodefv2_counter_destroy(_priv);
}





std::string  IODEFV2counter::get_meaning()
{
        return to_string(iodefv2_counter_get_meaning(_priv));
}

void IODEFV2counter::set_meaning(libiodefv2_string_t *meaning)
{
        iodefv2_counter_set_meaning(this, meaning);
}




iodefv2_counter_unit_t  IODEFV2counter::get_unit()
{
        return (iodefv2_counter_get_unit(_priv));
}

void IODEFV2counter::set_unit(iodefv2_counter_unit_t unit)
{
        iodefv2_counter_set_unit(this, unit);
}




std::string  IODEFV2counter::get_ext_type()
{
        return to_string(iodefv2_counter_get_ext_type(_priv));
}

void IODEFV2counter::set_ext_type(libiodefv2_string_t *ext_type)
{
        iodefv2_counter_set_ext_type(this, ext_type);
}




iodefv2_counter_duration_t * IODEFV2counter::get_duration()
{
        return (iodefv2_counter_get_duration(_priv));
}

void IODEFV2counter::set_duration(iodefv2_counter_duration_t duration)
{
        libiodefv2_return_if_fail(ptr);
        ptr->duration = duration;
        ptr->duration_is_set = 1;
}


void IODEFV2counter::unset_duration()
{
        iodefv2_counter_unset_duration(_priv);
}




std::string  IODEFV2counter::get_ext_unit()
{
        return to_string(iodefv2_counter_get_ext_unit(_priv));
}

void IODEFV2counter::set_ext_unit(libiodefv2_string_t *ext_unit)
{
        iodefv2_counter_set_ext_unit(this, ext_unit);
}




iodefv2_counter_type_t  IODEFV2counter::get_type()
{
        return (iodefv2_counter_get_type(_priv));
}

void IODEFV2counter::set_type(iodefv2_counter_type_t type)
{
        iodefv2_counter_set_type(this, type);
}




std::string  IODEFV2counter::get_ext_duration()
{
        return to_string(iodefv2_counter_get_ext_duration(_priv));
}

void IODEFV2counter::set_ext_duration(libiodefv2_string_t *ext_duration)
{
        iodefv2_counter_set_ext_duration(this, ext_duration);
}



/**
 * iodefv2_counter_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_counter_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2counter::copy(IODEFV2counter *dst)
{
        return iodefv2_counter_copy(_priv, dst->_priv);
}



/**
 * iodefv2_counter_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2counter *IODEFV2counter::clone()
{
        int ret;
        iodefv2_counter_t *dst;
        IODEFV2counter *ptr;

        ret = iodefv2_counter_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2counter();
        iodefv2_counter_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_counter_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2counter::compare(IODEFV2counter *obj)
{
        return iodefv2_counter_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_monetary_impact_new:
 * @ret: Pointer where to store the created #iodefv2_monetary_impact_t object.
 *
 * Create a new #iodefv2_monetary_impact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2monetary_impact::IODEFV2monetary_impact()
{
        iodefv2_monetary_impact_new(&_priv);
}


/**
 * iodefv2_monetary_impact_destroy:
 * @ptr: pointer to a #iodefv2_monetary_impact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2monetary_impact::~IODEFV2monetary_impact()
{
        iodefv2_monetary_impact_destroy(_priv);
}





std::string  IODEFV2monetary_impact::get_currency()
{
        return to_string(iodefv2_monetary_impact_get_currency(_priv));
}

void IODEFV2monetary_impact::set_currency(libiodefv2_string_t *currency)
{
        iodefv2_monetary_impact_set_currency(this, currency);
}




iodefv2_monetary_impact_severity_t * IODEFV2monetary_impact::get_severity()
{
        return (iodefv2_monetary_impact_get_severity(_priv));
}

void IODEFV2monetary_impact::set_severity(iodefv2_monetary_impact_severity_t severity)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity = severity;
        ptr->severity_is_set = 1;
}


void IODEFV2monetary_impact::unset_severity()
{
        iodefv2_monetary_impact_unset_severity(_priv);
}



/**
 * iodefv2_monetary_impact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_monetary_impact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2monetary_impact::copy(IODEFV2monetary_impact *dst)
{
        return iodefv2_monetary_impact_copy(_priv, dst->_priv);
}



/**
 * iodefv2_monetary_impact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2monetary_impact *IODEFV2monetary_impact::clone()
{
        int ret;
        iodefv2_monetary_impact_t *dst;
        IODEFV2monetary_impact *ptr;

        ret = iodefv2_monetary_impact_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2monetary_impact();
        iodefv2_monetary_impact_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_monetary_impact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2monetary_impact::compare(IODEFV2monetary_impact *obj)
{
        return iodefv2_monetary_impact_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_service_name_new:
 * @ret: Pointer where to store the created #iodefv2_service_name_t object.
 *
 * Create a new #iodefv2_service_name_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2service_name::IODEFV2service_name()
{
        iodefv2_service_name_new(&_priv);
}


/**
 * iodefv2_service_name_destroy:
 * @ptr: pointer to a #iodefv2_service_name_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2service_name::~IODEFV2service_name()
{
        iodefv2_service_name_destroy(_priv);
}





std::string  IODEFV2service_name::get_url()
{
        return to_string(iodefv2_service_name_get_url(_priv));
}

void IODEFV2service_name::set_url(libiodefv2_string_t *url)
{
        iodefv2_service_name_set_url(this, url);
}




std::string  IODEFV2service_name::get_iana_service()
{
        return to_string(iodefv2_service_name_get_iana_service(_priv));
}

void IODEFV2service_name::set_iana_service(libiodefv2_string_t *iana_service)
{
        iodefv2_service_name_set_iana_service(this, iana_service);
}




std::string  IODEFV2service_name::get_description()
{
        return to_string(iodefv2_service_name_get_description(_priv));
}

void IODEFV2service_name::set_description(libiodefv2_string_t *description)
{
        iodefv2_service_name_set_description(this, description);
}



/**
 * iodefv2_service_name_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_service_name_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2service_name::copy(IODEFV2service_name *dst)
{
        return iodefv2_service_name_copy(_priv, dst->_priv);
}



/**
 * iodefv2_service_name_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2service_name *IODEFV2service_name::clone()
{
        int ret;
        iodefv2_service_name_t *dst;
        IODEFV2service_name *ptr;

        ret = iodefv2_service_name_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2service_name();
        iodefv2_service_name_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_service_name_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2service_name::compare(IODEFV2service_name *obj)
{
        return iodefv2_service_name_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_indicator_id_new:
 * @ret: Pointer where to store the created #iodefv2_indicator_id_t object.
 *
 * Create a new #iodefv2_indicator_id_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2indicator_id::IODEFV2indicator_id()
{
        iodefv2_indicator_id_new(&_priv);
}


/**
 * iodefv2_indicator_id_destroy:
 * @ptr: pointer to a #iodefv2_indicator_id_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2indicator_id::~IODEFV2indicator_id()
{
        iodefv2_indicator_id_destroy(_priv);
}





std::string  IODEFV2indicator_id::get_version()
{
        return to_string(iodefv2_indicator_id_get_version(_priv));
}

void IODEFV2indicator_id::set_version(libiodefv2_string_t *version)
{
        iodefv2_indicator_id_set_version(this, version);
}




std::string  IODEFV2indicator_id::get_name()
{
        return to_string(iodefv2_indicator_id_get_name(_priv));
}

void IODEFV2indicator_id::set_name(libiodefv2_string_t *name)
{
        iodefv2_indicator_id_set_name(this, name);
}



/**
 * iodefv2_indicator_id_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_indicator_id_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2indicator_id::copy(IODEFV2indicator_id *dst)
{
        return iodefv2_indicator_id_copy(_priv, dst->_priv);
}



/**
 * iodefv2_indicator_id_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2indicator_id *IODEFV2indicator_id::clone()
{
        int ret;
        iodefv2_indicator_id_t *dst;
        IODEFV2indicator_id *ptr;

        ret = iodefv2_indicator_id_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2indicator_id();
        iodefv2_indicator_id_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_indicator_id_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2indicator_id::compare(IODEFV2indicator_id *obj)
{
        return iodefv2_indicator_id_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_signature_data_new:
 * @ret: Pointer where to store the created #iodefv2_signature_data_t object.
 *
 * Create a new #iodefv2_signature_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2signature_data::IODEFV2signature_data()
{
        iodefv2_signature_data_new(&_priv);
}


/**
 * iodefv2_signature_data_destroy:
 * @ptr: pointer to a #iodefv2_signature_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2signature_data::~IODEFV2signature_data()
{
        iodefv2_signature_data_destroy(_priv);
}





std::string  IODEFV2signature_data::get_signature()
{
        return to_string(iodefv2_signature_data_get_signature(_priv));
}

void IODEFV2signature_data::set_signature(libiodefv2_string_t *signature)
{
        iodefv2_signature_data_set_signature(this, signature);
}



/**
 * iodefv2_signature_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_signature_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2signature_data::copy(IODEFV2signature_data *dst)
{
        return iodefv2_signature_data_copy(_priv, dst->_priv);
}



/**
 * iodefv2_signature_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2signature_data *IODEFV2signature_data::clone()
{
        int ret;
        iodefv2_signature_data_t *dst;
        IODEFV2signature_data *ptr;

        ret = iodefv2_signature_data_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2signature_data();
        iodefv2_signature_data_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_signature_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2signature_data::compare(IODEFV2signature_data *obj)
{
        return iodefv2_signature_data_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_address_new:
 * @ret: Pointer where to store the created #iodefv2_address_t object.
 *
 * Create a new #iodefv2_address_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2address::IODEFV2address()
{
        iodefv2_address_new(&_priv);
}


/**
 * iodefv2_address_destroy:
 * @ptr: pointer to a #iodefv2_address_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2address::~IODEFV2address()
{
        iodefv2_address_destroy(_priv);
}





iodefv2_address_category_t  IODEFV2address::get_category()
{
        return (iodefv2_address_get_category(_priv));
}

void IODEFV2address::set_category(iodefv2_address_category_t category)
{
        iodefv2_address_set_category(this, category);
}




std::string  IODEFV2address::get_vlan_name()
{
        return to_string(iodefv2_address_get_vlan_name(_priv));
}

void IODEFV2address::set_vlan_name(libiodefv2_string_t *vlan_name)
{
        iodefv2_address_set_vlan_name(this, vlan_name);
}




std::string  IODEFV2address::get_ext_category()
{
        return to_string(iodefv2_address_get_ext_category(_priv));
}

void IODEFV2address::set_ext_category(libiodefv2_string_t *ext_category)
{
        iodefv2_address_set_ext_category(this, ext_category);
}




std::string  IODEFV2address::get_vlan_num()
{
        return to_string(iodefv2_address_get_vlan_num(_priv));
}

void IODEFV2address::set_vlan_num(libiodefv2_string_t *vlan_num)
{
        iodefv2_address_set_vlan_num(this, vlan_num);
}




std::string  IODEFV2address::get_observable_id()
{
        return to_string(iodefv2_address_get_observable_id(_priv));
}

void IODEFV2address::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_address_set_observable_id(this, observable_id);
}



/**
 * iodefv2_address_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_address_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2address::copy(IODEFV2address *dst)
{
        return iodefv2_address_copy(_priv, dst->_priv);
}



/**
 * iodefv2_address_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2address *IODEFV2address::clone()
{
        int ret;
        iodefv2_address_t *dst;
        IODEFV2address *ptr;

        ret = iodefv2_address_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2address();
        iodefv2_address_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_address_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2address::compare(IODEFV2address *obj)
{
        return iodefv2_address_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_application_header_new:
 * @ret: Pointer where to store the created #iodefv2_application_header_t object.
 *
 * Create a new #iodefv2_application_header_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2application_header::IODEFV2application_header()
{
        iodefv2_application_header_new(&_priv);
}


/**
 * iodefv2_application_header_destroy:
 * @ptr: pointer to a #iodefv2_application_header_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2application_header::~IODEFV2application_header()
{
        iodefv2_application_header_destroy(_priv);
}




/**
 * iodefv2_application_header_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_application_header_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2application_header::copy(IODEFV2application_header *dst)
{
        return iodefv2_application_header_copy(_priv, dst->_priv);
}



/**
 * iodefv2_application_header_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2application_header *IODEFV2application_header::clone()
{
        int ret;
        iodefv2_application_header_t *dst;
        IODEFV2application_header *ptr;

        ret = iodefv2_application_header_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2application_header();
        iodefv2_application_header_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_application_header_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2application_header::compare(IODEFV2application_header *obj)
{
        return iodefv2_application_header_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_certificate_data_new:
 * @ret: Pointer where to store the created #iodefv2_certificate_data_t object.
 *
 * Create a new #iodefv2_certificate_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2certificate_data::IODEFV2certificate_data()
{
        iodefv2_certificate_data_new(&_priv);
}


/**
 * iodefv2_certificate_data_destroy:
 * @ptr: pointer to a #iodefv2_certificate_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2certificate_data::~IODEFV2certificate_data()
{
        iodefv2_certificate_data_destroy(_priv);
}





iodefv2_certificate_data_restriction_t * IODEFV2certificate_data::get_restriction()
{
        return (iodefv2_certificate_data_get_restriction(_priv));
}

void IODEFV2certificate_data::set_restriction(iodefv2_certificate_data_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2certificate_data::unset_restriction()
{
        iodefv2_certificate_data_unset_restriction(_priv);
}




std::string  IODEFV2certificate_data::get_ext_restriction()
{
        return to_string(iodefv2_certificate_data_get_ext_restriction(_priv));
}

void IODEFV2certificate_data::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_certificate_data_set_ext_restriction(this, ext_restriction);
}




std::string  IODEFV2certificate_data::get_observable_id()
{
        return to_string(iodefv2_certificate_data_get_observable_id(_priv));
}

void IODEFV2certificate_data::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_certificate_data_set_observable_id(this, observable_id);
}



/**
 * iodefv2_certificate_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_certificate_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2certificate_data::copy(IODEFV2certificate_data *dst)
{
        return iodefv2_certificate_data_copy(_priv, dst->_priv);
}



/**
 * iodefv2_certificate_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2certificate_data *IODEFV2certificate_data::clone()
{
        int ret;
        iodefv2_certificate_data_t *dst;
        IODEFV2certificate_data *ptr;

        ret = iodefv2_certificate_data_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2certificate_data();
        iodefv2_certificate_data_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_certificate_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2certificate_data::compare(IODEFV2certificate_data *obj)
{
        return iodefv2_certificate_data_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_threat_actor_new:
 * @ret: Pointer where to store the created #iodefv2_threat_actor_t object.
 *
 * Create a new #iodefv2_threat_actor_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2threat_actor::IODEFV2threat_actor()
{
        iodefv2_threat_actor_new(&_priv);
}


/**
 * iodefv2_threat_actor_destroy:
 * @ptr: pointer to a #iodefv2_threat_actor_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2threat_actor::~IODEFV2threat_actor()
{
        iodefv2_threat_actor_destroy(_priv);
}





iodefv2_threat_actor_restriction_t * IODEFV2threat_actor::get_restriction()
{
        return (iodefv2_threat_actor_get_restriction(_priv));
}

void IODEFV2threat_actor::set_restriction(iodefv2_threat_actor_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2threat_actor::unset_restriction()
{
        iodefv2_threat_actor_unset_restriction(_priv);
}




std::string  IODEFV2threat_actor::get_ext_restriction()
{
        return to_string(iodefv2_threat_actor_get_ext_restriction(_priv));
}

void IODEFV2threat_actor::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_threat_actor_set_ext_restriction(this, ext_restriction);
}




std::string  IODEFV2threat_actor::get_url()
{
        return to_string(iodefv2_threat_actor_get_url(_priv));
}

void IODEFV2threat_actor::set_url(libiodefv2_string_t *url)
{
        iodefv2_threat_actor_set_url(this, url);
}




std::string  IODEFV2threat_actor::get_threat_actor_id()
{
        return to_string(iodefv2_threat_actor_get_threat_actor_id(_priv));
}

void IODEFV2threat_actor::set_threat_actor_id(libiodefv2_string_t *threat_actor_id)
{
        iodefv2_threat_actor_set_threat_actor_id(this, threat_actor_id);
}




std::string  IODEFV2threat_actor::get_description()
{
        return to_string(iodefv2_threat_actor_get_description(_priv));
}

void IODEFV2threat_actor::set_description(libiodefv2_string_t *description)
{
        iodefv2_threat_actor_set_description(this, description);
}



/**
 * iodefv2_threat_actor_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_threat_actor_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2threat_actor::copy(IODEFV2threat_actor *dst)
{
        return iodefv2_threat_actor_copy(_priv, dst->_priv);
}



/**
 * iodefv2_threat_actor_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2threat_actor *IODEFV2threat_actor::clone()
{
        int ret;
        iodefv2_threat_actor_t *dst;
        IODEFV2threat_actor *ptr;

        ret = iodefv2_threat_actor_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2threat_actor();
        iodefv2_threat_actor_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_threat_actor_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2threat_actor::compare(IODEFV2threat_actor *obj)
{
        return iodefv2_threat_actor_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_method_new:
 * @ret: Pointer where to store the created #iodefv2_method_t object.
 *
 * Create a new #iodefv2_method_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2method::IODEFV2method()
{
        iodefv2_method_new(&_priv);
}


/**
 * iodefv2_method_destroy:
 * @ptr: pointer to a #iodefv2_method_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2method::~IODEFV2method()
{
        iodefv2_method_destroy(_priv);
}





iodefv2_method_restriction_t * IODEFV2method::get_restriction()
{
        return (iodefv2_method_get_restriction(_priv));
}

void IODEFV2method::set_restriction(iodefv2_method_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2method::unset_restriction()
{
        iodefv2_method_unset_restriction(_priv);
}




std::string  IODEFV2method::get_ext_restriction()
{
        return to_string(iodefv2_method_get_ext_restriction(_priv));
}

void IODEFV2method::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_method_set_ext_restriction(this, ext_restriction);
}




std::string  IODEFV2method::get_description()
{
        return to_string(iodefv2_method_get_description(_priv));
}

void IODEFV2method::set_description(libiodefv2_string_t *description)
{
        iodefv2_method_set_description(this, description);
}



/**
 * iodefv2_method_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_method_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2method::copy(IODEFV2method *dst)
{
        return iodefv2_method_copy(_priv, dst->_priv);
}



/**
 * iodefv2_method_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2method *IODEFV2method::clone()
{
        int ret;
        iodefv2_method_t *dst;
        IODEFV2method *ptr;

        ret = iodefv2_method_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2method();
        iodefv2_method_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_method_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2method::compare(IODEFV2method *obj)
{
        return iodefv2_method_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_alternative_id_new:
 * @ret: Pointer where to store the created #iodefv2_alternative_id_t object.
 *
 * Create a new #iodefv2_alternative_id_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2alternative_id::IODEFV2alternative_id()
{
        iodefv2_alternative_id_new(&_priv);
}


/**
 * iodefv2_alternative_id_destroy:
 * @ptr: pointer to a #iodefv2_alternative_id_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2alternative_id::~IODEFV2alternative_id()
{
        iodefv2_alternative_id_destroy(_priv);
}





iodefv2_alternative_id_restriction_t * IODEFV2alternative_id::get_restriction()
{
        return (iodefv2_alternative_id_get_restriction(_priv));
}

void IODEFV2alternative_id::set_restriction(iodefv2_alternative_id_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2alternative_id::unset_restriction()
{
        iodefv2_alternative_id_unset_restriction(_priv);
}




std::string  IODEFV2alternative_id::get_ext_restriction()
{
        return to_string(iodefv2_alternative_id_get_ext_restriction(_priv));
}

void IODEFV2alternative_id::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_alternative_id_set_ext_restriction(this, ext_restriction);
}



/**
 * iodefv2_alternative_id_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_alternative_id_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2alternative_id::copy(IODEFV2alternative_id *dst)
{
        return iodefv2_alternative_id_copy(_priv, dst->_priv);
}



/**
 * iodefv2_alternative_id_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2alternative_id *IODEFV2alternative_id::clone()
{
        int ret;
        iodefv2_alternative_id_t *dst;
        IODEFV2alternative_id *ptr;

        ret = iodefv2_alternative_id_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2alternative_id();
        iodefv2_alternative_id_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_alternative_id_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2alternative_id::compare(IODEFV2alternative_id *obj)
{
        return iodefv2_alternative_id_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_software_new:
 * @ret: Pointer where to store the created #iodefv2_software_t object.
 *
 * Create a new #iodefv2_software_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2software::IODEFV2software()
{
        iodefv2_software_new(&_priv);
}


/**
 * iodefv2_software_destroy:
 * @ptr: pointer to a #iodefv2_software_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2software::~IODEFV2software()
{
        iodefv2_software_destroy(_priv);
}





std::string  IODEFV2software::get_url()
{
        return to_string(iodefv2_software_get_url(_priv));
}

void IODEFV2software::set_url(libiodefv2_string_t *url)
{
        iodefv2_software_set_url(this, url);
}




std::string  IODEFV2software::get_description()
{
        return to_string(iodefv2_software_get_description(_priv));
}

void IODEFV2software::set_description(libiodefv2_string_t *description)
{
        iodefv2_software_set_description(this, description);
}




iodefv2_software_reference_t  IODEFV2software::get_software_reference()
{
        return (iodefv2_software_get_software_reference(_priv));
}

void IODEFV2software::set_software_reference(iodefv2_software_reference_t *software_reference)
{
        iodefv2_software_set_software_reference(this, software_reference);
}



/**
 * iodefv2_software_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_software_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2software::copy(IODEFV2software *dst)
{
        return iodefv2_software_copy(_priv, dst->_priv);
}



/**
 * iodefv2_software_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2software *IODEFV2software::clone()
{
        int ret;
        iodefv2_software_t *dst;
        IODEFV2software *ptr;

        ret = iodefv2_software_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2software();
        iodefv2_software_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_software_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2software::compare(IODEFV2software *obj)
{
        return iodefv2_software_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_nameservers_new:
 * @ret: Pointer where to store the created #iodefv2_nameservers_t object.
 *
 * Create a new #iodefv2_nameservers_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2nameservers::IODEFV2nameservers()
{
        iodefv2_nameservers_new(&_priv);
}


/**
 * iodefv2_nameservers_destroy:
 * @ptr: pointer to a #iodefv2_nameservers_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2nameservers::~IODEFV2nameservers()
{
        iodefv2_nameservers_destroy(_priv);
}





std::string  IODEFV2nameservers::get_server()
{
        return to_string(iodefv2_nameservers_get_server(_priv));
}

void IODEFV2nameservers::set_server(libiodefv2_string_t *server)
{
        iodefv2_nameservers_set_server(this, server);
}



/**
 * iodefv2_nameservers_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_nameservers_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2nameservers::copy(IODEFV2nameservers *dst)
{
        return iodefv2_nameservers_copy(_priv, dst->_priv);
}



/**
 * iodefv2_nameservers_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2nameservers *IODEFV2nameservers::clone()
{
        int ret;
        iodefv2_nameservers_t *dst;
        IODEFV2nameservers *ptr;

        ret = iodefv2_nameservers_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2nameservers();
        iodefv2_nameservers_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_nameservers_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2nameservers::compare(IODEFV2nameservers *obj)
{
        return iodefv2_nameservers_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_windows_registry_keys_modified_new:
 * @ret: Pointer where to store the created #iodefv2_windows_registry_keys_modified_t object.
 *
 * Create a new #iodefv2_windows_registry_keys_modified_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2windows_registry_keys_modified::IODEFV2windows_registry_keys_modified()
{
        iodefv2_windows_registry_keys_modified_new(&_priv);
}


/**
 * iodefv2_windows_registry_keys_modified_destroy:
 * @ptr: pointer to a #iodefv2_windows_registry_keys_modified_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2windows_registry_keys_modified::~IODEFV2windows_registry_keys_modified()
{
        iodefv2_windows_registry_keys_modified_destroy(_priv);
}





std::string  IODEFV2windows_registry_keys_modified::get_observable_id()
{
        return to_string(iodefv2_windows_registry_keys_modified_get_observable_id(_priv));
}

void IODEFV2windows_registry_keys_modified::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_windows_registry_keys_modified_set_observable_id(this, observable_id);
}



/**
 * iodefv2_windows_registry_keys_modified_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_windows_registry_keys_modified_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2windows_registry_keys_modified::copy(IODEFV2windows_registry_keys_modified *dst)
{
        return iodefv2_windows_registry_keys_modified_copy(_priv, dst->_priv);
}



/**
 * iodefv2_windows_registry_keys_modified_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2windows_registry_keys_modified *IODEFV2windows_registry_keys_modified::clone()
{
        int ret;
        iodefv2_windows_registry_keys_modified_t *dst;
        IODEFV2windows_registry_keys_modified *ptr;

        ret = iodefv2_windows_registry_keys_modified_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2windows_registry_keys_modified();
        iodefv2_windows_registry_keys_modified_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_windows_registry_keys_modified_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2windows_registry_keys_modified::compare(IODEFV2windows_registry_keys_modified *obj)
{
        return iodefv2_windows_registry_keys_modified_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_campaign_new:
 * @ret: Pointer where to store the created #iodefv2_campaign_t object.
 *
 * Create a new #iodefv2_campaign_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2campaign::IODEFV2campaign()
{
        iodefv2_campaign_new(&_priv);
}


/**
 * iodefv2_campaign_destroy:
 * @ptr: pointer to a #iodefv2_campaign_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2campaign::~IODEFV2campaign()
{
        iodefv2_campaign_destroy(_priv);
}





iodefv2_campaign_restriction_t * IODEFV2campaign::get_restriction()
{
        return (iodefv2_campaign_get_restriction(_priv));
}

void IODEFV2campaign::set_restriction(iodefv2_campaign_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2campaign::unset_restriction()
{
        iodefv2_campaign_unset_restriction(_priv);
}




std::string  IODEFV2campaign::get_ext_restriction()
{
        return to_string(iodefv2_campaign_get_ext_restriction(_priv));
}

void IODEFV2campaign::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_campaign_set_ext_restriction(this, ext_restriction);
}




std::string  IODEFV2campaign::get_url()
{
        return to_string(iodefv2_campaign_get_url(_priv));
}

void IODEFV2campaign::set_url(libiodefv2_string_t *url)
{
        iodefv2_campaign_set_url(this, url);
}




std::string  IODEFV2campaign::get_description()
{
        return to_string(iodefv2_campaign_get_description(_priv));
}

void IODEFV2campaign::set_description(libiodefv2_string_t *description)
{
        iodefv2_campaign_set_description(this, description);
}




std::string  IODEFV2campaign::get_campaign_id()
{
        return to_string(iodefv2_campaign_get_campaign_id(_priv));
}

void IODEFV2campaign::set_campaign_id(libiodefv2_string_t *campaign_id)
{
        iodefv2_campaign_set_campaign_id(this, campaign_id);
}



/**
 * iodefv2_campaign_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_campaign_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2campaign::copy(IODEFV2campaign *dst)
{
        return iodefv2_campaign_copy(_priv, dst->_priv);
}



/**
 * iodefv2_campaign_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2campaign *IODEFV2campaign::clone()
{
        int ret;
        iodefv2_campaign_t *dst;
        IODEFV2campaign *ptr;

        ret = iodefv2_campaign_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2campaign();
        iodefv2_campaign_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_campaign_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2campaign::compare(IODEFV2campaign *obj)
{
        return iodefv2_campaign_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_assessment_new:
 * @ret: Pointer where to store the created #iodefv2_assessment_t object.
 *
 * Create a new #iodefv2_assessment_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2assessment::IODEFV2assessment()
{
        iodefv2_assessment_new(&_priv);
}


/**
 * iodefv2_assessment_destroy:
 * @ptr: pointer to a #iodefv2_assessment_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2assessment::~IODEFV2assessment()
{
        iodefv2_assessment_destroy(_priv);
}





iodefv2_assessment_restriction_t * IODEFV2assessment::get_restriction()
{
        return (iodefv2_assessment_get_restriction(_priv));
}

void IODEFV2assessment::set_restriction(iodefv2_assessment_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2assessment::unset_restriction()
{
        iodefv2_assessment_unset_restriction(_priv);
}




std::string  IODEFV2assessment::get_ext_restriction()
{
        return to_string(iodefv2_assessment_get_ext_restriction(_priv));
}

void IODEFV2assessment::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_assessment_set_ext_restriction(this, ext_restriction);
}




iodefv2_assessment_occurrence_t * IODEFV2assessment::get_occurrence()
{
        return (iodefv2_assessment_get_occurrence(_priv));
}

void IODEFV2assessment::set_occurrence(iodefv2_assessment_occurrence_t occurrence)
{
        libiodefv2_return_if_fail(ptr);
        ptr->occurrence = occurrence;
        ptr->occurrence_is_set = 1;
}


void IODEFV2assessment::unset_occurrence()
{
        iodefv2_assessment_unset_occurrence(_priv);
}




std::string  IODEFV2assessment::get_observable_id()
{
        return to_string(iodefv2_assessment_get_observable_id(_priv));
}

void IODEFV2assessment::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_assessment_set_observable_id(this, observable_id);
}




iodefv2_confidence_t  IODEFV2assessment::get_confidence()
{
        return (iodefv2_assessment_get_confidence(_priv));
}

void IODEFV2assessment::set_confidence(iodefv2_confidence_t *confidence)
{
        iodefv2_assessment_set_confidence(this, confidence);
}




std::string  IODEFV2assessment::get_incident_category()
{
        return to_string(iodefv2_assessment_get_incident_category(_priv));
}

void IODEFV2assessment::set_incident_category(libiodefv2_string_t *incident_category)
{
        iodefv2_assessment_set_incident_category(this, incident_category);
}




std::string  IODEFV2assessment::get_mitigating_factor()
{
        return to_string(iodefv2_assessment_get_mitigating_factor(_priv));
}

void IODEFV2assessment::set_mitigating_factor(libiodefv2_string_t *mitigating_factor)
{
        iodefv2_assessment_set_mitigating_factor(this, mitigating_factor);
}




std::string  IODEFV2assessment::get_cause()
{
        return to_string(iodefv2_assessment_get_cause(_priv));
}

void IODEFV2assessment::set_cause(libiodefv2_string_t *cause)
{
        iodefv2_assessment_set_cause(this, cause);
}



/**
 * iodefv2_assessment_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_assessment_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2assessment::copy(IODEFV2assessment *dst)
{
        return iodefv2_assessment_copy(_priv, dst->_priv);
}



/**
 * iodefv2_assessment_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2assessment *IODEFV2assessment::clone()
{
        int ret;
        iodefv2_assessment_t *dst;
        IODEFV2assessment *ptr;

        ret = iodefv2_assessment_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2assessment();
        iodefv2_assessment_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_assessment_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2assessment::compare(IODEFV2assessment *obj)
{
        return iodefv2_assessment_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_attack_phase_new:
 * @ret: Pointer where to store the created #iodefv2_attack_phase_t object.
 *
 * Create a new #iodefv2_attack_phase_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2attack_phase::IODEFV2attack_phase()
{
        iodefv2_attack_phase_new(&_priv);
}


/**
 * iodefv2_attack_phase_destroy:
 * @ptr: pointer to a #iodefv2_attack_phase_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2attack_phase::~IODEFV2attack_phase()
{
        iodefv2_attack_phase_destroy(_priv);
}





std::string  IODEFV2attack_phase::get_url()
{
        return to_string(iodefv2_attack_phase_get_url(_priv));
}

void IODEFV2attack_phase::set_url(libiodefv2_string_t *url)
{
        iodefv2_attack_phase_set_url(this, url);
}




std::string  IODEFV2attack_phase::get_description()
{
        return to_string(iodefv2_attack_phase_get_description(_priv));
}

void IODEFV2attack_phase::set_description(libiodefv2_string_t *description)
{
        iodefv2_attack_phase_set_description(this, description);
}




std::string  IODEFV2attack_phase::get_attack_phase_id()
{
        return to_string(iodefv2_attack_phase_get_attack_phase_id(_priv));
}

void IODEFV2attack_phase::set_attack_phase_id(libiodefv2_string_t *attack_phase_id)
{
        iodefv2_attack_phase_set_attack_phase_id(this, attack_phase_id);
}



/**
 * iodefv2_attack_phase_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_attack_phase_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2attack_phase::copy(IODEFV2attack_phase *dst)
{
        return iodefv2_attack_phase_copy(_priv, dst->_priv);
}



/**
 * iodefv2_attack_phase_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2attack_phase *IODEFV2attack_phase::clone()
{
        int ret;
        iodefv2_attack_phase_t *dst;
        IODEFV2attack_phase *ptr;

        ret = iodefv2_attack_phase_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2attack_phase();
        iodefv2_attack_phase_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_attack_phase_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2attack_phase::compare(IODEFV2attack_phase *obj)
{
        return iodefv2_attack_phase_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_contact_new:
 * @ret: Pointer where to store the created #iodefv2_contact_t object.
 *
 * Create a new #iodefv2_contact_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2contact::IODEFV2contact()
{
        iodefv2_contact_new(&_priv);
}


/**
 * iodefv2_contact_destroy:
 * @ptr: pointer to a #iodefv2_contact_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2contact::~IODEFV2contact()
{
        iodefv2_contact_destroy(_priv);
}





iodefv2_contact_restriction_t * IODEFV2contact::get_restriction()
{
        return (iodefv2_contact_get_restriction(_priv));
}

void IODEFV2contact::set_restriction(iodefv2_contact_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2contact::unset_restriction()
{
        iodefv2_contact_unset_restriction(_priv);
}




iodefv2_contact_role_t  IODEFV2contact::get_role()
{
        return (iodefv2_contact_get_role(_priv));
}

void IODEFV2contact::set_role(iodefv2_contact_role_t role)
{
        iodefv2_contact_set_role(this, role);
}




std::string  IODEFV2contact::get_ext_type()
{
        return to_string(iodefv2_contact_get_ext_type(_priv));
}

void IODEFV2contact::set_ext_type(libiodefv2_string_t *ext_type)
{
        iodefv2_contact_set_ext_type(this, ext_type);
}




std::string  IODEFV2contact::get_ext_role()
{
        return to_string(iodefv2_contact_get_ext_role(_priv));
}

void IODEFV2contact::set_ext_role(libiodefv2_string_t *ext_role)
{
        iodefv2_contact_set_ext_role(this, ext_role);
}




std::string  IODEFV2contact::get_ext_restriction()
{
        return to_string(iodefv2_contact_get_ext_restriction(_priv));
}

void IODEFV2contact::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_contact_set_ext_restriction(this, ext_restriction);
}




iodefv2_contact_type_t  IODEFV2contact::get_type()
{
        return (iodefv2_contact_get_type(_priv));
}

void IODEFV2contact::set_type(iodefv2_contact_type_t type)
{
        iodefv2_contact_set_type(this, type);
}




std::string  IODEFV2contact::get_contact_title()
{
        return to_string(iodefv2_contact_get_contact_title(_priv));
}

void IODEFV2contact::set_contact_title(libiodefv2_string_t *contact_title)
{
        iodefv2_contact_set_contact_title(this, contact_title);
}




std::string  IODEFV2contact::get_description()
{
        return to_string(iodefv2_contact_get_description(_priv));
}

void IODEFV2contact::set_description(libiodefv2_string_t *description)
{
        iodefv2_contact_set_description(this, description);
}




std::string  IODEFV2contact::get_contact_name()
{
        return to_string(iodefv2_contact_get_contact_name(_priv));
}

void IODEFV2contact::set_contact_name(libiodefv2_string_t *contact_name)
{
        iodefv2_contact_set_contact_name(this, contact_name);
}




std::string  IODEFV2contact::get_timezone()
{
        return to_string(iodefv2_contact_get_timezone(_priv));
}

void IODEFV2contact::set_timezone(libiodefv2_string_t *timezone)
{
        iodefv2_contact_set_timezone(this, timezone);
}



/**
 * iodefv2_contact_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_contact_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2contact::copy(IODEFV2contact *dst)
{
        return iodefv2_contact_copy(_priv, dst->_priv);
}



/**
 * iodefv2_contact_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2contact *IODEFV2contact::clone()
{
        int ret;
        iodefv2_contact_t *dst;
        IODEFV2contact *ptr;

        ret = iodefv2_contact_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2contact();
        iodefv2_contact_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_contact_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2contact::compare(IODEFV2contact *obj)
{
        return iodefv2_contact_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_related_activity_new:
 * @ret: Pointer where to store the created #iodefv2_related_activity_t object.
 *
 * Create a new #iodefv2_related_activity_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2related_activity::IODEFV2related_activity()
{
        iodefv2_related_activity_new(&_priv);
}


/**
 * iodefv2_related_activity_destroy:
 * @ptr: pointer to a #iodefv2_related_activity_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2related_activity::~IODEFV2related_activity()
{
        iodefv2_related_activity_destroy(_priv);
}





iodefv2_related_activity_restriction_t * IODEFV2related_activity::get_restriction()
{
        return (iodefv2_related_activity_get_restriction(_priv));
}

void IODEFV2related_activity::set_restriction(iodefv2_related_activity_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2related_activity::unset_restriction()
{
        iodefv2_related_activity_unset_restriction(_priv);
}




std::string  IODEFV2related_activity::get_ext_restriction()
{
        return to_string(iodefv2_related_activity_get_ext_restriction(_priv));
}

void IODEFV2related_activity::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_related_activity_set_ext_restriction(this, ext_restriction);
}




iodefv2_confidence_t  IODEFV2related_activity::get_confidence()
{
        return (iodefv2_related_activity_get_confidence(_priv));
}

void IODEFV2related_activity::set_confidence(iodefv2_confidence_t *confidence)
{
        iodefv2_related_activity_set_confidence(this, confidence);
}




std::string  IODEFV2related_activity::get_description()
{
        return to_string(iodefv2_related_activity_get_description(_priv));
}

void IODEFV2related_activity::set_description(libiodefv2_string_t *description)
{
        iodefv2_related_activity_set_description(this, description);
}




std::string  IODEFV2related_activity::get_url()
{
        return to_string(iodefv2_related_activity_get_url(_priv));
}

void IODEFV2related_activity::set_url(libiodefv2_string_t *url)
{
        iodefv2_related_activity_set_url(this, url);
}



/**
 * iodefv2_related_activity_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_related_activity_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2related_activity::copy(IODEFV2related_activity *dst)
{
        return iodefv2_related_activity_copy(_priv, dst->_priv);
}



/**
 * iodefv2_related_activity_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2related_activity *IODEFV2related_activity::clone()
{
        int ret;
        iodefv2_related_activity_t *dst;
        IODEFV2related_activity *ptr;

        ret = iodefv2_related_activity_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2related_activity();
        iodefv2_related_activity_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_related_activity_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2related_activity::compare(IODEFV2related_activity *obj)
{
        return iodefv2_related_activity_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_domain_contacts_new:
 * @ret: Pointer where to store the created #iodefv2_domain_contacts_t object.
 *
 * Create a new #iodefv2_domain_contacts_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2domain_contacts::IODEFV2domain_contacts()
{
        iodefv2_domain_contacts_new(&_priv);
}


/**
 * iodefv2_domain_contacts_destroy:
 * @ptr: pointer to a #iodefv2_domain_contacts_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2domain_contacts::~IODEFV2domain_contacts()
{
        iodefv2_domain_contacts_destroy(_priv);
}





std::string  IODEFV2domain_contacts::get_same_domain_contact()
{
        return to_string(iodefv2_domain_contacts_get_same_domain_contact(_priv));
}

void IODEFV2domain_contacts::set_same_domain_contact(libiodefv2_string_t *same_domain_contact)
{
        iodefv2_domain_contacts_set_same_domain_contact(this, same_domain_contact);
}



/**
 * iodefv2_domain_contacts_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_domain_contacts_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2domain_contacts::copy(IODEFV2domain_contacts *dst)
{
        return iodefv2_domain_contacts_copy(_priv, dst->_priv);
}



/**
 * iodefv2_domain_contacts_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2domain_contacts *IODEFV2domain_contacts::clone()
{
        int ret;
        iodefv2_domain_contacts_t *dst;
        IODEFV2domain_contacts *ptr;

        ret = iodefv2_domain_contacts_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2domain_contacts();
        iodefv2_domain_contacts_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_domain_contacts_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2domain_contacts::compare(IODEFV2domain_contacts *obj)
{
        return iodefv2_domain_contacts_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_history_item_new:
 * @ret: Pointer where to store the created #iodefv2_history_item_t object.
 *
 * Create a new #iodefv2_history_item_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2history_item::IODEFV2history_item()
{
        iodefv2_history_item_new(&_priv);
}


/**
 * iodefv2_history_item_destroy:
 * @ptr: pointer to a #iodefv2_history_item_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2history_item::~IODEFV2history_item()
{
        iodefv2_history_item_destroy(_priv);
}





iodefv2_history_item_action_t  IODEFV2history_item::get_action()
{
        return (iodefv2_history_item_get_action(_priv));
}

void IODEFV2history_item::set_action(iodefv2_history_item_action_t action)
{
        iodefv2_history_item_set_action(this, action);
}




iodefv2_history_item_restriction_t * IODEFV2history_item::get_restriction()
{
        return (iodefv2_history_item_get_restriction(_priv));
}

void IODEFV2history_item::set_restriction(iodefv2_history_item_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2history_item::unset_restriction()
{
        iodefv2_history_item_unset_restriction(_priv);
}




std::string  IODEFV2history_item::get_ext_action()
{
        return to_string(iodefv2_history_item_get_ext_action(_priv));
}

void IODEFV2history_item::set_ext_action(libiodefv2_string_t *ext_action)
{
        iodefv2_history_item_set_ext_action(this, ext_action);
}




std::string  IODEFV2history_item::get_ext_restriction()
{
        return to_string(iodefv2_history_item_get_ext_restriction(_priv));
}

void IODEFV2history_item::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_history_item_set_ext_restriction(this, ext_restriction);
}




std::string  IODEFV2history_item::get_observable_id()
{
        return to_string(iodefv2_history_item_get_observable_id(_priv));
}

void IODEFV2history_item::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_history_item_set_observable_id(this, observable_id);
}




iodefv2_contact_t  IODEFV2history_item::get_contact()
{
        return (iodefv2_history_item_get_contact(_priv));
}

void IODEFV2history_item::set_contact(iodefv2_contact_t *contact)
{
        iodefv2_history_item_set_contact(this, contact);
}




std::string  IODEFV2history_item::get_defined_coa()
{
        return to_string(iodefv2_history_item_get_defined_coa(_priv));
}

void IODEFV2history_item::set_defined_coa(libiodefv2_string_t *defined_coa)
{
        iodefv2_history_item_set_defined_coa(this, defined_coa);
}




std::string  IODEFV2history_item::get_description()
{
        return to_string(iodefv2_history_item_get_description(_priv));
}

void IODEFV2history_item::set_description(libiodefv2_string_t *description)
{
        iodefv2_history_item_set_description(this, description);
}




iodefv2_incident_id_t  IODEFV2history_item::get_incident_id()
{
        return (iodefv2_history_item_get_incident_id(_priv));
}

void IODEFV2history_item::set_incident_id(iodefv2_incident_id_t *incident_id)
{
        iodefv2_history_item_set_incident_id(this, incident_id);
}




iodefv2_time_t  IODEFV2history_item::get_date_time()
{
        return (iodefv2_history_item_get_date_time(_priv));
}

void IODEFV2history_item::set_date_time(iodefv2_time_t *date_time)
{
        iodefv2_history_item_set_date_time(this, date_time);
}



/**
 * iodefv2_history_item_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_history_item_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2history_item::copy(IODEFV2history_item *dst)
{
        return iodefv2_history_item_copy(_priv, dst->_priv);
}



/**
 * iodefv2_history_item_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2history_item *IODEFV2history_item::clone()
{
        int ret;
        iodefv2_history_item_t *dst;
        IODEFV2history_item *ptr;

        ret = iodefv2_history_item_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2history_item();
        iodefv2_history_item_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_history_item_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2history_item::compare(IODEFV2history_item *obj)
{
        return iodefv2_history_item_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_fuzzy_hash_new:
 * @ret: Pointer where to store the created #iodefv2_fuzzy_hash_t object.
 *
 * Create a new #iodefv2_fuzzy_hash_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2fuzzy_hash::IODEFV2fuzzy_hash()
{
        iodefv2_fuzzy_hash_new(&_priv);
}


/**
 * iodefv2_fuzzy_hash_destroy:
 * @ptr: pointer to a #iodefv2_fuzzy_hash_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2fuzzy_hash::~IODEFV2fuzzy_hash()
{
        iodefv2_fuzzy_hash_destroy(_priv);
}





iodefv2_software_t  IODEFV2fuzzy_hash::get_software()
{
        return (iodefv2_fuzzy_hash_get_software(_priv));
}

void IODEFV2fuzzy_hash::set_software(iodefv2_software_t *software)
{
        iodefv2_fuzzy_hash_set_software(this, software);
}



/**
 * iodefv2_fuzzy_hash_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_fuzzy_hash_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2fuzzy_hash::copy(IODEFV2fuzzy_hash *dst)
{
        return iodefv2_fuzzy_hash_copy(_priv, dst->_priv);
}



/**
 * iodefv2_fuzzy_hash_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2fuzzy_hash *IODEFV2fuzzy_hash::clone()
{
        int ret;
        iodefv2_fuzzy_hash_t *dst;
        IODEFV2fuzzy_hash *ptr;

        ret = iodefv2_fuzzy_hash_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2fuzzy_hash();
        iodefv2_fuzzy_hash_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_fuzzy_hash_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2fuzzy_hash::compare(IODEFV2fuzzy_hash *obj)
{
        return iodefv2_fuzzy_hash_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_hash_new:
 * @ret: Pointer where to store the created #iodefv2_hash_t object.
 *
 * Create a new #iodefv2_hash_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2hash::IODEFV2hash()
{
        iodefv2_hash_new(&_priv);
}


/**
 * iodefv2_hash_destroy:
 * @ptr: pointer to a #iodefv2_hash_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2hash::~IODEFV2hash()
{
        iodefv2_hash_destroy(_priv);
}





std::string  IODEFV2hash::get_digest_value()
{
        return to_string(iodefv2_hash_get_digest_value(_priv));
}

void IODEFV2hash::set_digest_value(libiodefv2_string_t *digest_value)
{
        iodefv2_hash_set_digest_value(this, digest_value);
}




std::string  IODEFV2hash::get_digest_method()
{
        return to_string(iodefv2_hash_get_digest_method(_priv));
}

void IODEFV2hash::set_digest_method(libiodefv2_string_t *digest_method)
{
        iodefv2_hash_set_digest_method(this, digest_method);
}




std::string  IODEFV2hash::get_canonicalization_method()
{
        return to_string(iodefv2_hash_get_canonicalization_method(_priv));
}

void IODEFV2hash::set_canonicalization_method(libiodefv2_string_t *canonicalization_method)
{
        iodefv2_hash_set_canonicalization_method(this, canonicalization_method);
}




iodefv2_software_t  IODEFV2hash::get_software()
{
        return (iodefv2_hash_get_software(_priv));
}

void IODEFV2hash::set_software(iodefv2_software_t *software)
{
        iodefv2_hash_set_software(this, software);
}



/**
 * iodefv2_hash_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_hash_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2hash::copy(IODEFV2hash *dst)
{
        return iodefv2_hash_copy(_priv, dst->_priv);
}



/**
 * iodefv2_hash_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2hash *IODEFV2hash::clone()
{
        int ret;
        iodefv2_hash_t *dst;
        IODEFV2hash *ptr;

        ret = iodefv2_hash_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2hash();
        iodefv2_hash_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_hash_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2hash::compare(IODEFV2hash *obj)
{
        return iodefv2_hash_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_detection_pattern_new:
 * @ret: Pointer where to store the created #iodefv2_detection_pattern_t object.
 *
 * Create a new #iodefv2_detection_pattern_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2detection_pattern::IODEFV2detection_pattern()
{
        iodefv2_detection_pattern_new(&_priv);
}


/**
 * iodefv2_detection_pattern_destroy:
 * @ptr: pointer to a #iodefv2_detection_pattern_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2detection_pattern::~IODEFV2detection_pattern()
{
        iodefv2_detection_pattern_destroy(_priv);
}





iodefv2_detection_pattern_restriction_t * IODEFV2detection_pattern::get_restriction()
{
        return (iodefv2_detection_pattern_get_restriction(_priv));
}

void IODEFV2detection_pattern::set_restriction(iodefv2_detection_pattern_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2detection_pattern::unset_restriction()
{
        iodefv2_detection_pattern_unset_restriction(_priv);
}




std::string  IODEFV2detection_pattern::get_ext_restriction()
{
        return to_string(iodefv2_detection_pattern_get_ext_restriction(_priv));
}

void IODEFV2detection_pattern::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_detection_pattern_set_ext_restriction(this, ext_restriction);
}




std::string  IODEFV2detection_pattern::get_observable_id()
{
        return to_string(iodefv2_detection_pattern_get_observable_id(_priv));
}

void IODEFV2detection_pattern::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_detection_pattern_set_observable_id(this, observable_id);
}




std::string  IODEFV2detection_pattern::get_detection_configuration()
{
        return to_string(iodefv2_detection_pattern_get_detection_configuration(_priv));
}

void IODEFV2detection_pattern::set_detection_configuration(libiodefv2_string_t *detection_configuration)
{
        iodefv2_detection_pattern_set_detection_configuration(this, detection_configuration);
}




std::string  IODEFV2detection_pattern::get_description()
{
        return to_string(iodefv2_detection_pattern_get_description(_priv));
}

void IODEFV2detection_pattern::set_description(libiodefv2_string_t *description)
{
        iodefv2_detection_pattern_set_description(this, description);
}




iodefv2_software_t  IODEFV2detection_pattern::get_software()
{
        return (iodefv2_detection_pattern_get_software(_priv));
}

void IODEFV2detection_pattern::set_software(iodefv2_software_t *software)
{
        iodefv2_detection_pattern_set_software(this, software);
}



/**
 * iodefv2_detection_pattern_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_detection_pattern_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2detection_pattern::copy(IODEFV2detection_pattern *dst)
{
        return iodefv2_detection_pattern_copy(_priv, dst->_priv);
}



/**
 * iodefv2_detection_pattern_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2detection_pattern *IODEFV2detection_pattern::clone()
{
        int ret;
        iodefv2_detection_pattern_t *dst;
        IODEFV2detection_pattern *ptr;

        ret = iodefv2_detection_pattern_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2detection_pattern();
        iodefv2_detection_pattern_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_detection_pattern_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2detection_pattern::compare(IODEFV2detection_pattern *obj)
{
        return iodefv2_detection_pattern_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_expectation_new:
 * @ret: Pointer where to store the created #iodefv2_expectation_t object.
 *
 * Create a new #iodefv2_expectation_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2expectation::IODEFV2expectation()
{
        iodefv2_expectation_new(&_priv);
}


/**
 * iodefv2_expectation_destroy:
 * @ptr: pointer to a #iodefv2_expectation_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2expectation::~IODEFV2expectation()
{
        iodefv2_expectation_destroy(_priv);
}





iodefv2_expectation_restriction_t * IODEFV2expectation::get_restriction()
{
        return (iodefv2_expectation_get_restriction(_priv));
}

void IODEFV2expectation::set_restriction(iodefv2_expectation_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2expectation::unset_restriction()
{
        iodefv2_expectation_unset_restriction(_priv);
}




std::string  IODEFV2expectation::get_ext_action()
{
        return to_string(iodefv2_expectation_get_ext_action(_priv));
}

void IODEFV2expectation::set_ext_action(libiodefv2_string_t *ext_action)
{
        iodefv2_expectation_set_ext_action(this, ext_action);
}




std::string  IODEFV2expectation::get_ext_severity()
{
        return to_string(iodefv2_expectation_get_ext_severity(_priv));
}

void IODEFV2expectation::set_ext_severity(libiodefv2_string_t *ext_severity)
{
        iodefv2_expectation_set_ext_severity(this, ext_severity);
}




iodefv2_expectation_severity_t * IODEFV2expectation::get_severity()
{
        return (iodefv2_expectation_get_severity(_priv));
}

void IODEFV2expectation::set_severity(iodefv2_expectation_severity_t severity)
{
        libiodefv2_return_if_fail(ptr);
        ptr->severity = severity;
        ptr->severity_is_set = 1;
}


void IODEFV2expectation::unset_severity()
{
        iodefv2_expectation_unset_severity(_priv);
}




iodefv2_expectation_action_t * IODEFV2expectation::get_action()
{
        return (iodefv2_expectation_get_action(_priv));
}

void IODEFV2expectation::set_action(iodefv2_expectation_action_t action)
{
        libiodefv2_return_if_fail(ptr);
        ptr->action = action;
        ptr->action_is_set = 1;
}


void IODEFV2expectation::unset_action()
{
        iodefv2_expectation_unset_action(_priv);
}




std::string  IODEFV2expectation::get_ext_restriction()
{
        return to_string(iodefv2_expectation_get_ext_restriction(_priv));
}

void IODEFV2expectation::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_expectation_set_ext_restriction(this, ext_restriction);
}




iodefv2_time_t  IODEFV2expectation::get_end_time()
{
        return (iodefv2_expectation_get_end_time(_priv));
}

void IODEFV2expectation::set_end_time(iodefv2_time_t *end_time)
{
        iodefv2_expectation_set_end_time(this, end_time);
}




std::string  IODEFV2expectation::get_defined_coa()
{
        return to_string(iodefv2_expectation_get_defined_coa(_priv));
}

void IODEFV2expectation::set_defined_coa(libiodefv2_string_t *defined_coa)
{
        iodefv2_expectation_set_defined_coa(this, defined_coa);
}




std::string  IODEFV2expectation::get_description()
{
        return to_string(iodefv2_expectation_get_description(_priv));
}

void IODEFV2expectation::set_description(libiodefv2_string_t *description)
{
        iodefv2_expectation_set_description(this, description);
}




iodefv2_time_t  IODEFV2expectation::get_start_time()
{
        return (iodefv2_expectation_get_start_time(_priv));
}

void IODEFV2expectation::set_start_time(iodefv2_time_t *start_time)
{
        iodefv2_expectation_set_start_time(this, start_time);
}




iodefv2_contact_t  IODEFV2expectation::get_contact()
{
        return (iodefv2_expectation_get_contact(_priv));
}

void IODEFV2expectation::set_contact(iodefv2_contact_t *contact)
{
        iodefv2_expectation_set_contact(this, contact);
}



/**
 * iodefv2_expectation_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_expectation_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2expectation::copy(IODEFV2expectation *dst)
{
        return iodefv2_expectation_copy(_priv, dst->_priv);
}



/**
 * iodefv2_expectation_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2expectation *IODEFV2expectation::clone()
{
        int ret;
        iodefv2_expectation_t *dst;
        IODEFV2expectation *ptr;

        ret = iodefv2_expectation_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2expectation();
        iodefv2_expectation_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_expectation_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2expectation::compare(IODEFV2expectation *obj)
{
        return iodefv2_expectation_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_domain_data_new:
 * @ret: Pointer where to store the created #iodefv2_domain_data_t object.
 *
 * Create a new #iodefv2_domain_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2domain_data::IODEFV2domain_data()
{
        iodefv2_domain_data_new(&_priv);
}


/**
 * iodefv2_domain_data_destroy:
 * @ptr: pointer to a #iodefv2_domain_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2domain_data::~IODEFV2domain_data()
{
        iodefv2_domain_data_destroy(_priv);
}





std::string  IODEFV2domain_data::get_ext_domain_status()
{
        return to_string(iodefv2_domain_data_get_ext_domain_status(_priv));
}

void IODEFV2domain_data::set_ext_domain_status(libiodefv2_string_t *ext_domain_status)
{
        iodefv2_domain_data_set_ext_domain_status(this, ext_domain_status);
}




iodefv2_domain_data_domain_status_t  IODEFV2domain_data::get_domain_status()
{
        return (iodefv2_domain_data_get_domain_status(_priv));
}

void IODEFV2domain_data::set_domain_status(iodefv2_domain_data_domain_status_t domain_status)
{
        iodefv2_domain_data_set_domain_status(this, domain_status);
}




std::string  IODEFV2domain_data::get_ext_system_status()
{
        return to_string(iodefv2_domain_data_get_ext_system_status(_priv));
}

void IODEFV2domain_data::set_ext_system_status(libiodefv2_string_t *ext_system_status)
{
        iodefv2_domain_data_set_ext_system_status(this, ext_system_status);
}




std::string  IODEFV2domain_data::get_observable_id()
{
        return to_string(iodefv2_domain_data_get_observable_id(_priv));
}

void IODEFV2domain_data::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_domain_data_set_observable_id(this, observable_id);
}




iodefv2_domain_data_system_status_t  IODEFV2domain_data::get_system_status()
{
        return (iodefv2_domain_data_get_system_status(_priv));
}

void IODEFV2domain_data::set_system_status(iodefv2_domain_data_system_status_t system_status)
{
        iodefv2_domain_data_set_system_status(this, system_status);
}




std::string  IODEFV2domain_data::get_name()
{
        return to_string(iodefv2_domain_data_get_name(_priv));
}

void IODEFV2domain_data::set_name(libiodefv2_string_t *name)
{
        iodefv2_domain_data_set_name(this, name);
}




iodefv2_time_t  IODEFV2domain_data::get_registration_date()
{
        return (iodefv2_domain_data_get_registration_date(_priv));
}

void IODEFV2domain_data::set_registration_date(iodefv2_time_t *registration_date)
{
        iodefv2_domain_data_set_registration_date(this, registration_date);
}




iodefv2_domain_contacts_t  IODEFV2domain_data::get_domain_contacts()
{
        return (iodefv2_domain_data_get_domain_contacts(_priv));
}

void IODEFV2domain_data::set_domain_contacts(iodefv2_domain_contacts_t *domain_contacts)
{
        iodefv2_domain_data_set_domain_contacts(this, domain_contacts);
}




iodefv2_time_t  IODEFV2domain_data::get_date_domain_was_checked()
{
        return (iodefv2_domain_data_get_date_domain_was_checked(_priv));
}

void IODEFV2domain_data::set_date_domain_was_checked(iodefv2_time_t *date_domain_was_checked)
{
        iodefv2_domain_data_set_date_domain_was_checked(this, date_domain_was_checked);
}




iodefv2_time_t  IODEFV2domain_data::get_expiration_date()
{
        return (iodefv2_domain_data_get_expiration_date(_priv));
}

void IODEFV2domain_data::set_expiration_date(iodefv2_time_t *expiration_date)
{
        iodefv2_domain_data_set_expiration_date(this, expiration_date);
}



/**
 * iodefv2_domain_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_domain_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2domain_data::copy(IODEFV2domain_data *dst)
{
        return iodefv2_domain_data_copy(_priv, dst->_priv);
}



/**
 * iodefv2_domain_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2domain_data *IODEFV2domain_data::clone()
{
        int ret;
        iodefv2_domain_data_t *dst;
        IODEFV2domain_data *ptr;

        ret = iodefv2_domain_data_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2domain_data();
        iodefv2_domain_data_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_domain_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2domain_data::compare(IODEFV2domain_data *obj)
{
        return iodefv2_domain_data_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_hash_data_new:
 * @ret: Pointer where to store the created #iodefv2_hash_data_t object.
 *
 * Create a new #iodefv2_hash_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2hash_data::IODEFV2hash_data()
{
        iodefv2_hash_data_new(&_priv);
}


/**
 * iodefv2_hash_data_destroy:
 * @ptr: pointer to a #iodefv2_hash_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2hash_data::~IODEFV2hash_data()
{
        iodefv2_hash_data_destroy(_priv);
}





iodefv2_hash_data_scope_t * IODEFV2hash_data::get_scope()
{
        return (iodefv2_hash_data_get_scope(_priv));
}

void IODEFV2hash_data::set_scope(iodefv2_hash_data_scope_t scope)
{
        libiodefv2_return_if_fail(ptr);
        ptr->scope = scope;
        ptr->scope_is_set = 1;
}


void IODEFV2hash_data::unset_scope()
{
        iodefv2_hash_data_unset_scope(_priv);
}




std::string  IODEFV2hash_data::get_ext_scope()
{
        return to_string(iodefv2_hash_data_get_ext_scope(_priv));
}

void IODEFV2hash_data::set_ext_scope(libiodefv2_string_t *ext_scope)
{
        iodefv2_hash_data_set_ext_scope(this, ext_scope);
}




std::string  IODEFV2hash_data::get_hash_target_id()
{
        return to_string(iodefv2_hash_data_get_hash_target_id(_priv));
}

void IODEFV2hash_data::set_hash_target_id(libiodefv2_string_t *hash_target_id)
{
        iodefv2_hash_data_set_hash_target_id(this, hash_target_id);
}




iodefv2_hash_t  IODEFV2hash_data::get_hash()
{
        return (iodefv2_hash_data_get_hash(_priv));
}

void IODEFV2hash_data::set_hash(iodefv2_hash_t *hash)
{
        iodefv2_hash_data_set_hash(this, hash);
}




iodefv2_fuzzy_hash_t  IODEFV2hash_data::get_fuzzy_hash()
{
        return (iodefv2_hash_data_get_fuzzy_hash(_priv));
}

void IODEFV2hash_data::set_fuzzy_hash(iodefv2_fuzzy_hash_t *fuzzy_hash)
{
        iodefv2_hash_data_set_fuzzy_hash(this, fuzzy_hash);
}



/**
 * iodefv2_hash_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_hash_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2hash_data::copy(IODEFV2hash_data *dst)
{
        return iodefv2_hash_data_copy(_priv, dst->_priv);
}



/**
 * iodefv2_hash_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2hash_data *IODEFV2hash_data::clone()
{
        int ret;
        iodefv2_hash_data_t *dst;
        IODEFV2hash_data *ptr;

        ret = iodefv2_hash_data_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2hash_data();
        iodefv2_hash_data_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_hash_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2hash_data::compare(IODEFV2hash_data *obj)
{
        return iodefv2_hash_data_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_bulk_observable_format_new:
 * @ret: Pointer where to store the created #iodefv2_bulk_observable_format_t object.
 *
 * Create a new #iodefv2_bulk_observable_format_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2bulk_observable_format::IODEFV2bulk_observable_format()
{
        iodefv2_bulk_observable_format_new(&_priv);
}


/**
 * iodefv2_bulk_observable_format_destroy:
 * @ptr: pointer to a #iodefv2_bulk_observable_format_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2bulk_observable_format::~IODEFV2bulk_observable_format()
{
        iodefv2_bulk_observable_format_destroy(_priv);
}





iodefv2_hash_t  IODEFV2bulk_observable_format::get_hash()
{
        return (iodefv2_bulk_observable_format_get_hash(_priv));
}

void IODEFV2bulk_observable_format::set_hash(iodefv2_hash_t *hash)
{
        iodefv2_bulk_observable_format_set_hash(this, hash);
}



/**
 * iodefv2_bulk_observable_format_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_bulk_observable_format_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2bulk_observable_format::copy(IODEFV2bulk_observable_format *dst)
{
        return iodefv2_bulk_observable_format_copy(_priv, dst->_priv);
}



/**
 * iodefv2_bulk_observable_format_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2bulk_observable_format *IODEFV2bulk_observable_format::clone()
{
        int ret;
        iodefv2_bulk_observable_format_t *dst;
        IODEFV2bulk_observable_format *ptr;

        ret = iodefv2_bulk_observable_format_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2bulk_observable_format();
        iodefv2_bulk_observable_format_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_bulk_observable_format_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2bulk_observable_format::compare(IODEFV2bulk_observable_format *obj)
{
        return iodefv2_bulk_observable_format_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_history_new:
 * @ret: Pointer where to store the created #iodefv2_history_t object.
 *
 * Create a new #iodefv2_history_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2history::IODEFV2history()
{
        iodefv2_history_new(&_priv);
}


/**
 * iodefv2_history_destroy:
 * @ptr: pointer to a #iodefv2_history_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2history::~IODEFV2history()
{
        iodefv2_history_destroy(_priv);
}





iodefv2_history_restriction_t * IODEFV2history::get_restriction()
{
        return (iodefv2_history_get_restriction(_priv));
}

void IODEFV2history::set_restriction(iodefv2_history_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2history::unset_restriction()
{
        iodefv2_history_unset_restriction(_priv);
}



/**
 * iodefv2_history_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_history_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2history::copy(IODEFV2history *dst)
{
        return iodefv2_history_copy(_priv, dst->_priv);
}



/**
 * iodefv2_history_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2history *IODEFV2history::clone()
{
        int ret;
        iodefv2_history_t *dst;
        IODEFV2history *ptr;

        ret = iodefv2_history_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2history();
        iodefv2_history_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_history_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2history::compare(IODEFV2history *obj)
{
        return iodefv2_history_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_discovery_new:
 * @ret: Pointer where to store the created #iodefv2_discovery_t object.
 *
 * Create a new #iodefv2_discovery_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2discovery::IODEFV2discovery()
{
        iodefv2_discovery_new(&_priv);
}


/**
 * iodefv2_discovery_destroy:
 * @ptr: pointer to a #iodefv2_discovery_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2discovery::~IODEFV2discovery()
{
        iodefv2_discovery_destroy(_priv);
}





iodefv2_discovery_source_t * IODEFV2discovery::get_source()
{
        return (iodefv2_discovery_get_source(_priv));
}

void IODEFV2discovery::set_source(iodefv2_discovery_source_t source)
{
        libiodefv2_return_if_fail(ptr);
        ptr->source = source;
        ptr->source_is_set = 1;
}


void IODEFV2discovery::unset_source()
{
        iodefv2_discovery_unset_source(_priv);
}




std::string  IODEFV2discovery::get_ext_restriction()
{
        return to_string(iodefv2_discovery_get_ext_restriction(_priv));
}

void IODEFV2discovery::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_discovery_set_ext_restriction(this, ext_restriction);
}




std::string  IODEFV2discovery::get_ext_source()
{
        return to_string(iodefv2_discovery_get_ext_source(_priv));
}

void IODEFV2discovery::set_ext_source(libiodefv2_string_t *ext_source)
{
        iodefv2_discovery_set_ext_source(this, ext_source);
}




std::string  IODEFV2discovery::get_observable_id()
{
        return to_string(iodefv2_discovery_get_observable_id(_priv));
}

void IODEFV2discovery::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_discovery_set_observable_id(this, observable_id);
}




iodefv2_discovery_restriction_t * IODEFV2discovery::get_restriction()
{
        return (iodefv2_discovery_get_restriction(_priv));
}

void IODEFV2discovery::set_restriction(iodefv2_discovery_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2discovery::unset_restriction()
{
        iodefv2_discovery_unset_restriction(_priv);
}




std::string  IODEFV2discovery::get_description()
{
        return to_string(iodefv2_discovery_get_description(_priv));
}

void IODEFV2discovery::set_description(libiodefv2_string_t *description)
{
        iodefv2_discovery_set_description(this, description);
}



/**
 * iodefv2_discovery_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_discovery_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2discovery::copy(IODEFV2discovery *dst)
{
        return iodefv2_discovery_copy(_priv, dst->_priv);
}



/**
 * iodefv2_discovery_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2discovery *IODEFV2discovery::clone()
{
        int ret;
        iodefv2_discovery_t *dst;
        IODEFV2discovery *ptr;

        ret = iodefv2_discovery_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2discovery();
        iodefv2_discovery_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_discovery_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2discovery::compare(IODEFV2discovery *obj)
{
        return iodefv2_discovery_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_bulk_observable_new:
 * @ret: Pointer where to store the created #iodefv2_bulk_observable_t object.
 *
 * Create a new #iodefv2_bulk_observable_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2bulk_observable::IODEFV2bulk_observable()
{
        iodefv2_bulk_observable_new(&_priv);
}


/**
 * iodefv2_bulk_observable_destroy:
 * @ptr: pointer to a #iodefv2_bulk_observable_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2bulk_observable::~IODEFV2bulk_observable()
{
        iodefv2_bulk_observable_destroy(_priv);
}





iodefv2_bulk_observable_type_t * IODEFV2bulk_observable::get_type()
{
        return (iodefv2_bulk_observable_get_type(_priv));
}

void IODEFV2bulk_observable::set_type(iodefv2_bulk_observable_type_t type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->type = type;
        ptr->type_is_set = 1;
}


void IODEFV2bulk_observable::unset_type()
{
        iodefv2_bulk_observable_unset_type(_priv);
}




std::string  IODEFV2bulk_observable::get_ext_type()
{
        return to_string(iodefv2_bulk_observable_get_ext_type(_priv));
}

void IODEFV2bulk_observable::set_ext_type(libiodefv2_string_t *ext_type)
{
        iodefv2_bulk_observable_set_ext_type(this, ext_type);
}




std::string  IODEFV2bulk_observable::get_bulk_observable_list()
{
        return to_string(iodefv2_bulk_observable_get_bulk_observable_list(_priv));
}

void IODEFV2bulk_observable::set_bulk_observable_list(libiodefv2_string_t *bulk_observable_list)
{
        iodefv2_bulk_observable_set_bulk_observable_list(this, bulk_observable_list);
}




iodefv2_bulk_observable_format_t  IODEFV2bulk_observable::get_bulk_observable_format()
{
        return (iodefv2_bulk_observable_get_bulk_observable_format(_priv));
}

void IODEFV2bulk_observable::set_bulk_observable_format(iodefv2_bulk_observable_format_t *bulk_observable_format)
{
        iodefv2_bulk_observable_set_bulk_observable_format(this, bulk_observable_format);
}



/**
 * iodefv2_bulk_observable_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_bulk_observable_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2bulk_observable::copy(IODEFV2bulk_observable *dst)
{
        return iodefv2_bulk_observable_copy(_priv, dst->_priv);
}



/**
 * iodefv2_bulk_observable_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2bulk_observable *IODEFV2bulk_observable::clone()
{
        int ret;
        iodefv2_bulk_observable_t *dst;
        IODEFV2bulk_observable *ptr;

        ret = iodefv2_bulk_observable_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2bulk_observable();
        iodefv2_bulk_observable_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_bulk_observable_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2bulk_observable::compare(IODEFV2bulk_observable *obj)
{
        return iodefv2_bulk_observable_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_email_data_new:
 * @ret: Pointer where to store the created #iodefv2_email_data_t object.
 *
 * Create a new #iodefv2_email_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2email_data::IODEFV2email_data()
{
        iodefv2_email_data_new(&_priv);
}


/**
 * iodefv2_email_data_destroy:
 * @ptr: pointer to a #iodefv2_email_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2email_data::~IODEFV2email_data()
{
        iodefv2_email_data_destroy(_priv);
}





std::string  IODEFV2email_data::get_observable_id()
{
        return to_string(iodefv2_email_data_get_observable_id(_priv));
}

void IODEFV2email_data::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_email_data_set_observable_id(this, observable_id);
}




std::string  IODEFV2email_data::get_email_headers()
{
        return to_string(iodefv2_email_data_get_email_headers(_priv));
}

void IODEFV2email_data::set_email_headers(libiodefv2_string_t *email_headers)
{
        iodefv2_email_data_set_email_headers(this, email_headers);
}




std::string  IODEFV2email_data::get_email_subject()
{
        return to_string(iodefv2_email_data_get_email_subject(_priv));
}

void IODEFV2email_data::set_email_subject(libiodefv2_string_t *email_subject)
{
        iodefv2_email_data_set_email_subject(this, email_subject);
}




std::string  IODEFV2email_data::get_email_x_mailer()
{
        return to_string(iodefv2_email_data_get_email_x_mailer(_priv));
}

void IODEFV2email_data::set_email_x_mailer(libiodefv2_string_t *email_x_mailer)
{
        iodefv2_email_data_set_email_x_mailer(this, email_x_mailer);
}




std::string  IODEFV2email_data::get_email_from()
{
        return to_string(iodefv2_email_data_get_email_from(_priv));
}

void IODEFV2email_data::set_email_from(libiodefv2_string_t *email_from)
{
        iodefv2_email_data_set_email_from(this, email_from);
}




iodefv2_application_header_t  IODEFV2email_data::get_application_header()
{
        return (iodefv2_email_data_get_application_header(_priv));
}

void IODEFV2email_data::set_application_header(iodefv2_application_header_t *application_header)
{
        iodefv2_email_data_set_application_header(this, application_header);
}




std::string  IODEFV2email_data::get_email_body()
{
        return to_string(iodefv2_email_data_get_email_body(_priv));
}

void IODEFV2email_data::set_email_body(libiodefv2_string_t *email_body)
{
        iodefv2_email_data_set_email_body(this, email_body);
}




std::string  IODEFV2email_data::get_email_message()
{
        return to_string(iodefv2_email_data_get_email_message(_priv));
}

void IODEFV2email_data::set_email_message(libiodefv2_string_t *email_message)
{
        iodefv2_email_data_set_email_message(this, email_message);
}




std::string  IODEFV2email_data::get_email_to()
{
        return to_string(iodefv2_email_data_get_email_to(_priv));
}

void IODEFV2email_data::set_email_to(libiodefv2_string_t *email_to)
{
        iodefv2_email_data_set_email_to(this, email_to);
}



/**
 * iodefv2_email_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_email_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2email_data::copy(IODEFV2email_data *dst)
{
        return iodefv2_email_data_copy(_priv, dst->_priv);
}



/**
 * iodefv2_email_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2email_data *IODEFV2email_data::clone()
{
        int ret;
        iodefv2_email_data_t *dst;
        IODEFV2email_data *ptr;

        ret = iodefv2_email_data_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2email_data();
        iodefv2_email_data_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_email_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2email_data::compare(IODEFV2email_data *obj)
{
        return iodefv2_email_data_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_file_new:
 * @ret: Pointer where to store the created #iodefv2_file_t object.
 *
 * Create a new #iodefv2_file_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2file::IODEFV2file()
{
        iodefv2_file_new(&_priv);
}


/**
 * iodefv2_file_destroy:
 * @ptr: pointer to a #iodefv2_file_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2file::~IODEFV2file()
{
        iodefv2_file_destroy(_priv);
}





std::string  IODEFV2file::get_observable_id()
{
        return to_string(iodefv2_file_get_observable_id(_priv));
}

void IODEFV2file::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_file_set_observable_id(this, observable_id);
}




iodefv2_hash_data_t  IODEFV2file::get_hash_data()
{
        return (iodefv2_file_get_hash_data(_priv));
}

void IODEFV2file::set_hash_data(iodefv2_hash_data_t *hash_data)
{
        iodefv2_file_set_hash_data(this, hash_data);
}




iodefv2_signature_data_t  IODEFV2file::get_signature_data()
{
        return (iodefv2_file_get_signature_data(_priv));
}

void IODEFV2file::set_signature_data(iodefv2_signature_data_t *signature_data)
{
        iodefv2_file_set_signature_data(this, signature_data);
}




std::string  IODEFV2file::get_url()
{
        return to_string(iodefv2_file_get_url(_priv));
}

void IODEFV2file::set_url(libiodefv2_string_t *url)
{
        iodefv2_file_set_url(this, url);
}




iodefv2_software_t  IODEFV2file::get_software()
{
        return (iodefv2_file_get_software(_priv));
}

void IODEFV2file::set_software(iodefv2_software_t *software)
{
        iodefv2_file_set_software(this, software);
}




std::string  IODEFV2file::get_file_name()
{
        return to_string(iodefv2_file_get_file_name(_priv));
}

void IODEFV2file::set_file_name(libiodefv2_string_t *file_name)
{
        iodefv2_file_set_file_name(this, file_name);
}



/**
 * iodefv2_file_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_file_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2file::copy(IODEFV2file *dst)
{
        return iodefv2_file_copy(_priv, dst->_priv);
}



/**
 * iodefv2_file_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2file *IODEFV2file::clone()
{
        int ret;
        iodefv2_file_t *dst;
        IODEFV2file *ptr;

        ret = iodefv2_file_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2file();
        iodefv2_file_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_file_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2file::compare(IODEFV2file *obj)
{
        return iodefv2_file_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_node_new:
 * @ret: Pointer where to store the created #iodefv2_node_t object.
 *
 * Create a new #iodefv2_node_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2node::IODEFV2node()
{
        iodefv2_node_new(&_priv);
}


/**
 * iodefv2_node_destroy:
 * @ptr: pointer to a #iodefv2_node_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2node::~IODEFV2node()
{
        iodefv2_node_destroy(_priv);
}





std::string  IODEFV2node::get_postal_address()
{
        return to_string(iodefv2_node_get_postal_address(_priv));
}

void IODEFV2node::set_postal_address(libiodefv2_string_t *postal_address)
{
        iodefv2_node_set_postal_address(this, postal_address);
}




std::string  IODEFV2node::get_location()
{
        return to_string(iodefv2_node_get_location(_priv));
}

void IODEFV2node::set_location(libiodefv2_string_t *location)
{
        iodefv2_node_set_location(this, location);
}



/**
 * iodefv2_node_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_node_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2node::copy(IODEFV2node *dst)
{
        return iodefv2_node_copy(_priv, dst->_priv);
}



/**
 * iodefv2_node_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2node *IODEFV2node::clone()
{
        int ret;
        iodefv2_node_t *dst;
        IODEFV2node *ptr;

        ret = iodefv2_node_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2node();
        iodefv2_node_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_node_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2node::compare(IODEFV2node *obj)
{
        return iodefv2_node_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_service_new:
 * @ret: Pointer where to store the created #iodefv2_service_t object.
 *
 * Create a new #iodefv2_service_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2service::IODEFV2service()
{
        iodefv2_service_new(&_priv);
}


/**
 * iodefv2_service_destroy:
 * @ptr: pointer to a #iodefv2_service_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2service::~IODEFV2service()
{
        iodefv2_service_destroy(_priv);
}





uint32_t  IODEFV2service::get_ip_protocol()
{
        return (iodefv2_service_get_ip_protocol(_priv));
}

void IODEFV2service::set_ip_protocol(uint32_t ip_protocol)
{
        iodefv2_service_set_ip_protocol(this, ip_protocol);
}




std::string  IODEFV2service::get_observable_id()
{
        return to_string(iodefv2_service_get_observable_id(_priv));
}

void IODEFV2service::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_service_set_observable_id(this, observable_id);
}




uint32_t * IODEFV2service::get_proto_code()
{
        return (iodefv2_service_get_proto_code(_priv));
}

void IODEFV2service::set_proto_code(uint32_t proto_code)
{
        libiodefv2_return_if_fail(ptr);
        ptr->proto_code = proto_code;
        ptr->proto_code_is_set = 1;
}


void IODEFV2service::unset_proto_code()
{
        iodefv2_service_unset_proto_code(_priv);
}




std::string  IODEFV2service::get_portlist()
{
        return to_string(iodefv2_service_get_portlist(_priv));
}

void IODEFV2service::set_portlist(libiodefv2_string_t *portlist)
{
        iodefv2_service_set_portlist(this, portlist);
}




uint32_t * IODEFV2service::get_proto_field()
{
        return (iodefv2_service_get_proto_field(_priv));
}

void IODEFV2service::set_proto_field(uint32_t proto_field)
{
        libiodefv2_return_if_fail(ptr);
        ptr->proto_field = proto_field;
        ptr->proto_field_is_set = 1;
}


void IODEFV2service::unset_proto_field()
{
        iodefv2_service_unset_proto_field(_priv);
}




iodefv2_service_name_t  IODEFV2service::get_service_name()
{
        return (iodefv2_service_get_service_name(_priv));
}

void IODEFV2service::set_service_name(iodefv2_service_name_t *service_name)
{
        iodefv2_service_set_service_name(this, service_name);
}




iodefv2_application_header_t  IODEFV2service::get_application_header()
{
        return (iodefv2_service_get_application_header(_priv));
}

void IODEFV2service::set_application_header(iodefv2_application_header_t *application_header)
{
        iodefv2_service_set_application_header(this, application_header);
}




iodefv2_email_data_t  IODEFV2service::get_email_data()
{
        return (iodefv2_service_get_email_data(_priv));
}

void IODEFV2service::set_email_data(iodefv2_email_data_t *email_data)
{
        iodefv2_service_set_email_data(this, email_data);
}




uint32_t * IODEFV2service::get_proto_type()
{
        return (iodefv2_service_get_proto_type(_priv));
}

void IODEFV2service::set_proto_type(uint32_t proto_type)
{
        libiodefv2_return_if_fail(ptr);
        ptr->proto_type = proto_type;
        ptr->proto_type_is_set = 1;
}


void IODEFV2service::unset_proto_type()
{
        iodefv2_service_unset_proto_type(_priv);
}




uint32_t * IODEFV2service::get_port()
{
        return (iodefv2_service_get_port(_priv));
}

void IODEFV2service::set_port(uint32_t port)
{
        libiodefv2_return_if_fail(ptr);
        ptr->port = port;
        ptr->port_is_set = 1;
}


void IODEFV2service::unset_port()
{
        iodefv2_service_unset_port(_priv);
}



/**
 * iodefv2_service_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_service_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2service::copy(IODEFV2service *dst)
{
        return iodefv2_service_copy(_priv, dst->_priv);
}



/**
 * iodefv2_service_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2service *IODEFV2service::clone()
{
        int ret;
        iodefv2_service_t *dst;
        IODEFV2service *ptr;

        ret = iodefv2_service_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2service();
        iodefv2_service_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_service_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2service::compare(IODEFV2service *obj)
{
        return iodefv2_service_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_file_data_new:
 * @ret: Pointer where to store the created #iodefv2_file_data_t object.
 *
 * Create a new #iodefv2_file_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2file_data::IODEFV2file_data()
{
        iodefv2_file_data_new(&_priv);
}


/**
 * iodefv2_file_data_destroy:
 * @ptr: pointer to a #iodefv2_file_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2file_data::~IODEFV2file_data()
{
        iodefv2_file_data_destroy(_priv);
}





iodefv2_file_data_restriction_t * IODEFV2file_data::get_restriction()
{
        return (iodefv2_file_data_get_restriction(_priv));
}

void IODEFV2file_data::set_restriction(iodefv2_file_data_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2file_data::unset_restriction()
{
        iodefv2_file_data_unset_restriction(_priv);
}




std::string  IODEFV2file_data::get_ext_restriction()
{
        return to_string(iodefv2_file_data_get_ext_restriction(_priv));
}

void IODEFV2file_data::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_file_data_set_ext_restriction(this, ext_restriction);
}




std::string  IODEFV2file_data::get_observable_id()
{
        return to_string(iodefv2_file_data_get_observable_id(_priv));
}

void IODEFV2file_data::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_file_data_set_observable_id(this, observable_id);
}



/**
 * iodefv2_file_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_file_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2file_data::copy(IODEFV2file_data *dst)
{
        return iodefv2_file_data_copy(_priv, dst->_priv);
}



/**
 * iodefv2_file_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2file_data *IODEFV2file_data::clone()
{
        int ret;
        iodefv2_file_data_t *dst;
        IODEFV2file_data *ptr;

        ret = iodefv2_file_data_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2file_data();
        iodefv2_file_data_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_file_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2file_data::compare(IODEFV2file_data *obj)
{
        return iodefv2_file_data_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_system_new:
 * @ret: Pointer where to store the created #iodefv2_system_t object.
 *
 * Create a new #iodefv2_system_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2system::IODEFV2system()
{
        iodefv2_system_new(&_priv);
}


/**
 * iodefv2_system_destroy:
 * @ptr: pointer to a #iodefv2_system_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2system::~IODEFV2system()
{
        iodefv2_system_destroy(_priv);
}





iodefv2_system_category_t  IODEFV2system::get_category()
{
        return (iodefv2_system_get_category(_priv));
}

void IODEFV2system::set_category(iodefv2_system_category_t category)
{
        iodefv2_system_set_category(this, category);
}




iodefv2_system_restriction_t * IODEFV2system::get_restriction()
{
        return (iodefv2_system_get_restriction(_priv));
}

void IODEFV2system::set_restriction(iodefv2_system_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2system::unset_restriction()
{
        iodefv2_system_unset_restriction(_priv);
}




std::string  IODEFV2system::get_ext_restriction()
{
        return to_string(iodefv2_system_get_ext_restriction(_priv));
}

void IODEFV2system::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_system_set_ext_restriction(this, ext_restriction);
}




std::string  IODEFV2system::get_ext_ownership()
{
        return to_string(iodefv2_system_get_ext_ownership(_priv));
}

void IODEFV2system::set_ext_ownership(libiodefv2_string_t *ext_ownership)
{
        iodefv2_system_set_ext_ownership(this, ext_ownership);
}




std::string  IODEFV2system::get_ext_category()
{
        return to_string(iodefv2_system_get_ext_category(_priv));
}

void IODEFV2system::set_ext_category(libiodefv2_string_t *ext_category)
{
        iodefv2_system_set_ext_category(this, ext_category);
}




iodefv2_system_spoofed_t * IODEFV2system::get_spoofed()
{
        return (iodefv2_system_get_spoofed(_priv));
}

void IODEFV2system::set_spoofed(iodefv2_system_spoofed_t spoofed)
{
        libiodefv2_return_if_fail(ptr);
        ptr->spoofed = spoofed;
        ptr->spoofed_is_set = 1;
}


void IODEFV2system::unset_spoofed()
{
        iodefv2_system_unset_spoofed(_priv);
}




iodefv2_system_virtual_t * IODEFV2system::get_virtual()
{
        return (iodefv2_system_get_virtual(_priv));
}

void IODEFV2system::set_virtual_sys(iodefv2_system_virtual_t virtual_sys)
{
        libiodefv2_return_if_fail(ptr);
        ptr->virtual_sys = virtual_sys;
        ptr->virtual_sys_is_set = 1;
}


void IODEFV2system::unset_virtual()
{
        iodefv2_system_unset_virtual(_priv);
}




std::string  IODEFV2system::get_observable_id()
{
        return to_string(iodefv2_system_get_observable_id(_priv));
}

void IODEFV2system::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_system_set_observable_id(this, observable_id);
}




iodefv2_system_ownership_t * IODEFV2system::get_ownership()
{
        return (iodefv2_system_get_ownership(_priv));
}

void IODEFV2system::set_ownership(iodefv2_system_ownership_t ownership)
{
        libiodefv2_return_if_fail(ptr);
        ptr->ownership = ownership;
        ptr->ownership_is_set = 1;
}


void IODEFV2system::unset_ownership()
{
        iodefv2_system_unset_ownership(_priv);
}




std::string  IODEFV2system::get_interface()
{
        return to_string(iodefv2_system_get_interface(_priv));
}

void IODEFV2system::set_interface(libiodefv2_string_t *interface)
{
        iodefv2_system_set_interface(this, interface);
}




iodefv2_node_t  IODEFV2system::get_node()
{
        return (iodefv2_system_get_node(_priv));
}

void IODEFV2system::set_node(iodefv2_node_t *node)
{
        iodefv2_system_set_node(this, node);
}




std::string  IODEFV2system::get_description()
{
        return to_string(iodefv2_system_get_description(_priv));
}

void IODEFV2system::set_description(libiodefv2_string_t *description)
{
        iodefv2_system_set_description(this, description);
}




std::string  IODEFV2system::get_asset_id()
{
        return to_string(iodefv2_system_get_asset_id(_priv));
}

void IODEFV2system::set_asset_id(libiodefv2_string_t *asset_id)
{
        iodefv2_system_set_asset_id(this, asset_id);
}




iodefv2_software_t  IODEFV2system::get_software()
{
        return (iodefv2_system_get_software(_priv));
}

void IODEFV2system::set_software(iodefv2_software_t *software)
{
        iodefv2_system_set_software(this, software);
}



/**
 * iodefv2_system_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_system_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2system::copy(IODEFV2system *dst)
{
        return iodefv2_system_copy(_priv, dst->_priv);
}



/**
 * iodefv2_system_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2system *IODEFV2system::clone()
{
        int ret;
        iodefv2_system_t *dst;
        IODEFV2system *ptr;

        ret = iodefv2_system_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2system();
        iodefv2_system_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_system_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2system::compare(IODEFV2system *obj)
{
        return iodefv2_system_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_record_data_new:
 * @ret: Pointer where to store the created #iodefv2_record_data_t object.
 *
 * Create a new #iodefv2_record_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2record_data::IODEFV2record_data()
{
        iodefv2_record_data_new(&_priv);
}


/**
 * iodefv2_record_data_destroy:
 * @ptr: pointer to a #iodefv2_record_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2record_data::~IODEFV2record_data()
{
        iodefv2_record_data_destroy(_priv);
}





iodefv2_record_data_restriction_t * IODEFV2record_data::get_restriction()
{
        return (iodefv2_record_data_get_restriction(_priv));
}

void IODEFV2record_data::set_restriction(iodefv2_record_data_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2record_data::unset_restriction()
{
        iodefv2_record_data_unset_restriction(_priv);
}




std::string  IODEFV2record_data::get_ext_restriction()
{
        return to_string(iodefv2_record_data_get_ext_restriction(_priv));
}

void IODEFV2record_data::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_record_data_set_ext_restriction(this, ext_restriction);
}




std::string  IODEFV2record_data::get_observable_id()
{
        return to_string(iodefv2_record_data_get_observable_id(_priv));
}

void IODEFV2record_data::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_record_data_set_observable_id(this, observable_id);
}




std::string  IODEFV2record_data::get_description()
{
        return to_string(iodefv2_record_data_get_description(_priv));
}

void IODEFV2record_data::set_description(libiodefv2_string_t *description)
{
        iodefv2_record_data_set_description(this, description);
}




std::string  IODEFV2record_data::get_url()
{
        return to_string(iodefv2_record_data_get_url(_priv));
}

void IODEFV2record_data::set_url(libiodefv2_string_t *url)
{
        iodefv2_record_data_set_url(this, url);
}




iodefv2_time_t  IODEFV2record_data::get_date_time()
{
        return (iodefv2_record_data_get_date_time(_priv));
}

void IODEFV2record_data::set_date_time(iodefv2_time_t *date_time)
{
        iodefv2_record_data_set_date_time(this, date_time);
}




iodefv2_software_t  IODEFV2record_data::get_software()
{
        return (iodefv2_record_data_get_software(_priv));
}

void IODEFV2record_data::set_software(iodefv2_software_t *software)
{
        iodefv2_record_data_set_software(this, software);
}



/**
 * iodefv2_record_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_record_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2record_data::copy(IODEFV2record_data *dst)
{
        return iodefv2_record_data_copy(_priv, dst->_priv);
}



/**
 * iodefv2_record_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2record_data *IODEFV2record_data::clone()
{
        int ret;
        iodefv2_record_data_t *dst;
        IODEFV2record_data *ptr;

        ret = iodefv2_record_data_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2record_data();
        iodefv2_record_data_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_record_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2record_data::compare(IODEFV2record_data *obj)
{
        return iodefv2_record_data_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_record_new:
 * @ret: Pointer where to store the created #iodefv2_record_t object.
 *
 * Create a new #iodefv2_record_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2record::IODEFV2record()
{
        iodefv2_record_new(&_priv);
}


/**
 * iodefv2_record_destroy:
 * @ptr: pointer to a #iodefv2_record_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2record::~IODEFV2record()
{
        iodefv2_record_destroy(_priv);
}





iodefv2_record_restriction_t * IODEFV2record::get_restriction()
{
        return (iodefv2_record_get_restriction(_priv));
}

void IODEFV2record::set_restriction(iodefv2_record_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2record::unset_restriction()
{
        iodefv2_record_unset_restriction(_priv);
}




std::string  IODEFV2record::get_ext_restriction()
{
        return to_string(iodefv2_record_get_ext_restriction(_priv));
}

void IODEFV2record::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_record_set_ext_restriction(this, ext_restriction);
}



/**
 * iodefv2_record_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_record_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2record::copy(IODEFV2record *dst)
{
        return iodefv2_record_copy(_priv, dst->_priv);
}



/**
 * iodefv2_record_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2record *IODEFV2record::clone()
{
        int ret;
        iodefv2_record_t *dst;
        IODEFV2record *ptr;

        ret = iodefv2_record_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2record();
        iodefv2_record_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_record_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2record::compare(IODEFV2record *obj)
{
        return iodefv2_record_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_flow_new:
 * @ret: Pointer where to store the created #iodefv2_flow_t object.
 *
 * Create a new #iodefv2_flow_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2flow::IODEFV2flow()
{
        iodefv2_flow_new(&_priv);
}


/**
 * iodefv2_flow_destroy:
 * @ptr: pointer to a #iodefv2_flow_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2flow::~IODEFV2flow()
{
        iodefv2_flow_destroy(_priv);
}




/**
 * iodefv2_flow_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_flow_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2flow::copy(IODEFV2flow *dst)
{
        return iodefv2_flow_copy(_priv, dst->_priv);
}



/**
 * iodefv2_flow_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2flow *IODEFV2flow::clone()
{
        int ret;
        iodefv2_flow_t *dst;
        IODEFV2flow *ptr;

        ret = iodefv2_flow_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2flow();
        iodefv2_flow_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_flow_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2flow::compare(IODEFV2flow *obj)
{
        return iodefv2_flow_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_event_data_new:
 * @ret: Pointer where to store the created #iodefv2_event_data_t object.
 *
 * Create a new #iodefv2_event_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2event_data::IODEFV2event_data()
{
        iodefv2_event_data_new(&_priv);
}


/**
 * iodefv2_event_data_destroy:
 * @ptr: pointer to a #iodefv2_event_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2event_data::~IODEFV2event_data()
{
        iodefv2_event_data_destroy(_priv);
}





iodefv2_event_data_restriction_t * IODEFV2event_data::get_restriction()
{
        return (iodefv2_event_data_get_restriction(_priv));
}

void IODEFV2event_data::set_restriction(iodefv2_event_data_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2event_data::unset_restriction()
{
        iodefv2_event_data_unset_restriction(_priv);
}




std::string  IODEFV2event_data::get_ext_restriction()
{
        return to_string(iodefv2_event_data_get_ext_restriction(_priv));
}

void IODEFV2event_data::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_event_data_set_ext_restriction(this, ext_restriction);
}




std::string  IODEFV2event_data::get_observable_id()
{
        return to_string(iodefv2_event_data_get_observable_id(_priv));
}

void IODEFV2event_data::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_event_data_set_observable_id(this, observable_id);
}




iodefv2_time_t  IODEFV2event_data::get_detect_time()
{
        return (iodefv2_event_data_get_detect_time(_priv));
}

void IODEFV2event_data::set_detect_time(iodefv2_time_t *detect_time)
{
        iodefv2_event_data_set_detect_time(this, detect_time);
}




iodefv2_time_t  IODEFV2event_data::get_report_time()
{
        return (iodefv2_event_data_get_report_time(_priv));
}

void IODEFV2event_data::set_report_time(iodefv2_time_t *report_time)
{
        iodefv2_event_data_set_report_time(this, report_time);
}




std::string  IODEFV2event_data::get_description()
{
        return to_string(iodefv2_event_data_get_description(_priv));
}

void IODEFV2event_data::set_description(libiodefv2_string_t *description)
{
        iodefv2_event_data_set_description(this, description);
}




iodefv2_record_t  IODEFV2event_data::get_record()
{
        return (iodefv2_event_data_get_record(_priv));
}

void IODEFV2event_data::set_record(iodefv2_record_t *record)
{
        iodefv2_event_data_set_record(this, record);
}




iodefv2_time_t  IODEFV2event_data::get_start_time()
{
        return (iodefv2_event_data_get_start_time(_priv));
}

void IODEFV2event_data::set_start_time(iodefv2_time_t *start_time)
{
        iodefv2_event_data_set_start_time(this, start_time);
}




iodefv2_time_t  IODEFV2event_data::get_end_time()
{
        return (iodefv2_event_data_get_end_time(_priv));
}

void IODEFV2event_data::set_end_time(iodefv2_time_t *end_time)
{
        iodefv2_event_data_set_end_time(this, end_time);
}




iodefv2_assessment_t  IODEFV2event_data::get_assessment()
{
        return (iodefv2_event_data_get_assessment(_priv));
}

void IODEFV2event_data::set_assessment(iodefv2_assessment_t *assessment)
{
        iodefv2_event_data_set_assessment(this, assessment);
}




iodefv2_time_t  IODEFV2event_data::get_recovery_time()
{
        return (iodefv2_event_data_get_recovery_time(_priv));
}

void IODEFV2event_data::set_recovery_time(iodefv2_time_t *recovery_time)
{
        iodefv2_event_data_set_recovery_time(this, recovery_time);
}



/**
 * iodefv2_event_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_event_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2event_data::copy(IODEFV2event_data *dst)
{
        return iodefv2_event_data_copy(_priv, dst->_priv);
}



/**
 * iodefv2_event_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2event_data *IODEFV2event_data::clone()
{
        int ret;
        iodefv2_event_data_t *dst;
        IODEFV2event_data *ptr;

        ret = iodefv2_event_data_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2event_data();
        iodefv2_event_data_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_event_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2event_data::compare(IODEFV2event_data *obj)
{
        return iodefv2_event_data_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_observable_new:
 * @ret: Pointer where to store the created #iodefv2_observable_t object.
 *
 * Create a new #iodefv2_observable_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2observable::IODEFV2observable()
{
        iodefv2_observable_new(&_priv);
}


/**
 * iodefv2_observable_destroy:
 * @ptr: pointer to a #iodefv2_observable_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2observable::~IODEFV2observable()
{
        iodefv2_observable_destroy(_priv);
}





iodefv2_observable_restriction_t * IODEFV2observable::get_restriction()
{
        return (iodefv2_observable_get_restriction(_priv));
}

void IODEFV2observable::set_restriction(iodefv2_observable_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2observable::unset_restriction()
{
        iodefv2_observable_unset_restriction(_priv);
}




std::string  IODEFV2observable::get_ext_restriction()
{
        return to_string(iodefv2_observable_get_ext_restriction(_priv));
}

void IODEFV2observable::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_observable_set_ext_restriction(this, ext_restriction);
}




iodefv2_detection_pattern_t  IODEFV2observable::get_detection_pattern()
{
        return (iodefv2_observable_get_detection_pattern(_priv));
}

void IODEFV2observable::set_detection_pattern(iodefv2_detection_pattern_t *detection_pattern)
{
        iodefv2_observable_set_detection_pattern(this, detection_pattern);
}




iodefv2_service_t  IODEFV2observable::get_service()
{
        return (iodefv2_observable_get_service(_priv));
}

void IODEFV2observable::set_service(iodefv2_service_t *service)
{
        iodefv2_observable_set_service(this, service);
}




iodefv2_system_t  IODEFV2observable::get_system()
{
        return (iodefv2_observable_get_system(_priv));
}

void IODEFV2observable::set_system(iodefv2_system_t *system)
{
        iodefv2_observable_set_system(this, system);
}




iodefv2_domain_data_t  IODEFV2observable::get_domain_data()
{
        return (iodefv2_observable_get_domain_data(_priv));
}

void IODEFV2observable::set_domain_data(iodefv2_domain_data_t *domain_data)
{
        iodefv2_observable_set_domain_data(this, domain_data);
}




iodefv2_email_data_t  IODEFV2observable::get_email_data()
{
        return (iodefv2_observable_get_email_data(_priv));
}

void IODEFV2observable::set_email_data(iodefv2_email_data_t *email_data)
{
        iodefv2_observable_set_email_data(this, email_data);
}




iodefv2_assessment_t  IODEFV2observable::get_assessment()
{
        return (iodefv2_observable_get_assessment(_priv));
}

void IODEFV2observable::set_assessment(iodefv2_assessment_t *assessment)
{
        iodefv2_observable_set_assessment(this, assessment);
}




iodefv2_record_data_t  IODEFV2observable::get_record_data()
{
        return (iodefv2_observable_get_record_data(_priv));
}

void IODEFV2observable::set_record_data(iodefv2_record_data_t *record_data)
{
        iodefv2_observable_set_record_data(this, record_data);
}




iodefv2_reference_t  IODEFV2observable::get_reference()
{
        return (iodefv2_observable_get_reference(_priv));
}

void IODEFV2observable::set_reference(iodefv2_reference_t *reference)
{
        iodefv2_observable_set_reference(this, reference);
}




iodefv2_history_item_t  IODEFV2observable::get_history_item()
{
        return (iodefv2_observable_get_history_item(_priv));
}

void IODEFV2observable::set_history_item(iodefv2_history_item_t *history_item)
{
        iodefv2_observable_set_history_item(this, history_item);
}




iodefv2_bulk_observable_t  IODEFV2observable::get_bulk_observable()
{
        return (iodefv2_observable_get_bulk_observable(_priv));
}

void IODEFV2observable::set_bulk_observable(iodefv2_bulk_observable_t *bulk_observable)
{
        iodefv2_observable_set_bulk_observable(this, bulk_observable);
}




iodefv2_certificate_data_t  IODEFV2observable::get_certificate_data()
{
        return (iodefv2_observable_get_certificate_data(_priv));
}

void IODEFV2observable::set_certificate_data(iodefv2_certificate_data_t *certificate_data)
{
        iodefv2_observable_set_certificate_data(this, certificate_data);
}




iodefv2_expectation_t  IODEFV2observable::get_expectation()
{
        return (iodefv2_observable_get_expectation(_priv));
}

void IODEFV2observable::set_expectation(iodefv2_expectation_t *expectation)
{
        iodefv2_observable_set_expectation(this, expectation);
}




iodefv2_windows_registry_keys_modified_t  IODEFV2observable::get_windows_registry_keys_modified()
{
        return (iodefv2_observable_get_windows_registry_keys_modified(_priv));
}

void IODEFV2observable::set_windows_registry_keys_modified(iodefv2_windows_registry_keys_modified_t *windows_registry_keys_modified)
{
        iodefv2_observable_set_windows_registry_keys_modified(this, windows_registry_keys_modified);
}




iodefv2_address_t  IODEFV2observable::get_address()
{
        return (iodefv2_observable_get_address(_priv));
}

void IODEFV2observable::set_address(iodefv2_address_t *address)
{
        iodefv2_observable_set_address(this, address);
}




iodefv2_event_data_t  IODEFV2observable::get_event_data()
{
        return (iodefv2_observable_get_event_data(_priv));
}

void IODEFV2observable::set_event_data(iodefv2_event_data_t *event_data)
{
        iodefv2_observable_set_event_data(this, event_data);
}




iodefv2_file_data_t  IODEFV2observable::get_file_data()
{
        return (iodefv2_observable_get_file_data(_priv));
}

void IODEFV2observable::set_file_data(iodefv2_file_data_t *file_data)
{
        iodefv2_observable_set_file_data(this, file_data);
}




iodefv2_registry_handle_t  IODEFV2observable::get_registry_handle()
{
        return (iodefv2_observable_get_registry_handle(_priv));
}

void IODEFV2observable::set_registry_handle(iodefv2_registry_handle_t *registry_handle)
{
        iodefv2_observable_set_registry_handle(this, registry_handle);
}



/**
 * iodefv2_observable_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_observable_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2observable::copy(IODEFV2observable *dst)
{
        return iodefv2_observable_copy(_priv, dst->_priv);
}



/**
 * iodefv2_observable_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2observable *IODEFV2observable::clone()
{
        int ret;
        iodefv2_observable_t *dst;
        IODEFV2observable *ptr;

        ret = iodefv2_observable_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2observable();
        iodefv2_observable_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_observable_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2observable::compare(IODEFV2observable *obj)
{
        return iodefv2_observable_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_indicator_expression_new:
 * @ret: Pointer where to store the created #iodefv2_indicator_expression_t object.
 *
 * Create a new #iodefv2_indicator_expression_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2indicator_expression::IODEFV2indicator_expression()
{
        iodefv2_indicator_expression_new(&_priv);
}


/**
 * iodefv2_indicator_expression_destroy:
 * @ptr: pointer to a #iodefv2_indicator_expression_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2indicator_expression::~IODEFV2indicator_expression()
{
        iodefv2_indicator_expression_destroy(_priv);
}





iodefv2_indicator_expression_operator_t * IODEFV2indicator_expression::get_operator()
{
        return (iodefv2_indicator_expression_get_operator(_priv));
}

void IODEFV2indicator_expression::set_operator_indic(iodefv2_indicator_expression_operator_t operator_indic)
{
        libiodefv2_return_if_fail(ptr);
        ptr->operator_indic = operator_indic;
        ptr->operator_indic_is_set = 1;
}


void IODEFV2indicator_expression::unset_operator()
{
        iodefv2_indicator_expression_unset_operator(_priv);
}




std::string  IODEFV2indicator_expression::get_ext_operator()
{
        return to_string(iodefv2_indicator_expression_get_ext_operator(_priv));
}

void IODEFV2indicator_expression::set_ext_operator(libiodefv2_string_t *ext_operator)
{
        iodefv2_indicator_expression_set_ext_operator(this, ext_operator);
}




iodefv2_confidence_t  IODEFV2indicator_expression::get_confidence()
{
        return (iodefv2_indicator_expression_get_confidence(_priv));
}

void IODEFV2indicator_expression::set_confidence(iodefv2_confidence_t *confidence)
{
        iodefv2_indicator_expression_set_confidence(this, confidence);
}



/**
 * iodefv2_indicator_expression_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_indicator_expression_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2indicator_expression::copy(IODEFV2indicator_expression *dst)
{
        return iodefv2_indicator_expression_copy(_priv, dst->_priv);
}



/**
 * iodefv2_indicator_expression_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2indicator_expression *IODEFV2indicator_expression::clone()
{
        int ret;
        iodefv2_indicator_expression_t *dst;
        IODEFV2indicator_expression *ptr;

        ret = iodefv2_indicator_expression_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2indicator_expression();
        iodefv2_indicator_expression_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_indicator_expression_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2indicator_expression::compare(IODEFV2indicator_expression *obj)
{
        return iodefv2_indicator_expression_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_indicator_new:
 * @ret: Pointer where to store the created #iodefv2_indicator_t object.
 *
 * Create a new #iodefv2_indicator_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2indicator::IODEFV2indicator()
{
        iodefv2_indicator_new(&_priv);
}


/**
 * iodefv2_indicator_destroy:
 * @ptr: pointer to a #iodefv2_indicator_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2indicator::~IODEFV2indicator()
{
        iodefv2_indicator_destroy(_priv);
}





iodefv2_indicator_restriction_t * IODEFV2indicator::get_restriction()
{
        return (iodefv2_indicator_get_restriction(_priv));
}

void IODEFV2indicator::set_restriction(iodefv2_indicator_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2indicator::unset_restriction()
{
        iodefv2_indicator_unset_restriction(_priv);
}




std::string  IODEFV2indicator::get_ext_restriction()
{
        return to_string(iodefv2_indicator_get_ext_restriction(_priv));
}

void IODEFV2indicator::set_ext_restriction(libiodefv2_string_t *ext_restriction)
{
        iodefv2_indicator_set_ext_restriction(this, ext_restriction);
}




iodefv2_confidence_t  IODEFV2indicator::get_confidence()
{
        return (iodefv2_indicator_get_confidence(_priv));
}

void IODEFV2indicator::set_confidence(iodefv2_confidence_t *confidence)
{
        iodefv2_indicator_set_confidence(this, confidence);
}




iodefv2_observable_t  IODEFV2indicator::get_observable()
{
        return (iodefv2_indicator_get_observable(_priv));
}

void IODEFV2indicator::set_observable(iodefv2_observable_t *observable)
{
        iodefv2_indicator_set_observable(this, observable);
}




iodefv2_indicator_expression_t  IODEFV2indicator::get_indicator_expression()
{
        return (iodefv2_indicator_get_indicator_expression(_priv));
}

void IODEFV2indicator::set_indicator_expression(iodefv2_indicator_expression_t *indicator_expression)
{
        iodefv2_indicator_set_indicator_expression(this, indicator_expression);
}




iodefv2_time_t  IODEFV2indicator::get_start_time()
{
        return (iodefv2_indicator_get_start_time(_priv));
}

void IODEFV2indicator::set_start_time(iodefv2_time_t *start_time)
{
        iodefv2_indicator_set_start_time(this, start_time);
}




iodefv2_indicator_id_t  IODEFV2indicator::get_indicator_id()
{
        return (iodefv2_indicator_get_indicator_id(_priv));
}

void IODEFV2indicator::set_indicator_id(iodefv2_indicator_id_t *indicator_id)
{
        iodefv2_indicator_set_indicator_id(this, indicator_id);
}




iodefv2_indicator_reference_t  IODEFV2indicator::get_indicator_reference()
{
        return (iodefv2_indicator_get_indicator_reference(_priv));
}

void IODEFV2indicator::set_indicator_reference(iodefv2_indicator_reference_t *indicator_reference)
{
        iodefv2_indicator_set_indicator_reference(this, indicator_reference);
}




iodefv2_observable_reference_t  IODEFV2indicator::get_observable_reference()
{
        return (iodefv2_indicator_get_observable_reference(_priv));
}

void IODEFV2indicator::set_observable_reference(iodefv2_observable_reference_t *observable_reference)
{
        iodefv2_indicator_set_observable_reference(this, observable_reference);
}




iodefv2_time_t  IODEFV2indicator::get_end_time()
{
        return (iodefv2_indicator_get_end_time(_priv));
}

void IODEFV2indicator::set_end_time(iodefv2_time_t *end_time)
{
        iodefv2_indicator_set_end_time(this, end_time);
}



/**
 * iodefv2_indicator_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_indicator_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2indicator::copy(IODEFV2indicator *dst)
{
        return iodefv2_indicator_copy(_priv, dst->_priv);
}



/**
 * iodefv2_indicator_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2indicator *IODEFV2indicator::clone()
{
        int ret;
        iodefv2_indicator_t *dst;
        IODEFV2indicator *ptr;

        ret = iodefv2_indicator_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2indicator();
        iodefv2_indicator_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_indicator_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2indicator::compare(IODEFV2indicator *obj)
{
        return iodefv2_indicator_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_indicator_data_new:
 * @ret: Pointer where to store the created #iodefv2_indicator_data_t object.
 *
 * Create a new #iodefv2_indicator_data_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2indicator_data::IODEFV2indicator_data()
{
        iodefv2_indicator_data_new(&_priv);
}


/**
 * iodefv2_indicator_data_destroy:
 * @ptr: pointer to a #iodefv2_indicator_data_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2indicator_data::~IODEFV2indicator_data()
{
        iodefv2_indicator_data_destroy(_priv);
}




/**
 * iodefv2_indicator_data_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_indicator_data_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2indicator_data::copy(IODEFV2indicator_data *dst)
{
        return iodefv2_indicator_data_copy(_priv, dst->_priv);
}



/**
 * iodefv2_indicator_data_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2indicator_data *IODEFV2indicator_data::clone()
{
        int ret;
        iodefv2_indicator_data_t *dst;
        IODEFV2indicator_data *ptr;

        ret = iodefv2_indicator_data_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2indicator_data();
        iodefv2_indicator_data_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_indicator_data_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2indicator_data::compare(IODEFV2indicator_data *obj)
{
        return iodefv2_indicator_data_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_incident_new:
 * @ret: Pointer where to store the created #iodefv2_incident_t object.
 *
 * Create a new #iodefv2_incident_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2incident::IODEFV2incident()
{
        iodefv2_incident_new(&_priv);
}


/**
 * iodefv2_incident_destroy:
 * @ptr: pointer to a #iodefv2_incident_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
IODEFV2incident::~IODEFV2incident()
{
        iodefv2_incident_destroy(_priv);
}





iodefv2_incident_status_t  IODEFV2incident::get_status()
{
        return (iodefv2_incident_get_status(_priv));
}

void IODEFV2incident::set_status(iodefv2_incident_status_t status)
{
        iodefv2_incident_set_status(this, status);
}




iodefv2_incident_lang_t * IODEFV2incident::get_lang()
{
        return (iodefv2_incident_get_lang(_priv));
}

void IODEFV2incident::set_lang(iodefv2_incident_lang_t lang)
{
        libiodefv2_return_if_fail(ptr);
        ptr->lang = lang;
        ptr->lang_is_set = 1;
}


void IODEFV2incident::unset_lang()
{
        iodefv2_incident_unset_lang(_priv);
}




std::string  IODEFV2incident::get_ext_purpose()
{
        return to_string(iodefv2_incident_get_ext_purpose(_priv));
}

void IODEFV2incident::set_ext_purpose(libiodefv2_string_t *ext_purpose)
{
        iodefv2_incident_set_ext_purpose(this, ext_purpose);
}




iodefv2_incident_purpose_t  IODEFV2incident::get_purpose()
{
        return (iodefv2_incident_get_purpose(_priv));
}

void IODEFV2incident::set_purpose(iodefv2_incident_purpose_t purpose)
{
        iodefv2_incident_set_purpose(this, purpose);
}




std::string  IODEFV2incident::get_ext_status()
{
        return to_string(iodefv2_incident_get_ext_status(_priv));
}

void IODEFV2incident::set_ext_status(libiodefv2_string_t *ext_status)
{
        iodefv2_incident_set_ext_status(this, ext_status);
}




iodefv2_incident_restriction_t * IODEFV2incident::get_restriction()
{
        return (iodefv2_incident_get_restriction(_priv));
}

void IODEFV2incident::set_restriction(iodefv2_incident_restriction_t restriction)
{
        libiodefv2_return_if_fail(ptr);
        ptr->restriction = restriction;
        ptr->restriction_is_set = 1;
}


void IODEFV2incident::unset_restriction()
{
        iodefv2_incident_unset_restriction(_priv);
}




std::string  IODEFV2incident::get_observable_id()
{
        return to_string(iodefv2_incident_get_observable_id(_priv));
}

void IODEFV2incident::set_observable_id(libiodefv2_string_t *observable_id)
{
        iodefv2_incident_set_observable_id(this, observable_id);
}




iodefv2_history_t  IODEFV2incident::get_history()
{
        return (iodefv2_incident_get_history(_priv));
}

void IODEFV2incident::set_history(iodefv2_history_t *history)
{
        iodefv2_incident_set_history(this, history);
}




iodefv2_time_t  IODEFV2incident::get_start_time()
{
        return (iodefv2_incident_get_start_time(_priv));
}

void IODEFV2incident::set_start_time(iodefv2_time_t *start_time)
{
        iodefv2_incident_set_start_time(this, start_time);
}




iodefv2_alternative_id_t  IODEFV2incident::get_alternative_id()
{
        return (iodefv2_incident_get_alternative_id(_priv));
}

void IODEFV2incident::set_alternative_id(iodefv2_alternative_id_t *alternative_id)
{
        iodefv2_incident_set_alternative_id(this, alternative_id);
}




iodefv2_related_activity_t  IODEFV2incident::get_related_activity()
{
        return (iodefv2_incident_get_related_activity(_priv));
}

void IODEFV2incident::set_related_activity(iodefv2_related_activity_t *related_activity)
{
        iodefv2_incident_set_related_activity(this, related_activity);
}




iodefv2_time_t  IODEFV2incident::get_end_time()
{
        return (iodefv2_incident_get_end_time(_priv));
}

void IODEFV2incident::set_end_time(iodefv2_time_t *end_time)
{
        iodefv2_incident_set_end_time(this, end_time);
}




iodefv2_time_t  IODEFV2incident::get_generation_time()
{
        return (iodefv2_incident_get_generation_time(_priv));
}

void IODEFV2incident::set_generation_time(iodefv2_time_t *generation_time)
{
        iodefv2_incident_set_generation_time(this, generation_time);
}




iodefv2_time_t  IODEFV2incident::get_recovery_time()
{
        return (iodefv2_incident_get_recovery_time(_priv));
}

void IODEFV2incident::set_recovery_time(iodefv2_time_t *recovery_time)
{
        iodefv2_incident_set_recovery_time(this, recovery_time);
}




iodefv2_time_t  IODEFV2incident::get_detect_time()
{
        return (iodefv2_incident_get_detect_time(_priv));
}

void IODEFV2incident::set_detect_time(iodefv2_time_t *detect_time)
{
        iodefv2_incident_set_detect_time(this, detect_time);
}




iodefv2_time_t  IODEFV2incident::get_report_time()
{
        return (iodefv2_incident_get_report_time(_priv));
}

void IODEFV2incident::set_report_time(iodefv2_time_t *report_time)
{
        iodefv2_incident_set_report_time(this, report_time);
}




std::string  IODEFV2incident::get_description()
{
        return to_string(iodefv2_incident_get_description(_priv));
}

void IODEFV2incident::set_description(libiodefv2_string_t *description)
{
        iodefv2_incident_set_description(this, description);
}




iodefv2_indicator_data_t  IODEFV2incident::get_indicator_data()
{
        return (iodefv2_incident_get_indicator_data(_priv));
}

void IODEFV2incident::set_indicator_data(iodefv2_indicator_data_t *indicator_data)
{
        iodefv2_incident_set_indicator_data(this, indicator_data);
}




iodefv2_incident_id_t  IODEFV2incident::get_incident_id()
{
        return (iodefv2_incident_get_incident_id(_priv));
}

void IODEFV2incident::set_incident_id(iodefv2_incident_id_t *incident_id)
{
        iodefv2_incident_set_incident_id(this, incident_id);
}



/**
 * iodefv2_incident_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_incident_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2incident::copy(IODEFV2incident *dst)
{
        return iodefv2_incident_copy(_priv, dst->_priv);
}



/**
 * iodefv2_incident_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2incident *IODEFV2incident::clone()
{
        int ret;
        iodefv2_incident_t *dst;
        IODEFV2incident *ptr;

        ret = iodefv2_incident_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2incident();
        iodefv2_incident_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_incident_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2incident::compare(IODEFV2incident *obj)
{
        return iodefv2_incident_compare(_priv, obj->_priv);
}


    

/**
 * iodefv2_document_new:
 * @ret: Pointer where to store the created #iodefv2_document_t object.
 *
 * Create a new #iodefv2_document_t object.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2document::IODEFV2document()
{
        iodefv2_document_new(&_priv);
}







iodefv2_document_lang_t  IODEFV2document::get_lang()
{
        return (iodefv2_document_get_lang(_priv));
}

void IODEFV2document::set_lang(iodefv2_document_lang_t lang)
{
        iodefv2_document_set_lang(this, lang);
}




std::string  IODEFV2document::get_formatid()
{
        return to_string(iodefv2_document_get_formatid(_priv));
}

void IODEFV2document::set_formatid(libiodefv2_string_t *formatid)
{
        iodefv2_document_set_formatid(this, formatid);
}




std::string  IODEFV2document::get_version()
{
        return to_string(iodefv2_document_get_version(_priv));
}

void IODEFV2document::set_version(libiodefv2_string_t *version)
{
        iodefv2_document_set_version(this, version);
}




std::string  IODEFV2document::get_private_enum_name()
{
        return to_string(iodefv2_document_get_private_enum_name(_priv));
}

void IODEFV2document::set_private_enum_name(libiodefv2_string_t *private_enum_name)
{
        iodefv2_document_set_private_enum_name(this, private_enum_name);
}




std::string  IODEFV2document::get_private_enum_id()
{
        return to_string(iodefv2_document_get_private_enum_id(_priv));
}

void IODEFV2document::set_private_enum_id(libiodefv2_string_t *private_enum_id)
{
        iodefv2_document_set_private_enum_id(this, private_enum_id);
}



/**
 * iodefv2_document_copy:
 * @src: Source of the copy.
 * @dst: Where to copy the object.
 *
 * Copy a new #iodefv2_document_t object from @src to @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
int IODEFV2document::copy(IODEFV2document *dst)
{
        return iodefv2_document_copy(_priv, dst->_priv);
}



/**
 * iodefv2_document_clone:
 * @src: Object to be cloned.
 * @dst: Address where to store the pointer to the cloned object.
 *
 * Create a copy of @src, and store it in @dst.
 *
 * Returns: 0 on success, a negative value if an error occured.
 */
IODEFV2document *IODEFV2document::clone()
{
        int ret;
        iodefv2_document_t *dst;
        IODEFV2document *ptr;

        ret = iodefv2_document_clone(_priv, &dst);
        if ( ret < 0 )
                throw LibIdemfv2Error(ret);

        ptr = new IODEFV2document();
        iodefv2_document_destroy(ptr->_priv);
        ptr->_priv = dst;

        return ptr;
}


/**
 * iodefv2_document_compare:
 * @obj1: Object to compare with @obj2.
 * @obj2: Object to compare with @obj1.
 *
 * Compare @obj1 with @obj2.
 *
 * Returns: 0 on match, a negative value on comparison failure.
 */
int IODEFV2document::compare(IODEFV2document *obj)
{
        return iodefv2_document_compare(_priv, obj->_priv);
}



void IODEFV2Message::set_pmsg(libiodefv2_msg_t *msg)
{
        iodefv2_document_set_pmsg(_priv, msg);
}


libiodefv2_msg_t *IODEFV2Message::get_pmsg()
{
        return iodefv2_document_get_pmsg(_priv);
}


/**
 * iodefv2_document_destroy:
 * @ptr: pointer to a #iodefv2_document_t object.
 *
 * Destroy @ptr and all of it's children.
 * The objects are only destroyed if their reference count reach zero.
 */
void IODEFV2Message::~IODEFV2Message()
{
        iodefv2_document_destroy(_priv);
}


